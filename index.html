<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>PV-One App v3 Lite - iPad Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<!-- PWA Meta Tags -->
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="PV-One v3 Lite" />
<!-- meta[name=theme-color] is not supported by Firefox, Opera. Kept for Chrome/Android. -->
<script>
  // Only add theme-color meta tag for browsers that support it (Chrome/Safari/Edge)
  if (window.chrome || (navigator.userAgent.indexOf('Safari') > -1 && navigator.userAgent.indexOf('Chrome') === -1) || navigator.userAgent.indexOf('Edge') > -1) {
    document.head.insertAdjacentHTML('beforeend', '<meta name="theme-color" content="#002b5c" />');
  }
</script>
<meta name="description" content="Pressure-Volume Loop Analysis & Hemodynamic Monitoring for Cardiogenic Shock" />

<!-- PWA Manifest removed to disable installability/banner -->
<!-- <link rel="manifest" href="manifest.json" /> -->

<!-- Icons -->
<!-- Favicon for browsers -->
<link rel="icon" type="image/x-icon" href="Logo-ITAMEX.ico" />
<!-- Apple/iOS home screen icon (PNG recommended). If missing, iOS will fallback to a screenshot. -->
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />
<!-- Safari pinned tab (macOS) -->
<link rel="mask-icon" href="Logo-ITAMEX.svg" color="#002b5c" />

<!-- Web Bridge: Reemplaza Electron API con localStorage -->
<script src="web-bridge.js"></script>

<!-- Service Worker Registration -->
<script>
  // Registrar Service Worker para PWA offline
  // Only attempt registration in supported/secure contexts (HTTPS or localhost).
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      // service workers require a secure origin (HTTPS) or localhost.
      const isLocalhost = Boolean(
        location.hostname === 'localhost' ||
        location.hostname === '127.0.0.1' ||
        location.hostname === '[::1]'
      );

      const canRegister = window.isSecureContext || isLocalhost || location.protocol === 'https:';

      if (!canRegister) {
        // Friendly info for local file loads (file://) or other unsupported origins.
        console.info('⚠️ Service Worker not registered: current origin is not a secure context (HTTPS/localhost required).');
        return;
      }

      navigator.serviceWorker.register('./service-worker.js')
        .then(registration => {
          console.log('✅ Service Worker registered:', registration.scope);

          // Verificar actualizaciones cada 30 minutos
          setInterval(() => {
            registration.update();
          }, 1800000);
        })
        .catch(error => {
          console.warn('❌ Service Worker registration failed:', error);
        });
    });
  }
  
  // Removed install prompt handling and suppression; install banner is disabled by removing the manifest link above.
</script>

<script>
  // Lightweight Plotly loader: exposes window.loadPlotly() which returns a Promise.
  (function(){
    const CDN = 'https://cdn.plot.ly/plotly-2.35.3.min.js';
    function load(){
      return new Promise((resolve,reject)=>{
        if(window.Plotly && typeof window.Plotly.newPlot === 'function') return resolve(window.Plotly);
        const existing = Array.from(document.getElementsByTagName('script')).find(s=> s.src && s.src.indexOf('plotly') !== -1);
        if(existing){
          existing.addEventListener('load', ()=> resolve(window.Plotly));
          existing.addEventListener('error', ()=> reject(new Error('failed to load existing script')));
          return;
        }
        const s = document.createElement('script'); s.src = CDN; s.async = true;
        s.onload = ()=> resolve(window.Plotly); s.onerror = ()=> reject(new Error('failed to load plotly'));
        document.head.appendChild(s);
      });
    }
    window.loadPlotly = load;
    // Start loading Plotly in background so legacy direct calls succeed quickly
    try{ window.loadPlotly().catch(()=>{}); }catch(e){}
  })();
</script>

<script>
  // Ensure a minimal byId helper is available early for scripts that run before the main helpers are declared
  if (typeof window.byId !== 'function') {
    window.byId = function(id){ return document.getElementById(id); };
  }
</script>
<script src="scripts/perf.js"></script>
<script src="alarms.bundle.js"></script>
<script src="lib/variablesbuild.js"></script>
<script>
// Preserve alarm rules loaded from alarms.bundle.js and merge any custom rules from localStorage.
// Previously this block cleared window.ALARM_RULES, which hid built-in sections like MCS-specific.
try {
  // Keep a copy of the original rules if available
  if (Array.isArray(window.ALARM_RULES) && window.ALARM_RULES.length) {
    window._ALARM_RULES_ORIGINAL = window._ALARM_RULES_ORIGINAL || window.ALARM_RULES.slice();
  }
  // Ensure arrays exist
  window.ALARM_RULES = Array.isArray(window.ALARM_RULES) ? window.ALARM_RULES : (Array.isArray(window._ALARM_RULES_ORIGINAL) ? window._ALARM_RULES_ORIGINAL.slice() : []);
  window.ALARM_RULES_EXTRA = Array.isArray(window.ALARM_RULES_EXTRA) ? window.ALARM_RULES_EXTRA : [];

  // Auto-load custom alarm rules from localStorage (pv-one-custom-alarms)
  const s = localStorage.getItem('pv-one-custom-alarms');
  if (s) {
    const parsed = JSON.parse(s);
    if (Array.isArray(parsed) && parsed.length) {
      const group = { subtitle: 'Custom rules (localStorage)', items: parsed.map((r, idx) => {
        const expr = r.expression || r.expr || r.rule || '';
        return {
          expr,
          label: r.name || r.label || r.tag || '',
          id: r.id || r.tag || `local_${idx}`,
          clinical: r.clinical || r.clin || r.description || '',
          suggest: r.suggest || '',
          color: (r.severity === 'critical' ? 'critical' : (r.severity === 'wean_ok' ? 'wean_ok' : (r.severity === 'improving' ? 'improving' : 'warning')))
        };
      }) };

      // remove any previous local group to avoid duplicates, then prepend (keeping bundled rules intact)
      window.ALARM_RULES = (window.ALARM_RULES || []).filter(g => g.subtitle !== 'Custom rules (localStorage)');
      window.ALARM_RULES.unshift(group);
    }
  }
} catch (e) { console.warn('Alarm rules init failed', e); }
</script>
<script src="lib/formulas.js"></script>
<script src="lib/logic.js"></script>
<script src="lib/renderers.js"></script>
<style>
      /* alignment helper for Hemodynamic Gauges header + controls */
      .hemo-header-group{display:flex;align-items:center;gap:10px}
      @media (max-width:800px){
        .hemo-header-group{justify-content:center;width:100%}
        #gaugeTimeControls{margin-left:4px}
      }
  :root{
    --bg:#ffffff;--panel:#f6f8fc;--ink:#0b1b33;--pri:#0f2447;--acc:#1f6fff;
    --ok:#16a34a;--warn:#f59e0b;--bad:#dc2626;--line:#d7e1f6;
    /* Official CSWG‑SCAI palette (exposed for JS + CSS theming) */
    --scai-a: #10b981; /* Stage A — green */
    --scai-b: #1f6fff; /* Stage B — blue  */
    --scai-c: #f59e0b; /* Stage C — amber */
    --scai-d: #ef4444; /* Stage D — red   */
    --scai-e: #6b7280; /* Stage E — neutral/gray */
  }

  /* iPad y móviles: estilos táctiles mejorados */
  @media (hover: none) and (pointer: coarse) {
    /* Aumentar tamaño de botones para touch */
    .btn{ min-height:44px; min-width:44px; padding:10px 14px; font-size:16px }
    input, select, textarea{ min-height:44px; font-size:16px; padding:10px 12px }
    .tab{ min-height:40px; padding:10px 14px; font-size:15px }
    
    /* Mejorar interacción táctil */
    button, .btn, .tab, select, input[type="checkbox"], input[type="radio"] {
      -webkit-tap-highlight-color: rgba(31, 111, 255, 0.1);
    }
  }
  
  /* iPad específico: optimizar layout */
  @media (max-width: 1024px) {
    .grid{ grid-template-columns: 1fr; }
    .gaugeGrid{ grid-template-columns: repeat(2, 1fr); }
    .container{ padding: 10px 12px; }
  }
  
  /* Prevenir zoom en inputs en iOS */
  @supports (-webkit-touch-callout: none) {
    input, select, textarea {
      font-size: 16px !important;
    }
  }

  /* Clinic theme overrides */
  .clinic-theme{ --clinic-bg: #f6fbfb; --clinic-panel:#ffffff; --clinic-accent:#0ea5a4; --clinic-muted:#6b8a8a; --clinic-text:#000000; --clinic-text-secondary:#334155; }
  .clinic-theme .card, .clinic-theme .tpCard{ background: var(--clinic-panel); border:1px solid rgba(14,165,164,0.06); box-shadow: 0 6px 18px rgba(14,165,164,0.04); }
  .clinic-theme h2{ color: var(--clinic-accent); }
  .clinic-theme .small{ color: var(--clinic-muted); }
  /* Align Clinic smart alarms palette with dashboard */
  .clinic-theme .status.improve{ background:#eaf2fe; color:#1f6fff; border:1px solid #bcd3ff }
  /* In Clinic Panel, show "improving" (🟢) with green background */
  .clinic-theme .status.improve{ background:#eaf7f0 !important; color:#00461b !important; border:1px solid #aee3c0 !important }
  .clinic-theme .pill, .clinic-theme .pill small{ background: rgba(14,165,164,0.08); color:var(--clinic-accent); }
  .clinic-theme .gauge-plot .number{ color: var(--clinic-accent); }
  
  /* Dark mode suave: pupil-friendly, reduced halation, no extremes */
  body.dark .clinic-theme{
    --clinic-bg:#0d1117;          /* casi negro, no puro (L*≈11) */
    --clinic-panel:#0f172a;       /* surface panel */
    --clinic-text:#e6edf3;        /* off-white cómodo (L*≈92) */
    --clinic-text-secondary:#b6c2cf;
    --clinic-muted:#c2e4ff;
    --clinic-accent:#3aa7a4;      /* teal desaturado */

    /* Estados suaves y legibles */
    --c-info:#5f8ffd;             /* azul menos chillón */
    --c-success:#2db37b;
    --c-warning:#f2b642;
    --c-danger:#e86b6b;

    /* Alphas estándar */
    --a-weak:0.12; --a-mid:0.20; --a-strong:0.28;

    /* PV plot colors */
    --c-chart-1:#5f8ffd;
    --c-chart-2:#ff8a47;
    --c-chart-prev:#41b6ea;
    --c-chart-fill:rgba(95,143,253,0.10);
    --c-grid:rgba(230,237,243,0.06);

    color-scheme: dark;
  }

  body.dark .clinic-theme{ background:var(--clinic-bg); color:var(--clinic-text); }
  body.dark .clinic-theme .card, body.dark .clinic-theme .tpCard{
    background:var(--clinic-panel);
    border:1px solid rgba(147,166,182,0.18);
    box-shadow:0 6px 18px rgba(0,0,0,0.30);
  }

  /* Tipografía amigable */
  body.dark .clinic-theme h2{ color:var(--clinic-accent); font-weight:600; }
  body.dark .clinic-theme h3, body.dark .clinic-theme h4, body.dark .clinic-theme strong{ color:var(--clinic-text); }
  body.dark .clinic-theme .small{ color:var(--clinic-muted); }
  body.dark .clinic-theme p{ line-height:1.55; }

  /* Botones con alpha suave */
  body.dark .clinic-theme .btn{
    background: color-mix(in srgb, var(--clinic-accent) calc(var(--a-mid)*100%), transparent);
    color: var(--clinic-text);
    border:1px solid color-mix(in srgb, var(--clinic-accent) 38%, transparent);
  }
  body.dark .clinic-theme .btn:hover{
    background: color-mix(in srgb, var(--clinic-accent) calc(var(--a-strong)*100%), transparent);
  }

  /* Pills */
  body.dark .clinic-theme .pill{
    background: color-mix(in srgb, var(--clinic-accent) calc(var(--a-weak)*100%), transparent);
    color: var(--clinic-accent);
  }

  /* Estados (fondos translúcidos + texto legible AA) */
  body.dark .clinic-theme .status{ color:var(--clinic-text)!important; }
  body.dark .clinic-theme .status.improve{
    background: color-mix(in srgb, var(--c-success) calc(var(--a-mid)*100%), transparent);
  /* Fallback for color-mix not supported in Chrome < 111 */
  color: #2db37b !important;
  /* Fallback for color-mix not supported in Chrome < 111 */
  border:1px solid #aee3c0 !important;
  }
  body.dark .clinic-theme .status.stable{
    /* Keep same palette as light mode for Clinic Panel */
    background:#eaf7f0 !important;
    color:#137a3a !important;
    border:1px solid #aee3c0 !important;
  }
  body.dark .clinic-theme .status.worse{
    /* Keep same palette as light mode for Clinic Panel */
    background:#ffebee !important;
    color:#dc2626 !important;
    border:1px solid #ffc3c8 !important;
  }
  /* Stage walker time labels: default dark-gray in light mode, bright text in dark mode */
  .stage-time{ color: #374151; }
  body.dark .stage-time{ color: var(--dark-text) !important; }
  
  /* Additional dark-mode contrast fixes: ensure inputs, pills, buttons and variable chips
     keep readable foreground and borders against dark backgrounds. This complements the
     existing clinic-theme overrides and targets edge cases where inline styles or
     component-specific backgrounds made text hard to read. */
  body.dark input, body.dark select, body.dark textarea, body.dark .btn, body.dark .pill,
  body.dark .variable-item, body.dark .summaryBox, body.dark .category-title, body.dark .variable-category h4 {
    background: var(--dark-panel) !important;
    color: var(--dark-text) !important;
    border-color: var(--dark-border) !important;
  }

  /* Clinic-specific tighter overrides to keep clinic-theme look but improve contrast */
  body.dark .clinic-theme .variable-item{
    background: transparent !important;
    color: var(--dark-text) !important;
    border-color: rgba(147,166,182,0.06) !important;
  }

  /* Make scrollbars and small accents visible in dark mode */
  body.dark .variable-list::-webkit-scrollbar{ height:8px; width:8px }
  body.dark .variable-list::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.08); border-radius:6px }

  /* Ensure summaryBox and expression textarea are legible */
  body.dark .summaryBox, body.dark #expressionPreview, body.dark .modal-content{ background: var(--dark-panel) !important; color: var(--dark-text) !important; border-color: var(--dark-border) !important }

  /* Buttons variant: ensure primary buttons remain readable on dark backgrounds */
  body.dark .btn.primary{ background: var(--clinic-accent) !important; color: #fff !important; border-color: rgba(58,167,164,0.6) !important }

  /* Dark mode warning (amber) for Clinic Panel */
  body.dark .clinic-theme .status.warning{
    /* Keep same palette as light mode for Clinic Panel */
    background:#fff8ea !important;
    color:#8a6b30 !important;
    border:1px solid #ffdf9e !important;
  }

  /* Ensure titles inside alarm cards don't get overridden to white in dark mode */
  .clinic-theme .status strong{ color: inherit !important; }

  /* Clinic/Suggest inline text in dark: set to 80% opacity */
  body.dark .clinic-theme .status div[style*="color:#666"]{
    color: rgba(126, 126, 126, 0.8) !important;
  }

  /* PV plot con grid muy tenue */
  body.dark .clinic-theme #clinicPVPlot{ background:transparent; }

  /* Generic popover (menus, dropdowns) — light by default, dark override */
  .popover{ background:#fff; border:1px solid #dfe8ff; color:#0b1b33; }
  body.dark .popover{ background:var(--dark-panel); border:1px solid var(--dark-border) !important; color:var(--dark-text); }
  body.dark .clinic-theme .pv-line-1{ stroke:var(--c-chart-1); }
  body.dark .clinic-theme .pv-line-2{ stroke:var(--c-chart-2); }

  /* Stronger dark-mode rules for Trends small-multiples */
  body.dark .trends-grid-2x2{
    gap:18px;
    padding:8px 0;
    align-items:start;
  }
  body.dark .trends-cell{
    background: var(--dark-panel) !important;
    border: 1px solid var(--dark-border) !important;
    box-shadow: 0 6px 18px rgba(0,0,0,0.45);
    padding:6px !important;
    border-radius:6px;
    color: var(--dark-text) !important;
  }

  /* Make Plotly tick labels and annotations readable in dark mode */
  body.dark .trends-cell .xtick text,
  body.dark .trends-cell .ytick text,
  body.dark .trends-cell .annotation-text,
  body.dark .trends-cell .gtitle,
  body.dark .trends-cell .legendtext {
    fill: var(--dark-text) !important;
    color: var(--dark-text) !important;
    opacity: 0.92 !important;
  }

  /* Ensure x-axis titles visible on bottom panels */
  body.dark .trends-cell .xaxislayer-above .xtitle,
  body.dark .trends-cell .xaxislayer-below .xtitle{
    fill: var(--dark-text) !important;
  }

  /* Reduce halation of tiny tick markers */
  body.dark .trends-cell .tick line{ stroke: rgba(230,237,243,0.12) !important; }

  /* Improve contrast for dropdowns and inputs inside Trends */
  body.dark .selTrVar, body.dark select[id^="selTrVar_"]{ background: var(--dark-panel) !important; color: var(--dark-text) !important; border-color: var(--dark-border) !important }
  body.dark .clinic-theme .pv-line-prev{ stroke:var(--c-chart-prev); stroke-dasharray:6 6; }
  body.dark .clinic-theme .pv-fill{ fill:var(--c-chart-fill); }
  body.dark .clinic-theme .pv-grid line{ stroke:var(--c-grid); }

  /* Recommendation boxes */
  body.dark .clinic-theme .recommendation{
    background: color-mix(in srgb, var(--c-info) calc(var(--a-mid)*100%), transparent) !important;
  /* Fallback for color-mix not supported in Chrome < 111 */
  border-left-color: #5f8ffd !important;
    color: var(--clinic-text) !important;
  }

  /* Accesibilidad: foco visible */
  body.dark .clinic-theme :focus-visible{
  /* Fallback for color-mix not supported in Chrome < 111 */
  outline:2px solid #0ea5a4;
    outline-offset:2px;
  }

  /* Alarm badges dark mode: ensure labels are bright and visible */
  body.dark .clinic-theme .agg-badge div:last-child{
    color: var(--clinic-text) !important;
  }
  body.dark .clinic-theme #clinicAlarmBadges .agg-badge div[style*="color:#234"]{
    color: var(--clinic-text) !important;
  }

  *{box-sizing:border-box}
  /* Slightly larger base font for improved legibility across the app */
  html,body{font-size:16px}
  body{font-family:Inter,Arial,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:0;background:var(--bg);color:var(--ink)}
  header{background:linear-gradient(90deg,#0b2d66,#154ea8);color:#fff;padding:12px 18px;display:flex;align-items:center;justify-content:space-between}
  header h1{margin:0;font-size:18px;font-weight:700}
  .tabs{display:flex;gap:6px}
  .actions{display:flex;gap:8px;align-items:center}
  .tab{padding:8px 12px;border-radius:999px;border:1px solid #7aa2ff;background:#0e2350;color:#cfe0ff;cursor:pointer}
  .tab.active{background:#1c3f86;border-color:#a7c2ff;color:#fff}
  .container{padding:12px 14px}
  /* Reduce grid gaps slightly to save vertical space between cards */
  .grid{display:grid;grid-template-columns:2fr 1fr;gap:10px}
  /* Slightly smaller card padding to reduce per-card vertical height while keeping visual separation */
  .card{background:var(--panel);border-radius:12px;padding:10px;box-shadow:0 6px 18px rgba(0,0,0,.07);border:1px solid #e3ebfd}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{display:inline-flex;align-items:center;gap:6px}
  input,select,textarea{padding:8px 10px;border:1px solid #c9d7f8;border-radius:8px;background:#fff;color:var(--ink);font-size:0.95rem}
  textarea{width:100%;min-height:110px}
  input[type="number"]{width:100px}
  input[readonly]{background:#f0f4ff}
  .btn{padding:6px 10px;border:1px solid #c9d7f8;border-radius:8px;background:#fff;color:#0b1b33;cursor:pointer}
  .btn.primary{background:#1f6fff;color:#fff;border-color:#1f6fff}
  /* Weaning button-style toggle (hidden checkbox + pill) */
  .weaning-btn{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;border:1px solid #c9d7f8;background:#fff;color:#0b1b33;cursor:pointer;font-weight:600;font-size:13px}
  .weaning-btn input[type="checkbox"]{display:none}
  .weaning-btn span{display:inline-block;padding:2px 6px;border-radius:6px}
  .weaning-btn input[type="checkbox"] + span{background:transparent;color:var(--pri)}
  .weaning-btn input[type="checkbox"]:checked + span{background:var(--pri);color:#fff}
  #plotPV,#plotHemo,#plotTr,#plotStage{width:100%;min-height:480px;background:transparent;border:1px solid var(--line);border-radius:10px}

  /* Reduce vertical footprint of SCAI walker cell specifically — walker content is compact */
  #plotStage{ min-height:120px }
  /* Make the dashboard PV loop taller for better readability */
  #plotPV{ min-height:640px; width:100%; max-width:100%; min-width:0; box-sizing:border-box; }
  
  /* Responsive adjustments for different window sizes */
  @media (max-width: 1200px) {
    #plotPV { min-height:500px; }
  }
  
  @media (max-width: 900px) {
    #plotPV { min-height:450px; }
  }
  
  /* iPad: el gráfico PV ocupa el ancho completo en dashboard */
  @media (max-width: 1024px) {
    #plotPV {
      width: 100vw !important;
      max-width: 100vw !important;
      min-width: 0 !important;
      /* compensar padding del container (18px) y de la card (14px) */
      margin-left: -32px;
      margin-right: -32px;
    }
    /* eliminar padding lateral de la card que contiene el PV para un verdadero full-bleed */
    .card:has(#plotPV){ padding-left:0; padding-right:0; }
  }
  
  /* Ajustes para ventanas muy pequeñas o media pantalla */
  @media (max-width: 600px) {
    #plotPV { 
      min-height:400px;
      font-size:12px;
    }
  }
  
  /* Asegurar que la card que contiene plotPV también sea responsiva */
  .card:has(#plotPV) {
    min-width: 0;
    overflow: visible;
  }
  h2{color:var(--pri);margin:0 0 8px;font-size:18px}
  h3{color:var(--pri);margin:10px 0 6px;font-size:15px}
  .status{display:inline-flex;align-items:center;gap:8px;border-radius:999px;padding:4px 10px;font-size:12px}
  .status.stable{background:#eaf7f0;color:#137a3a;border:1px solid #aee3c0}
  .status.improve{background:#eaf2fe;color:#1f6fff;border:1px solid #bcd3ff}
  .status.worse{background:#ffebee;color:#dc2626;border:1px solid #ffc3c8}
  /* Warning state for Smart Alarms (yellow background, used in Clinic Panel) */
  .status.warning{background:#fff8ea;color:#885800;border:1px solid #ffdf9e}
  /* Dashboard Smart Alarms: match Clinic palette (green improve, amber warning) */
  #alarms .status.improve{ background:#eaf7f0; color:#137a3a; border:1px solid #aee3c0 }
  #alarms .status strong{ color: inherit !important; }
  body.dark #alarms .status.improve{ background:#eaf7f0 !important; color:#137a3a !important; border:1px solid #aee3c0 !important }
  body.dark #alarms .status.warning{ background:#fff8ea !important; color:#885800 !important; border:1px solid #ffdf9e !important }
  /* Improve legibility of inline grey copy inside alarm cards in dark mode (80% opacity)
    Apply broadly within #alarms to override global dark-muted rule */
  body.dark #alarms .status div[style*="color:#666"],
  body.dark #alarms div[style*="color:#666"],
  body.dark #alarms span[style*="color:#666"]{ color: rgba(110, 110, 110, 0.8) !important; }
  table{border-collapse:collapse;width:100%;margin-top:10px;font-size:13px;background:#fff;border:1px solid var(--line)}
  th,td{border:1px solid var(--line);padding:6px;text-align:center}
  th{background:#0f2447;color:#fff}
  /* Slightly larger table text for readability */
  table, th, td { font-size: 0.95rem }
  .small{font-size:12px;color:#46639b}
  .pill{display:inline-block;background:#eaf0ff;color:#0f2447;border:1px solid #c9d7f8;border-radius:999px;padding:2px 8px;font-size:12px;margin-right:8px}
  .section{display:none}
  .section.active{display:block}

  /* Professional meta fields styling (Age/Sex/Anthro) */
  .metaRow{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  .metaField{display:inline-flex;align-items:center;gap:6px}
  .metaField input[type="number"]{width:84px}
  .unit{color:#6b82ad;font-size:.85em}

  /* Collapsible timepoint card */
  .tpCard.collapsed .gcol-3, .tpCard.collapsed .gcol-4, .tpCard.collapsed .gcol-6, .tpCard.collapsed .gcol-12, .tpCard.collapsed .row.mono{display:none}
  .tpHead{cursor:pointer}

  /* Dark mode variables "pupil-friendly" - suave para la vista */
  :root{ --dark-bg:#0d1117; --dark-panel:#0f172a; --dark-border:#234457; --dark-input:#0f172a; --dark-text:#e6edf3; --dark-muted:#93a6b6; }
  body.dark{background:var(--dark-bg) !important; color:var(--dark-text) !important}
  body.dark header{background:linear-gradient(90deg,#06203a,#0b3b66)}
  body.dark .card{background:var(--dark-panel) !important;border-color:var(--dark-border)}
  /* Timepoint compact cards in dark mode */
  body.dark .tpCard{background:var(--dark-panel) !important;border:1px solid var(--dark-border);color:var(--dark-text)}
  /* FORZAR TODOS los inputs, textareas, selects, divs con fondo oscuro */
  body.dark input{background:var(--dark-panel) !important;color:var(--dark-text) !important;border-color:var(--dark-border) !important}
  body.dark textarea{background:var(--dark-panel) !important;color:var(--dark-text) !important;border-color:var(--dark-border) !important}
  body.dark select{background:var(--dark-panel) !important;color:var(--dark-text) !important;border-color:var(--dark-border) !important}
  body.dark div[style*="background:#fff"]{background:var(--dark-panel) !important}
  body.dark div[style*="background: #fff"]{background:var(--dark-panel) !important}
  /* Keep specific builder fields light in light mode for readability (apply when body does NOT have .dark) */
  body:not(.dark) #expressionPreview,
  body:not(.dark) #clinicalWording,
  body:not(.dark) #suggestedActions {
    background: #f8fbff !important; /* very light, matches other input panels */
    color: #0b1b33 !important;      /* dark text for high contrast */
    border-color: #c9d7f8 !important;
  }
  body:not(.dark) #expressionPreview::placeholder,
  body:not(.dark) #clinicalWording::placeholder,
  body:not(.dark) #suggestedActions::placeholder{
    color: #6b7280 !important; /* readable placeholder in light bg */
    opacity: 1 !important;
  }
  /* Plotly y tablas con fondo panel oscuro (sin blanco) */
  body.dark table{background:var(--dark-panel) !important}
  body.dark #plotPV, body.dark #plotHemo, body.dark #plotTr, body.dark #plotStage{background:transparent !important}
  body.dark th{background:rgba(15,23,42,0.8) !important;color:var(--dark-text) !important;border-color:var(--dark-border) !important}
  body.dark td{background:var(--dark-panel) !important;color:var(--dark-text) !important;border-color:rgba(147,166,182,0.12) !important}
  /* Use a softer blue for headings and plot/gauge labels instead of pure white */
  body.dark h2, body.dark h3, body.dark .title, body.dark .subtitle{color:var(--dark-text)}
  body.dark .small, body.dark label{color:var(--dark-muted)}
  body.dark .pill{background:rgba(58,167,164,0.12) !important;color:#3aa7a4 !important;border-color:rgba(58,167,164,0.2) !important}
  /* Target Plotly's SVG text elements to improve readability in dark mode */
  body.dark .js-plotly-plot svg text{fill:var(--dark-text) !important}
  body.dark .js-plotly-plot .gtitle, body.dark .js-plotly-plot .gaxis text{fill:var(--dark-text) !important}
  /* Gauge components: approximate selector for gauge text (depends on gauge implementation) */
  body.dark .gaugeGrid svg text, body.dark .gaugeGrid .plotly .gauge text{fill:var(--dark-text) !important}
  /* LegendBox sin fondo blanco */
  body.dark .legendBox{background:var(--dark-panel) !important;border-color:var(--dark-border)}
  body.dark .legendItem{color:var(--dark-text)}
  body.dark .chip{background:var(--dark-panel) !important;color:var(--dark-text);border-color:var(--dark-border)}
  /* Botones y controles sin fondo blanco - FORZAR */
  body.dark .btn{background:var(--dark-panel) !important;color:var(--dark-text) !important;border-color:var(--dark-border) !important}
  body.dark .weaning-btn{background:var(--dark-panel) !important;color:var(--dark-text);border-color:var(--dark-border)}
  body.dark .segmented{background:var(--dark-panel) !important;border-color:var(--dark-border)}
  body.dark .segmented label{background:var(--dark-panel) !important;color:var(--dark-text)}
  body.dark .segmented input:checked + label{background:var(--dark-border) !important;color:var(--dark-text)}
  body.dark #csTypeGroup label{background:var(--dark-panel) !important;color:var(--dark-text);border-color:var(--dark-border)}
  /* Tablas del tema clinic sin fondo blanco */
  body.dark .clinic-prognosis-table tbody td{background:var(--dark-panel);border-color:rgb(147, 166, 182)}
  body.dark .support-tp{background:var(--dark-panel);color:var(--dark-text);border-color:var(--dark-border)}
  /* Alarm builder y template cards sin fondo blanco */
  body.dark .condition-row{background:var(--dark-panel);border-color:var(--dark-border)}
  body.dark .template-card{background:var(--dark-panel);border-color:var(--dark-border)}
  body.dark .template-card:hover{background:var(--dark-border);border-color:var(--dark-text)}
  body.dark .alarm-rule-item{background:var(--dark-panel);border-color:var(--dark-border)}
  /* Condition Builder panel: keep light-mode look but ensure readable dark-mode override
    The HTML container uses class="condition-builder-panel" so we can target it precisely
    without relying on brittle inline-style matching. Inputs inside the panel will also
    inherit readable colors in dark mode. */
  .condition-builder-panel{ background:#f8fbff; border:1px solid #dfe8ff; border-radius:8px; padding:12px }
  .condition-builder-panel .row{ margin-bottom:0 }
  body.dark .condition-builder-panel{ background:var(--dark-panel) !important; border-color:var(--dark-border) !important; color:var(--dark-text) }
  body.dark .condition-builder-panel input, body.dark .condition-builder-panel select, body.dark .condition-builder-panel textarea{ background:var(--dark-panel) !important; color:var(--dark-text) !important; border-color:var(--dark-border) !important }
  /* Custom Variables list cards (used in Variable Builder) */
  .variable-rule-card{ background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px; padding:10px }
  .variable-rule-card .mono{ color:#374151 }
  .variable-rule-card .small{ color:#6b7280 }
  /* Dark mode: force cards and inner text to dark theme colors */
  body.dark .variable-rule-card{ background:var(--dark-panel) !important; border-color:var(--dark-border) !important; color:var(--dark-text) !important; box-shadow:none !important }
  body.dark .variable-rule-card .mono, body.dark .variable-rule-card .small, body.dark .variable-rule-card div{ color:var(--dark-text) !important }
  /* Summary boxes sin fondo blanco */
  body.dark .summaryBox{background:var(--dark-panel) !important;border-color:var(--dark-border) !important;color:var(--dark-text) !important}
  body.dark .summaryHeader h3{color:var(--dark-text)}
  /* Textos inline que se pierden en dark mode - forzar colores legibles */
  body.dark div[style*="color:#666"]{color:var(--dark-muted) !important}
  body.dark span[style*="color:#666"]{color:var(--dark-muted) !important}
  body.dark div[style*="color:#888"]{color:var(--dark-muted) !important}
  body.dark div[style*="color:#9ca3af"]{color:var(--dark-muted) !important}
  body.dark div[style*="color:#0066cc"]{color:#5f8ffd !important}
  body.dark div[style*="color:#16a34a"]{color:#2db37b !important}
  body.dark .small[style*="color:#"]{color:var(--dark-muted) !important}

    /* Label under gauges (title shown below semicircle) */
    .gauge-label{ font-weight:600; color:var(--pri); }
    body.dark .gauge-label{ color: var(--dark-text); opacity:0.95 }

    /* Inner holder for Plotly gauge so label can be placed below and centered */
    /* Use a consistent minimum cell size so zooming doesn't reflow badly */
    .gaugeGrid > div{ min-height:260px; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; padding:12px; box-sizing:border-box }
    .gauge-plot{ width:100%; display:block }
    .gauge-label{ text-align:center; margin-top:8px; font-size:13px; line-height:1 }

  /* Compact timepoint cards */
  .tpWrap{display:grid;grid-template-columns:repeat(12,minmax(0,1fr));gap:10px}
  .tpCard{grid-column:span 12;background:#fff;border:1px solid #dfe8ff;border-radius:12px;padding:10px;display:grid;gap:8px;grid-template-columns:repeat(12,minmax(0,1fr))}
  .tpHead{grid-column:span 12;display:flex;align-items:center;gap:10px}
  .chip{background:#eef3ff;border:1px solid #c9d7f8;border-radius:999px;padding:2px 8px;font-size:12px;color:#0f2447}
  .gcol-3{grid-column:span 3} .gcol-2{grid-column:span 2} .gcol-4{grid-column:span 4}
  .gcol-6{grid-column:span 6} .gcol-12{grid-column:span 12}
  .mini label{font-size:12px;color:#234}
  .mini input, .mini select{width:100%}

  /* Devices grid inside timepoint cards: consistent columns and flex-wrapping to avoid Chrome reflow issues */
  .tpCard .devices-grid{
    display:grid;
    /* wider label column and larger control column to keep device controls in one row */
    grid-template-columns: 28px 140px minmax(220px, 1fr);
    gap:8px;
    align-items:center;
    row-gap:6px;
  }
  /* ensure each grid cell that holds multiple controls is a single-row flex container */
  .tpCard .devices-grid > div{
    display:flex; gap:10px; align-items:center; flex-wrap:nowrap; min-width:0;
  }
  /* prevent internal controls from forcing the cell to expand and wrap */
  .tpCard .devices-grid select, .tpCard .devices-grid input[type="number"]{
    max-width:180px; min-width:40px; box-sizing:border-box; white-space:nowrap;
  }
  .tpCard .devices-grid label{ white-space:nowrap }
  .tpCard .devices-grid span{ font-size:0.95em; white-space:nowrap }
  @media (max-width:900px){
    /* on smaller screens allow the control column to shrink but keep controls inline when possible */
    .tpCard .devices-grid{ grid-template-columns: 24px 110px 1fr; }
    .tpCard .devices-grid > div{ gap:8px }
  }

  .legendBox{border:1px solid #dfe8ff;background:#fff;border-radius:10px;padding:8px;display:flex;gap:12px;flex-wrap:wrap;margin-top:8px}
  .legendItem{display:flex;align-items:center;gap:6px;font-size:12px;color:#234}
  .swatch{width:14px;height:14px;border-radius:3px;border:1px solid #365b9f}

  /* Gauge grid: slightly smaller min widths and tighter gaps to avoid clipping */
.gaugeGrid{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap:8px;
  grid-auto-rows:300px;             /* increased min height to give gauges more vertical room */
}
.gaugeGrid > div{
  min-height:300px;                 /* ensure each cell provides a comfortable plotting area */
  display:flex;
  align-items:center;
  justify-content:center;
  padding:6px;
}
/* el canvas de Plotly ocupa toda la celda */
.gaugeGrid > div > div{
  width:100% !important;
  height:100% !important;
}

/* breakpoints: reduce columnas, mantiene alturas coherentes */
@media (max-width:1600px){ .gaugeGrid{ grid-template-columns:repeat(5,1fr); } }
@media (max-width:1280px){ .gaugeGrid{ grid-template-columns:repeat(4,1fr); } }
@media (max-width:1024px){ .gaugeGrid{ grid-template-columns:repeat(3,1fr); } }
@media (max-width:768px){  .gaugeGrid{ grid-template-columns:repeat(2,1fr); } }
@media (max-width:520px){  .gaugeGrid{ grid-template-columns:1fr; } }

/* When browser zoom changes, ensure each gauge cell keeps an approximate aspect ratio */
@media (min-width:1400px){ .gaugeGrid > div{ min-height:320px } }
@media (max-width:900px){ .gaugeGrid > div{ min-height:220px } }

  /* Header spacing tweak for better horizontal use */
  header .tabs{margin-right:12px}

  /* Summaries styling */
  .summaryBox{min-height:220px;resize:vertical;padding:10px;border-radius:8px;background:#fbfdff;border:1px solid #dfe8ff;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace;overflow:auto}
  .summaryHeader{display:flex;align-items:center;gap:8px}
  .summaryGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;transition:grid-template-columns 0.3s ease}
  @media (max-width:1080px){ .summaryGrid{grid-template-columns:repeat(2,1fr);} }
  @media (max-width:720px){ .summaryGrid{grid-template-columns:1fr;} }
  .summaryToolbar{display:flex;gap:8px;align-items:center}
  .summaryMeta{display:flex;justify-content:space-between;align-items:center;margin-top:6px}
  .summaryMeta .small{color:#486b9c}
  
  /* Language Pills Hover Effects */
  .lang-pill:hover{transform:translateY(-1px);box-shadow:0 2px 4px rgba(0,0,0,0.08)}
  .lang-pill.active{box-shadow:0 2px 8px rgba(37,99,235,0.25)}
  /* Ensure language pills are readable in dark mode and non-active pills inherit muted color */
  /* Ensure emoji flags render by using emoji-capable fonts first */
  .lang-pill{ color: #64748b; font-family: "Segoe UI Emoji", "Noto Color Emoji", "Apple Color Emoji", "Segoe UI Symbol", system-ui, -apple-system, sans-serif }
  body.dark .lang-pill{ color: var(--dark-muted) !important }

  /* Flag icon sizing inside language pills */
  .lang-pill .flag{ width:20px; height:12px; vertical-align:middle }
  .lang-pill .flag-icon{ display:inline-flex; align-items:center }
  .lang-pill.active{ background: #2563eb; color: #fff }
  body.dark .lang-pill.active{ background: #2563eb !important; color: #fff !important }
  /* Summary controls: make the whole toolbar concordant in dark mode */
  /* light-mode default for .summary-controls kept inline in HTML */
  body.dark .summary-controls{ background: var(--dark-panel) !important; border-color: var(--dark-border) !important; box-shadow: none !important }
  /* Inner pill container: use transparent background so it blends with toolbar */
  body.dark #summaryLangPills{ background: transparent !important; border-color: rgba(147,166,182,0.06) !important }
  /* Time selector & action buttons in dark */
  body.dark #summaryTimeFilter, body.dark #summaryTimeFilter *{ background: var(--dark-panel) !important; color: var(--dark-text) !important; border-color: var(--dark-border) !important }
  body.dark .summary-controls .btn{ background: var(--dark-panel) !important; color: var(--dark-text) !important; border-color: var(--dark-border) !important }
  /* Stats badge */
  .summary-stats-badge{ background:#f1f5f9 }
  /* Improve contrast for the language label and stats badge in dark mode */
  body.dark #summaryLangLabel{ color: var(--dark-text) !important; font-weight:600 !important; text-shadow:none !important }
  body.dark .summary-stats-badge{ background:transparent !important; border:1px solid rgba(147,166,182,0.08); color:var(--dark-text) !important; font-weight:500 !important }
  
  /* Summary Action Buttons Hover */
  #btnCopySummary:hover{background:#1d4ed8;transform:translateY(-1px);box-shadow:0 4px 12px rgba(37,99,235,0.3)}
  #btnSaveSummary:hover{background:#f8fafc;border-color:#cbd5e1;transform:translateY(-1px);box-shadow:0 2px 8px rgba(0,0,0,0.08)}
  #btnSaveSummary:active, #btnCopySummary:active{transform:translateY(0)}

  /* Support table monospace doses */
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

  /* Alarms Builder Styles */
  .condition-row {
    border: 1px solid #e3ebfd;
    border-radius: 6px;
    padding: 8px;
    margin-bottom: 8px;
    background: #fff;
  }
  
  .template-card {
    border: 1px solid #dfe8ff;
    border-radius: 8px;
    padding: 12px;
    background: #fff;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .template-card:hover {
    border-color: #1f6fff;
    background: #f8fbff;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(31, 111, 255, 0.15);
  }
  
  .alarm-rule-item {
    border: 1px solid #e3ebfd;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    background: #fff;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
  }
  
  .alarm-rule-item .severity-critical { border-left: 4px solid #dc2626; }
  .alarm-rule-item .severity-warning { border-left: 4px solid #f59e0b; }
  .alarm-rule-item .severity-improving { border-left: 4px solid #16a34a; }
  .alarm-rule-item .severity-wean_ok { border-left: 4px solid #2563eb; }
  
  .alarm-rule-content {
    flex: 1;
  }
  
  .alarm-rule-actions {
    display: flex;
    gap: 6px;
    margin-left: 12px;
  }
  
  .validation-success {
    color: #16a34a;
    font-weight: 600;
  }
  
  .validation-error {
    color: #dc2626;
    font-weight: 600;
  }
  
  /* Modal Styles */
  .modal {
    display: none;
    position: fixed;
    z-index: 10000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.5);
  }
  
  .modal-content {
    background-color: var(--bg);
    color: var(--ink);
    margin: 5% auto;
    padding: 20px;
    border: 1px solid var(--line);
    border-radius: 12px;
    width: 90%;
    max-width: 600px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    position: relative;
  }
  
  .modal-close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    position: absolute;
    right: 15px;
    top: 10px;
  }
  
  .modal-close:hover,
  .modal-close:focus {
    color: var(--ink);
    text-decoration: none;
  }
  
  .modal-header {
    border-bottom: 1px solid var(--line);
    padding-bottom: 10px;
    margin-bottom: 15px;
  }
  
  .modal-header h3 {
    margin: 0;
    color: var(--pri);
  }
  
  body.dark .modal-content {
    background-color: var(--dark-panel);
    color: var(--dark-text);
    border-color: var(--dark-border);
  }
  
  body.dark .modal-close:hover,
  body.dark .modal-close:focus {
    color: var(--dark-text);
  }

  /* Variables Reference Styles */
  .variable-item {
    display: inline-block;
    background: #f0f4ff;
    border: 1px solid #c9d7f8;
    border-radius: 4px;
    padding: 4px 8px;
    font-family: monospace;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    -webkit-user-select: none;
    user-select: none;
  }
  
  .variable-item:hover {
    background: #e0e7ff;
    border-color: #a5b4fc;
    transform: translateY(-1px);
  }
  
  .variable-item:active {
    background: #c7d2fe;
    transform: translateY(0);
  }
  
  .variable-item.copied {
    background: #dcfce7;
    border-color: #86efac;
    animation: copyPulse 0.3s ease;
  }
  
  @keyframes copyPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  
  /* Dark mode for generic variable items */
  body.dark .variable-item {
    background: rgba(58,167,164,0.08) !important;
    border: 0 !important;
    color: var(--dark-text) !important;
  }
  
  body.dark .variable-item:hover {
    background: rgba(58,167,164,0.15) !important;
  }
  
  body.dark .variable-item:active {
    background: rgba(58,167,164,0.20) !important;
  }
  
  body.dark .variable-item.copied {
    background: rgba(45,179,123,0.15) !important;
  }
  
  .variable-category.hidden {
    display: none;
  }

  /* Clinic Panel: present variables as horizontal category "listones" (strips)
     Each category becomes a full-width horizontal strip with the title on the left
     and the variable chips arranged in a single horizontal row on the right
     (scrollable horizontally on small screens). This is scoped to the clinic theme
     so other pages/layouts keep their original behavior. */
  .clinic-theme .variables-grid { display:flex; flex-direction:column; gap:12px; }
  .clinic-theme .variable-category { display:flex; align-items:center; gap:16px; padding:10px 12px; border-radius:8px; background: rgba(14,165,164,0.03); border:1px solid rgba(14,165,164,0.04); }
  .clinic-theme .variable-category h4 { margin:0; min-width:180px; font-size:15px; padding-right:8px; border-right:1px solid rgba(14,165,164,0.06); color:var(--clinic-accent); }
  /* Allow variable chips to wrap onto two lines instead of forcing horizontal scroll.
    Use flex-wrap:wrap so chips flow to a second row when needed. Limit the visible
    height to two approximate rows to avoid excessive vertical growth; additional
    items will be clipped (keeps the clinic panel compact). On very small screens
    the media query below will switch categories to column layout. */
  .clinic-theme .variable-list { display:flex; gap:8px; align-items:flex-start; flex-wrap:wrap; overflow-x:visible; padding-left:12px; max-height:64px; }
  /* Keep a subtle vertical clip rather than a horizontal scroller; if many items
    are present the two visible rows will show the most relevant items without
    introducing a slide control. */
  .clinic-theme .variable-list::-webkit-scrollbar{ height:0; width:0 }
  /* New styles for grouped Clinic vars (category title + horizontal chips) */
  .clinic-theme .category-title{ font-weight:700; min-width:180px; padding-right:12px; border-right:1px solid rgb(14, 165, 165); color:var(--clinic-accent); }
  .clinic-theme .variable-item{ display:inline-flex; flex-direction:row; align-items:baseline; gap:6px; padding:4px 8px; margin-right:8px; background:rgba(14, 165, 165, 0.08); border-radius:4px; box-sizing:border-box; white-space:nowrap; }
  .clinic-theme .variable-item .variable-name{ font-size:11px; color:#6b8a8a; font-weight:600; }
  .clinic-theme .variable-item .variable-val{ font-size:13px; font-weight:700; color:#0ea5a4; }
  @media (max-width:720px){ .clinic-theme .variable-category{ flex-direction:column; align-items:stretch; } .clinic-theme .variable-category h4{ border-right:0; border-bottom:1px solid rgb(14, 165, 165); padding-bottom:8px } .clinic-theme .variable-list{ padding-left:0; padding-top:8px } }
  
  /* Dark mode for variables grid - pupil-friendly */
  body.dark .clinic-theme .variable-category { background: transparent !important; border:1px solid var(--dark-border) !important; }
  body.dark .clinic-theme .variable-category h4 { border-right:1px solid var(--dark-border) !important; color:#3aa7a4 !important; }
  body.dark .clinic-theme .variable-item { background: transparent !important; border:0 !important; }
  body.dark .clinic-theme .variable-item .variable-name{ color:#93a6b6 !important; }
  body.dark .clinic-theme .variable-item .variable-val{ color:#ffffff !important; font-weight:700; }
  body.dark .clinic-theme .variable-list::-webkit-scrollbar-thumb{ background:rgba(58, 167, 163, 0); }
  
  /* Prognosis table (clinic) styling */
  .clinic-prognosis-table{ width:100%; border-collapse:separate; border-spacing:0; margin-top:6px; font-size:0.95rem }
  .clinic-prognosis-table thead th{ background:#0f2447; color:#fff; padding:8px 10px; text-align:left; font-weight:700; }
  .clinic-prognosis-table tbody td{ background:#fff; padding:8px 10px; border-bottom:1px solid #eef4fb; vertical-align:middle }
  .clinic-prognosis-table tbody tr:nth-child(odd) td{ background:#fbfdff }
  .clinic-prog-bar{ height:12px; background:#eef6fb; border-radius:8px; overflow:hidden; box-shadow: inset 0 1px 0 rgba(255,255,255,0.4) }
  .clinic-prog-bar-fill{ height:100%; border-radius:8px 0 0 8px }
  .clinic-prog-bar-label{ color:#0b2740; font-weight:700; font-size:13px }
  .clinic-prog-cell{ padding:8px 10px }
  
  /* Dark mode for prognosis table - sin fondos blancos */
  body.dark .clinic-prognosis-table thead th{ background:var(--dark-panel); color:var(--clinic-text); border-color:rgba(147,166,182,0.18); }
  body.dark .clinic-prognosis-table tbody td{ background:var(--dark-panel); border-bottom:1px solid rgba(147,166,182,0.12); color:var(--clinic-text); }
  body.dark .clinic-prognosis-table tbody tr:nth-child(odd) td{ background:rgba(147,166,182,0.04); }
  body.dark .clinic-prog-bar{ background:rgba(58,167,164,0.15); box-shadow: inset 0 1px 0 rgba(0,0,0,0.2) }
  body.dark .clinic-prog-bar-label{ color:var(--clinic-text); }

  /* Clinic grid layout: left (narrow) + main (PV loop) + alarms; alarms sits below left on wide, after main on small */
  .clinic-grid{ display:grid; grid-template-columns:40% 60%; gap:12px; margin-top:12px; align-items:start; grid-template-areas: 'left main' 'alarms main'; }
  .clinic-left{ grid-area:left; display:flex; flex-direction:column; gap:12px; min-width:0; }
  .clinic-main{ grid-area:main; display:flex; flex-direction:column; gap:12px; min-width:0; overflow:hidden; }
  .clinic-alarms{ grid-area:alarms; display:flex; flex-direction:column; gap:12px; min-width:0; }
  .clinic-left.collapsed{ display:none }
  .clinic-main.collapsed{ display:none }
  @media (max-width:980px){
    /* stack: Patient first, then PV loops, then Smart Alarms */
    .clinic-grid{ grid-template-columns:1fr; grid-template-areas: 'left' 'main' 'alarms'; }
    .clinic-left, .clinic-main{ width:100%; min-width:0; }
  }

  /* Broader tablet breakpoint: ensure clinic-left stacks above main on typical iPad widths
     and give the hemo plot more vertical room so it displays clearly in portrait. */
  @media (max-width:1024px){
    .clinic-grid{ grid-template-columns:1fr; grid-template-areas: 'left' 'main' 'alarms'; }
    #plotHemoClinic{ height:260px !important; min-height:180px; }
    /* reduce PV plot min-height a bit so the stacked layout fits on smaller screens */
    #clinicPVPlot{ min-height:420px; }
  }

  /* Dashboard: use the global .grid rules for the two-column layout (2fr / 1fr) */

  /* Ensure PV plot has minimum height but uses responsive sizing like Dashboard */
  #clinicPVPlot{ min-height:600px; width:100%; max-width:100%; }
  #clinicPVLoops{ width:100%; max-width:100%; overflow:visible; }

  /* Slightly reduce inner padding for main cards in clinic to give PV more horizontal room */
  #sec-clinic .clinic-main > .card{ padding:8px; overflow:hidden; }

  /* Palette classes for clinic theme: overrides clinic accent variable and subtle backgrounds */
  /* palette classes are unused now and can remain for future use */
  .palette-green{ --clinic-accent: #0ea5a4; --clinic-muted: #6b8a8a; }
  .palette-blue { --clinic-accent: #1f6fff; --clinic-muted: #6b82ad; }
  .palette-red  { --clinic-accent: #dc2626; --clinic-muted: #8b3e3e; }
  .palette-yellow{ --clinic-accent: #f59e0b; --clinic-muted: #8a6b30; }

  /* Mini support timeline styles */
  .clinic-support-timeline{ display:flex; gap:8px; overflow-x:auto; padding:4px 0 }
  .support-tp{ min-width:120px; border:1px solid #e5efff; background:#fff; border-radius:8px; padding:6px 8px; font-size:12px; color:#0b1726 }
  .support-tp.active{ border-color: var(--clinic-accent); box-shadow: 0 0 0 2px rgba(31,111,255,0.10) }
  .support-t{ margin-bottom:4px; color:#062a4f }
  .support-pills{ display:flex; flex-wrap:wrap; gap:6px }
  .support-pill{ display:inline-flex; align-items:center; gap:4px; padding:2px 6px; border-radius:999px; font-size:11px; line-height:1.3 }
  .support-pill.mcs{ background: rgba(14,165,164,0.10); color:#0ea5a4 }
  .support-pill.drug{ background: rgba(31,111,255,0.10); color:#1f6fff }
  .support-pill.more{ background: rgba(107,130,173,0.14); color:#334155 }
  
  /* Dark mode for support timeline */
  body.dark .support-tp{ border:1px solid rgba(93,213,211,0.15); background:var(--clinic-panel); color:var(--clinic-text) }
  body.dark .support-tp.active{ border-color: var(--clinic-accent); box-shadow: 0 0 0 2px rgba(93,213,211,0.2) }
  body.dark .support-t{ color:var(--clinic-text) }
  body.dark .support-pill.mcs{ background: rgba(93,213,211,0.2); color:#5dd5d3 }
  body.dark .support-pill.drug{ background: rgba(111,180,255,0.2); color:#6fb4ff }
  body.dark .support-pill.more{ background: rgba(148,179,198,0.2); color:var(--clinic-muted) }

  /* iPad / tablet optimizations: force single-column vertical layout and override
     inline min-widths that prevent stacking. Targets typical iPad widths up to 1024px
     and reduces large plot heights to fit the stacked layout. */
  @media (max-width: 1024px) {
    /* Make main grids single-column */
    .grid { grid-template-columns: 1fr !important; }
    .clinic-grid { grid-template-columns: 1fr !important; grid-template-areas: 'left' 'main' 'alarms' !important; }
    .tpWrap { grid-template-columns: 1fr !important; }

    /* Override inline min-widths used in some card rows so elements can shrink and stack */
    .container .card .row > div, .container .card > .row > div, .card .metaRow > div {
      min-width: 0 !important;
      width: 100% !important;
      flex: 1 1 100% !important;
    }

    /* Specific patient/header row adjustments to stack inputs vertically */
    .container > .card > .row { flex-direction: column !important; align-items: stretch !important; gap: 10px !important; }

    /* Clinic columns become full width */
    .clinic-left, .clinic-main, .clinic-alarms { width: 100% !important; min-width: 0 !important; }

    /* Prevent PV plot negative margins causing horizontal scroll on tablets */
    #plotPV, #clinicPVPlot { margin-left: 0 !important; margin-right: 0 !important; width: 100% !important; max-width: 100% !important; }
    .card:has(#plotPV){ padding-left: 14px !important; padding-right: 14px !important; }

    /* Reduce heavy min-heights so the stacked layout fits vertically */
    #plotPV { min-height: 420px !important; }
    #clinicPVPlot { min-height: 420px !important; }

    /* Make gauges more compact in stacked view */
    .gaugeGrid { grid-template-columns: repeat(2, 1fr) !important; }
    .gaugeGrid > div { min-height: 220px !important; }

    /* Ensure timepoint cards stack cleanly */
    .tpCard { grid-template-columns: repeat(12, 1fr) !important; }

    /* Header adjustments for portrait tablets */
    header .top-actions { gap: 8px !important; }
  }

  /* iPad portrait tweaks: hide subtitle to save vertical space */
  @media only screen and (max-width: 1024px) and (orientation: portrait) {
    .brand-text .subtitle { display: none !important; }
    .logo { height: 44px !important; }
  }

</style>
</head>
<body>

<!-- Fixed top header: PV-One Clinical Dashboard v3.0 -->
<header id="topHeader" class="top-header">
  <div class="top-header-inner">
    <div class="brand">
      <!-- logo: try .tif first, fallback to .png (converted file should be placed in workspace if necessary) -->
  <img id="logoITAMEX" src="Logo-ITAMEX.ico" alt="ITA-MEX / CSWG-SCAI" class="logo">
      <div class="brand-text">
  <div class="title">PV-One App v3 Lite</div>
    <div class="subtitle">iPad Edition · Developed by J.A. Ortega-Hernández & ITA-MEX Registry</div>
      </div>
    </div>
    <div class="top-actions">
      <div class="tabs">
        <button class="tab active" data-tab="dash">Dashboard</button>
        <button class="tab" data-tab="clinic">Clinic Panel</button>
        <button class="tab" data-tab="summaries">Summaries</button>
        <!-- Dropdown selector replacing two separate tabs -->
        <div style="position:relative">
          <button id="btnMore" class="tab" aria-haspopup="true" aria-expanded="false">More ▾</button>
          <div id="moreMenu" style="display:none;position:absolute;right:0;top:40px;background:var(--dark-panel);border:1px solid #dfe8ff;padding:8px;border-radius:8px;min-width:160px;box-shadow:0 8px 28px rgba(11,27,51,0.12);z-index:10000">
            <div style="display:flex;flex-direction:column;gap:6px">
              <!-- Import/Export moved to Patient section for v3 Lite iPad UI -->
              <hr style="margin:4px 0;border:0;border-top:1px solid #dfe8ff">
              <button class="btn" data-tab="formulas">Formulas</button>
              <button class="btn" data-tab="alarms">Alarms</button>
              <button class="btn" data-tab="alarms-builder">Alarms Builder</button>
              <button class="btn" data-tab="about">About</button>
            </div>
          </div>
        </div>
      </div>
      <div class="action-buttons">
        <input type="file" id="csvInput" style="display:none" />
        <input type="file" id="patientFileInput" accept="application/json" style="display:none" />
        <button class="btn" id="btnDarkToggle" title="Toggle dark mode">🌙</button>
        <button class="btn primary" id="btnGenerate">🔄 Generate</button>
      </div>
    </div>
  </div>
</header>

<style>
  /* Top header styles (mimic Tailwind utilities used in the request) */
  :root{ --jacc-blue: #002b5c; }
  .top-header{ position:fixed; top:0; left:0; right:0; height:60px; background:var(--jacc-blue); color:#fff; box-shadow: 0 3px 8px rgba(0,0,0,0.12); z-index:9999; display:flex; align-items:center; }
  .top-header-inner{ width:100%; max-width:1280px; margin:0 auto; padding:0 12px; display:flex; align-items:center; justify-content:space-between; }
  .brand{ display:flex; align-items:center; gap:10px; }
  /* logo increased ~25% */
  .logo{ height:50px; width:auto; object-fit:contain; background:rgba(255,255,255,0.08); padding:4px; border-radius:6px; }
  .brand-text{ display:flex; flex-direction:column; }
  .title{ font-weight:700; color:#fff; font-size:16px; line-height:1; }
  .subtitle{ font-size:11px; color:rgba(255,255,255,0.85); line-height:1; }
  .top-actions{ display:flex; align-items:center; gap:14px; }
  .tabs{ display:flex; gap:6px; }
  .tab{ background:transparent; border:0; color:rgba(255,255,255,0.9); padding:6px 10px; border-radius:6px; cursor:pointer; }
  .tab.active{ background:rgba(255,255,255,0.06); }
  .action-buttons{ display:flex; gap:6px; align-items:center; }
  /* segmented control (for CS Type) */
  .segmented{ display:inline-flex; border:1px solid #c9d7f8; border-radius:8px; overflow:hidden; background:#fff }
  .segmented input{ position:absolute; opacity:0; pointer-events:none }
  .segmented label{ padding:6px 10px; cursor:pointer; color:#0b1b33; -webkit-user-select:none; user-select:none; background:#fff; font-size:12px }
  .segmented label + label{ border-left:1px solid #c9d7f8 }
  .segmented input:checked + label{ background:#1f6fff; color:#fff }
  /* Override for csType pills to match desired style */
  #csTypeGroup{ display:inline-flex; gap:8px; border:0; background:transparent; overflow:visible }
  #csTypeGroup label{ border:1px solid #d1dcfb; border-radius:999px; background:#fff; color:#1f4888; line-height:1; display:inline-flex; align-items:center; padding:6px 10px; }
  #csTypeGroup label + label{ border-left:0 }
  #csTypeGroup input:checked + label{ background:#0b3d91; border-color:#0b3d91; color:#fff }
  #csTypeGroup label:hover{ border-color:#0b3d91; color:#0b3d91 }
  #csTypeGroup label svg{ width:16px; height:16px; margin-right:6px; display:inline-block }
  /* small screen adjustments */
  @media (max-width:640px){
    .top-header{ height:52px; }
    /* mobile logo scaled ~25% larger */
    .logo{ height:40px; }
    .title{ font-size:14px; }
    .subtitle{ display:none; }
    .top-header-inner{ padding:0 8px; }
  }
  /* push page content down so header doesn't overlap */
  body{ padding-top:64px; }
</style>

<div class="container">

  <!-- Patient & global -->
  <div class="card">
    <div class="row" style="justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap">
      <!-- Left: Lite v3 iPad - line 1: patient name; line 2: action buttons -->
      <div style="display:flex;flex-direction:column;gap:6px;min-width:420px;flex:1">
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
          <label>Paciente <input id="patientName" value="Paciente 1" style="width:220px"></label>
        </div>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
          <button class="btn" id="btnImportMenu">📂 Import CSV</button>
          <button class="btn" id="btnExportMenu">💾 Export CSV</button>
          <button class="btn" id="btnCleanAllPatient" title="Limpiar todo">🧹 Clean all</button>
        </div>
        <!-- Hidden legacy elements kept to avoid runtime errors in Lite version -->
        <div style="display:none">
          <select id="patientList" onchange="onPatientSelected(this)"></select>
          <div id="patientFolder" class="small"></div>
          <span id="patientMsg" class="small"></span>
        </div>
      </div>
      <!-- Right: reordered for iPad — Age/Sex/H/W → CS Type → Method (last) -->
      <div style="display:flex;flex-direction:column;gap:6px;min-width:380px">
        <!-- Row 1: Age, Sex, Height, Weight -->
        <div class="metaRow" style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
          <label class="metaField" title="Chronological age in years">Age (y) <input type="number" id="ptAge" min="0" max="120" step="1" placeholder="—"></label>
          <label class="metaField" title="Biological sex at birth">Sex
            <select id="ptSex" style="width:100px">
              <option value="">—</option>
              <option value="M">Male</option>
              <option value="F">Female</option>
            </select>
          </label>
          <label class="metaField" title="Patient height in meters">Height (m) <input type="number" step="0.01" id="ptH" value="1.70"></label>
          <label class="metaField" title="Patient weight in kilograms">Weight (kg) <input type="number" id="ptW" value="75"></label>
        </div>
        <!-- Row 2: BMI, BSA pills -->
        <div class="metaRow" style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
          <span class="pill" id="chipBMI" title="Body Mass Index">BMI —</span>
          <span class="pill" id="chipBSA" title="Mosteller Body Surface Area">BSA —</span>
        </div>
        <!-- Row 3: Cardiogenic shock label + segmented control (same line) -->
        <div class="metaRow" style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
          <div style="display:flex;align-items:center;gap:10px;flex-wrap:nowrap">
            <label class="metaField" style="min-width:160px;white-space:nowrap">Cardiogenic shock:</label>
            <div class="segmented" id="csTypeGroup" title="Primary CS etiology">
            <input type="radio" name="csType" id="csTypeAMI" value="ami"><label for="csTypeAMI">
              <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M20.8 4.6c-1.9-1.8-5-1.8-6.9 0L12 6.5l-1.9-1.9c-1.9-1.8-5-1.8-6.9 0-2 1.9-2 5 0 6.9l1.9 1.9L12 21l6.9-6.6 1.9-1.9c2-1.9 2-5 0-6.9z" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
              AMI-CS
            </label>
            <input type="radio" name="csType" id="csTypeHF" value="hf"><label for="csTypeHF">
              <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M20.8 4.6c-1.9-1.8-5-1.8-6.9 0L12 6.5l-1.9-1.9c-1.9-1.8-5-1.8-6.9 0-2 1.9-2 5 0 6.9l1.9 1.9L12 21l6.9-6.6 1.9-1.9c2-1.9 2-5 0-6.9z" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
              HF-CS
            </label>
            </div>
          </div>
        </div>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
          <label>Method
            <select id="method">
              <option value="hybrid">Hybrid (CO + LVEF → EDV/ESV)</option>
              <option value="manual">Manual (EDV/ESV → SV/CO)</option>
            </select>
          </label>
          <!-- Per-timepoint creatinine and SvO2 are collected per card -->
          <label class="small" style="margin-left:auto"><input type="checkbox" id="chkNormalize"> Normalize trends (0–1)</label>
        </div>
      </div>
    </div>
  </div>

  <!-- Timepoints compact -->
  <div id="cardTimepoints" class="card">
    <div class="row">
        <button class="btn" onclick="addTP()">➕ Add timepoint</button>
        <span class="small">✔ include · ● active · hours can be decimals (0, 5.5, 17…). Drug ON = dose &gt; 0.</span>
        
        <label class="small" style="margin-left:8px"><input type="checkbox" id="chkTimeISO"> Time inputs are ISO datetimes (parse as timestamps)</label>
        <button class="btn" id="btnToggleInputs" style="margin-left:auto">▼ Hide timepoints</button>
      </div>
    <div id="tpInputs" class="tpWrap"></div>
  </div>

  <!-- DASHBOARD -->
  <section id="sec-dash" class="section active">
    <div class="grid">
      <!-- Left: Pressure-Volume Loop (main) -->
      <div class="card">
        <div class="row" style="justify-content:space-between">
          <h2>Pressure-Volume Loop</h2>
          <div style="display:flex;align-items:center;gap:8px">
            <span id="statusPill" class="status stable">Stable</span>
            <div id="pvControls" style="position:relative">
              <button class="btn primary" id="btnPVQuick" title="Quick select timepoints" style="display:flex;align-items:center;gap:8px;padding:6px 10px">
                <span style="font-weight:700">Times</span>
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
              </button>
              <div id="pvTimesMenu" class="popover" style="display:none;position:absolute;left:0;top:44px;padding:10px;border-radius:10px;min-width:260px;box-shadow:0 8px 28px rgba(11,27,51,0.12);z-index:10000"></div>
            </div>
          </div>
        </div>
        <div id="plotPV"></div>
        <div id="pvLegend" class="legendBox" style="margin-top:8px"></div>
      </div>

      <!-- Right: Key Hemodynamics (compact clinical panel) -->
      <div class="card">
        <h2>Key Hemodynamics</h2>
        <div id="kpis"></div>
        <div class="small" style="margin-top:8px">
          <span class="pill" id="pillSCAI">CSWG-SCAI: —</span>
        </div>
        <h3 style="margin-top:10px">Smart alarms</h3>
        <div id="alarms"></div>
      </div>
    </div>

    <div class="card">
      <h2 style="margin-top:0">RAP vs PCWP</h2>
      <div class="small">Thresholds: RAP=12 mmHg, PCWP=18 mmHg. Compact view (Clinic style).</div>
      <div style="display:flex;gap:12px;align-items:flex-start">
        <div style="flex:3;min-width:0">
          <div id="plotHemo" style="width:100%;height:220px"></div>
        </div>
        <div style="flex:1;min-width:140px">
          <div id="hemoLegend" class="legendBox small" style="padding-left:6px"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>CSWG-SCAI Stage Walker</h2>
      <div id="plotStage"></div>
    </div>

    <div class="card">
      <h2>Trends</h2>
      <div style="display:flex;gap:12px;align-items:flex-start;margin-bottom:8px">
        <div style="flex:1;display:flex;gap:8px;flex-wrap:wrap">
          <div style="display:flex;flex-direction:column;min-width:160px">
            <label class="small">Var 1</label>
            <select class="selTrVar" id="selTrVar_0" style="width:160px"></select>
          </div>
          <div style="display:flex;flex-direction:column;min-width:160px">
            <label class="small">Var 2</label>
            <select class="selTrVar" id="selTrVar_1" style="width:160px"></select>
          </div>
          <div style="display:flex;flex-direction:column;min-width:160px">
            <label class="small">Var 3</label>
            <select class="selTrVar" id="selTrVar_2" style="width:160px"></select>
          </div>
          <div style="display:flex;flex-direction:column;min-width:160px">
            <label class="small">Var 4</label>
            <select class="selTrVar" id="selTrVar_3" style="width:160px"></select>
          </div>
          <!-- Var5 removed — Trends now support up to 4 variables (2×2 panels). UI limited to four selectors. -->
        </div>
        <div style="white-space:nowrap;min-width:140px">
          <label class="small"><input type="checkbox" id="chkTrDeltas"> Show deltas vs first timepoint</label>
          <div class="small" style="margin-top:6px;color:#666">Select up to 4 variables (one per dropdown). Layout is 2×2 independent panels with separate axes.</div>
        </div>
      </div>
      <div id="plotTr"></div>
    </div>

    <div class="card">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <div style="display:flex;align-items:center;gap:12px">
            <h2 style="margin:0">Hemodynamic Gauges</h2>
            <!-- Time selector for gauges (moved closer to title) -->
            <div id="gaugeTimeControls" style="position:relative;margin-left:6px">
              <button class="btn" id="btnGaugeTime" title="Select time for gauges" style="display:flex;align-items:center;gap:6px;padding:6px 8px;font-size:13px">
                <span style="font-weight:700">Select time</span>
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5" stroke="#0b1b33" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
              </button>
              <div id="gaugeTimesMenu" class="popover" style="display:none;position:absolute;right:0;top:40px;padding:8px;border-radius:10px;min-width:220px;box-shadow:0 8px 28px rgba(11,27,51,0.12);z-index:10000">
                <div id="gaugeTimesList" style="display:flex;flex-direction:column;gap:6px;max-height:260px;overflow:auto"></div>
                <div style="border-top:1px solid #eef4ff;margin-top:8px;padding-top:8px;display:flex;gap:8px;justify-content:space-between">
                  <button class="btn" id="btnGaugeTimeUseLast">Use last</button>
                  <button class="btn" id="btnGaugeTimeClear">Clear</button>
                </div>
              </div>
            </div>
          </div>
          <div></div>
        </div>
        <div id="hemodynamicGaugesCard" style="min-height:240px">
        <div class="gaugeGrid" id="gaugeContainer">
        <div id="gauge_HR"></div>
        <div id="gauge_MAP"></div>
        <div id="gauge_CI"></div>
        <div id="gauge_RAP"></div>
        <div id="gauge_PCWP"></div>
        <div id="gauge_Lactate"></div>
      </div>
        <div class="gaugeGrid" id="gaugeContainer2" style="margin-top:8px">
          <div id="gauge_CPO"></div>
          <div id="gauge_SVR"></div>
          <div id="gauge_PVR"></div>
          <div id="gauge_Eff"></div>
          <div id="gauge_VAC"></div>
          <div id="gauge_PAPI"></div>
        </div>
    </div>

    <div class="card">
      <h2>Table Summary</h2>

      <h3>Cardiac Output & Index</h3>
      <table id="tblCOv"></table>

      <h3>Systemic Arterial Load</h3>
      <table id="tblSysv"></table>

      <h3>Left Heart Filling / Mechanics</h3>
      <table id="tblLVv"></table>

      <h3>Right Heart Filling / Mechanics</h3>
      <table id="tblRVv"></table>

      <h3>PV Loops — Mechanics</h3>
      <table id="tblPVv"></table>
    </div>

    <div class="card">
      <h2>Support overview (drugs & MCS)</h2>
      <div class="small">Inotropes: dobutamine, dopamine, milrinone, levosimendan, epinephrine. Vasopressors: norepinephrine, epinephrine, vasopressin.</div>
      <table id="tblSupport"></table>
    </div>
  </section>

  
  <!-- CLINIC PANEL -->
  <section id="sec-clinic" class="section clinic-theme">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <div style="display:flex;align-items:center;gap:12px">
          <h2 style="margin:0">Clinic Panel</h2>
          <div class="small" style="color:#6b82ad">Read-only clinical dashboard — change timepoints to update</div>
        </div>
        <!-- Modern time selector -->
          <div id="clinicTimeSelector" style="display:flex;gap:8px;align-items:center">
            <div class="small" style="color:#6b82ad">Quick time:</div>
            <!-- Buttons are generated dynamically from dashboard timepoints (only those with on=true) -->
            <div id="clinicQuickButtons" style="display:flex;gap:6px"></div>
            <!-- view toggles removed -->
          </div>
      </div>

      <!-- Patient card (moved before badges) -->
      <div class="card" style="padding:14px;background:var(--panel);border-radius:12px;margin-top:10px">
        <h3 style="margin-top:0">Patient</h3>
        <div style="line-height:1.5">
          <div><strong>Name:</strong> <span id="clinicPatientName">—</span></div>
          <div><strong>Age:</strong> <span id="clinicPatientAge">—</span> &nbsp; <strong>Sex:</strong> <span id="clinicPatientSex">—</span></div>
          <div><strong>CS Type:</strong> <span id="clinicPatientCS">—</span></div>
          <div><strong>Height:</strong> <span id="clinicPatientHeight">—</span> m &nbsp; <strong>Weight:</strong> <span id="clinicPatientWeight">—</span> kg</div>
          <div><strong>BMI:</strong> <span id="clinicPatientBMI">—</span> &nbsp; <strong>BSA:</strong> <span id="clinicPatientBSA">—</span></div>
        </div>
      </div>

      <!-- Badges panel (full width, separate cell) -->
      <div class="card" id="clinicBadgesCard" style="padding:14px;background:var(--panel);border-radius:12px;margin-top:10px">
        <div id="clinicAlarmBadges" style="display:flex;gap:16px;flex-wrap:wrap;align-items:center;justify-content:center;overflow:auto"></div>
      </div>

      <!-- New two-column layout: left = narrow column (prognosis/alarms), right = PV Loop + Tables -->
      <div class="clinic-grid">
        <!-- LEFT: narrow column -->
        <div class="clinic-left">

          <div class="card" style="padding:14px;background:var(--panel);border-radius:12px" id="clinicPrognosisCard">
            <h3 style="margin-top:0">Prognosis & Outcome Probabilities</h3>
            <div class="small" style="margin-bottom:8px;color:#6b82ad">Predicted probabilities for each available timepoint.</div>
            <div id="clinicPrognosis">
              <div class="small" id="clinicPrognosisPlaceholder">No prognosis data available. Update timepoints to compute probabilities.</div>
            </div>
          </div>

          <!-- RAP vs PCWP card (clinic-specific, separate cell) -->
          <div class="card" id="clinicHemoCard" style="padding:12px;background:var(--panel);border-radius:12px;margin-top:10px">
            <h3 style="margin-top:0">RAP vs PCWP</h3>
            <!-- thresholds note removed for compact clinic layout -->
            <div style="display:flex;gap:12px;align-items:flex-start">
              <div style="flex:3;min-width:0">
                <div id="plotHemoClinic" style="width:100%;height:220px"></div>
              </div>
              <div style="flex:1;min-width:140px">
                <div id="hemoLegendClinic" class="legendBox small" style="padding-left:6px"></div>
              </div>
            </div>
          </div>

        </div>

  <!-- RIGHT: main area (PV Loop) -->
  <div class="clinic-main">
          <div class="card" style="padding:12px;background:var(--panel);border-radius:12px;overflow:visible">
            <div class="row" style="justify-content:space-between">
              <h3 style="margin-top:0">Pressure-Volume Loop</h3>
              <div style="display:flex;align-items:center;gap:8px">
                <span id="clinicStatusPill" class="status stable">Stable</span>
                <div id="clinicPvControls" style="position:relative">
                  <button class="btn primary" id="clinicBtnPVQuick" title="Quick select timepoints" style="display:flex;align-items:center;gap:8px;padding:6px 10px">
                    <span style="font-weight:700">Times</span>
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                  </button>
                  <div id="clinicPvTimesMenu" class="popover" style="display:none;position:absolute;left:0;top:44px;padding:10px;border-radius:10px;min-width:260px;box-shadow:0 8px 28px rgba(11,27,51,0.12);z-index:10000"></div>
                </div>
              </div>
            </div>
            <div id="clinicPVLoops" style="width:100%;overflow:visible">
              <div id="clinicPVPlot"></div>
              <div id="pvLegendClinic" class="legendBox" style="margin-top:8px"></div>
              <div id="clinicSupportTimeline" style="margin-top:8px"></div>
              <div id="clinicGroupedVars" style="margin-top:12px"></div>
            </div>
          </div>

          <!-- Tables removed per user request -->
        </div>

        <!-- ALARMS: separate grid area so on small screens it appears after PV Loops -->
        <div class="clinic-alarms">
          <div class="card" style="padding:14px;background:var(--panel);border-radius:12px">
            <h3 style="margin-top:0">Smart Alarms</h3>
            <div id="clinicSmartAlarms"></div>
          </div>
        </div>
      </div>

      <!-- Extended trends (full width) -->
      <div style="margin-top:14px">
        <div class="card" style="padding:12px;background:var(--panel);border-radius:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <h3 style="margin:0">Extended Trends</h3>
            <div class="small" style="color:#6b82ad">Select variables and time window to view extended trends</div>
          </div>
          <div id="clinicExtendedTrends" style="margin-top:10px">
            <div id="clinicTrends"></div>
          </div>
        </div>
      </div>

    </div>
  </section>

  <!-- ALARMS REFERENCE -->
  <section id="sec-alarms" class="section">
    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h2>Alarms reference (per-device criteria)</h2>
        <button class="btn" onclick="refreshAlarmsReference()" title="Refresh alarms reference after bundle update">🔄 Refresh</button>
      </div>
      <div class="small">This reference lists explicit, device-specific criteria and other important alarm rules. Rows are ungrouped so each rule can be looked up independently.</div>
      <div style="margin-top:8px">
        <div style="max-height:520px;overflow:auto;padding-right:6px">
          <div id="alarmsReferenceContainer"></div>
        </div>
      </div>
      </div>
    </div>
  </section>

  <!-- FORMULAS (English, explicit equations) -->
  <section id="sec-formulas" class="section">
    <div class="card">
      <h2>Formulas and methodology</h2>
      <div class="small">This section lists the explicit formulas used by the application and documents how the CSWG‑SCAI stage is computed (see <code>computeSCAI</code> in the source).</div>

      <h3>1) Basic hemodynamic calculations</h3>
      <ul>
        <li><b>Mean arterial pressure (MAP)</b>: <code>MAP = DBP + (SBP - DBP) / 3</code></li>
        <li><b>Estimated end‑systolic pressure (ESP)</b>: <code>ESP = 0.9 × SBP</code></li>
        <li><b>Stroke volume (SV)</b>: <code>SV = EDV − ESV</code></li>
        <li><b>Arterial elastance (Ea)</b>: <code>Ea = ESP / SV</code></li>
        <li><b>End‑systolic elastance (Ees)</b> (approx): <code>Ees = ESP / ESV</code></li>
        <li><b>Ventriculo‑arterial coupling (VAC)</b>: <code>VAC = Ea / Ees</code></li>
        <li><b>Stroke work (SW)</b>: <code>SW = ESP × SV</code></li>
        <li><b>Potential energy (PE)</b>: <code>PE = 0.5 × ESP × ESV</code></li>
        <li><b>Pressure–volume area (PVA)</b>: <code>PVA = SW + PE</code></li>
        <li><b>Mechanical efficiency (Eff, %)</b>: <code>Eff = 100 × SW / PVA</code></li>
        <li><b>Cardiac index (CI)</b>: <code>CI = CO / BSA</code></li>
        <li><b>Cardiac power output (CPO, W)</b>: <code>CPO = (MAP × CO) / 451</code></li>
        <li><b>Cardiac power index (CPI)</b>: <code>CPI = CPO / BSA</code></li>
      </ul>

      <h3>2) Resistances and pulmonary vascular calculations</h3>
      <ul>
        <li><b>Mean pulmonary artery pressure (mPAP)</b>: <code>mPAP = dPAP + (sPAP − dPAP) / 3</code> (when sPAP and dPAP are available)</li>
        <li><b>Systemic vascular resistance (SVR)</b> (dyn·s·cm⁻⁵): <code>SVR = 80 × (MAP − RAP) / CO</code></li>
        <li><b>Pulmonary vascular resistance (PVR, Wood units)</b>: <code>PVR_WU = (mPAP − PCWP) / CO</code></li>
        <li><b>Indexed PVR (PVRI)</b>: <code>PVRI_WU = (mPAP − PCWP) / CI</code></li>
        <li><b>PAPI</b> (pulmonary artery pulsatility index): <code>PAPI = (sPAP − dPAP) / RAP</code> (if RAP &gt; 0)</li>
      </ul>

      <h3>3) EDPVR (end‑diastolic pressure–volume relationship) — explicit model</h3>
      <div class="small">The EDPVR is modeled with the nonlinear power law:</div>
      <div class="mono" style="margin:8px 0">P(V) = α × (V − V0)^β</div>
      <div class="small">Where:</div>
      <ul>
        <li><b>V</b> is ventricular volume (mL)</li>
        <li><b>P</b> is diastolic pressure (mmHg)</li>
        <li><b>V0</b> is the volume intercept (mL)</li>
        <li><b>α</b> and <b>β</b> are fitted parameters</li>
      </ul>
      <div class="small">Parameter estimation implemented in <code>edpvrParams(EDV, PCWP)</code> uses the following approach (as implemented):</div>
      <ol>
        <li>Initial guess for V0: <code>V0 = EDV × (0.6 − 0.006 × PCWP)</code></li>
        <li>Compute an auxiliary volume V30 (volume at 30 mmHg) using a scaling rule:
          <div class="mono">V30 = V0 + (EDV − V0) / (PCWP / An)^(1/Bn)</div>
          with constants <code>An = 27.78</code> and <code>Bn = 2.76</code> used in the implementation.</li>
        <li>Then estimate β and α from the two anchor points (PCWP at EDV and 30 mmHg at V30):
          <div class="mono">β = ln(PCWP / 30) / ln((EDV − V0) / (V30 − V0))</div>
          <div class="mono">α = 30 / (V30 − V0)^β</div>
        </li>
        <li>If the above produces non‑finite or non‑positive β/α, the function falls back to using a V15 anchor (15 mmHg) and recalculates β and α:
          <div class="mono">V15 = 0.8 × (V30 − V0) + V0</div>
          <div class="mono">β = ln(PCWP / 15) / ln((EDV − V0) / (V15 − V0))</div>
          <div class="mono">α = PCWP / (EDV − V0)^β</div>
        </li>
      </ol>
      <div class="small">These choices provide a numerically stable estimate of α, β and V0 given only EDV and a single diastolic pressure (PCWP).</div>

      <h3>4) Additional indices</h3>
      <ul>
        <li><b>LVIS (vasoactive index)</b>:
          <div class="mono">LVIS = Dopamine + Dobutamine + 100 × Epinephrine + 10 × Milrinone + 10000 × (Vasopressin/kg/min) + 100 × Norepinephrine + 50 × Levosimendan</div>
        </li>
        <li><b>LVSWi / RVSWi</b> (indexed stroke work):
          <div class="mono">LVSWi = (MAP − PCWP) × SVI × 0.0136</div>
          <div class="mono">RVSWi = (mPAP − RAP) × SVI × 0.0136</div>
        </li>
      </ul>

      <h3>5) CSWG‑SCAI staging (algorithm summary)</h3>
      <div class="small">The stage assignment follows a prioritized rule set (the code in <code>computeSCAI(vis)</code> mirrors these rules exactly):</div>
      <ol>
        <li><b>Stage E</b> if any of the following:
          <ul>
            <li>Severe hypotension: <code>SBP &lt; 60</code> mmHg or <code>MAP &lt; 50</code> mmHg</li>
            <li>Severe hypoperfusion: <code>lactate ≥ 10</code> mmol/L or <code>pH ≤ 7.20</code></li>
            <li>Three or more vasoactive drugs active (<b>vasopressors or inotropes</b>; <code>drugsOn &gt;= 3</code>) or three or more devices active (<code>devicesOn &gt;= 3</code>)</li>
            <li>OHCA (out‑of‑hospital cardiac arrest)</li>
          </ul>
        </li>
        <li><b>Stage D</b> if total supports (devices + drugs) ≥ 5</li>
        <li><b>Stage D</b> if hypotension (mild/moderate) combined with <b>great</b> hypoperfusion (lactate ≥ 5 or ALT ≥ 500)</li>
        <li><b>Escalation rule (D or C)</b>: if totalSupports ≥ 2, or totalSupports == 1 with hypotension or hypoperfusion:
          <ul>
            <li>If <code>prior_therapy</code> is false → assign C and set a downgrade flag (this reflects the rule that would otherwise be D for escalation without prior therapy)</li>
            <li>Otherwise → assign D</li>
          </ul>
        </li>
        <li><b>Stage C</b> if device for CS is present (MCS_for_CS true) and ≥1 device active</li>
        <li><b>Stage C</b> for hypotension + hypoperfusion or single active support</li>
        <li><b>Stage B</b> for mild hypotension or lactate 2–5 mmol/L or ALT 200–500 U/L</li>
        <li><b>Stage A</b> otherwise (stable)</li>
      </ol>

    </div>
    </div>
  </section>

  <!-- ALARMS BUILDER -->
  <section id="sec-alarms-builder" class="section">
    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h2>Alarms Builder</h2>
        <div style="display:flex;gap:8px">
          <button class="btn" id="btnSetupDirectUpdate" title="Setup direct file update (bypass CORS)" style="background:#d4edda">🔧 Setup Direct Update</button>
          <button class="btn" id="btnApplyToDisk" title="Write current bundle to selected file">💾 Apply to disk</button>
          <button class="btn primary" id="btnGenerateAlarms" title="Generate alarms.bundle.js">Generate Bundle</button>
        </div>
      </div>
      <div class="small">Create custom alarm rules using a visual interface. Build simple or complex conditions that will be evaluated in real-time on the dashboard.</div>
      <div class="small" style="background:#e8f4fd;padding:8px;border-radius:6px;margin-top:8px;border-left:3px solid #1f6fff">
        <strong>🚀 Auto-Update:</strong> Alarm rules are automatically activated when you add, edit, or delete them. Rules stay active during your session.<br>
        <strong>💾 Auto-Save:</strong> All alarm rules are automatically saved to your browser and restored when you return!<br>
        <strong>💾 Save Rules:</strong> Use "Download Bundle" to save your rules permanently to file and use "Reload from File" after placing the file in the project folder.
      </div>
      
      <!-- Alarm Builder Form -->
      <div class="card" style="margin-top:16px">
        <h3>Create New Alarm Rule</h3>
        
        <div class="row" style="margin-bottom:12px">
          <label style="min-width:120px">Rule Name <input type="text" id="alarmName" placeholder="e.g., High Lactate warning" style="width:300px"></label>
          <label style="min-width:120px">Tag/ID <input type="text" id="alarmTag" placeholder="e.g., hypoperfusion" style="width:200px"></label>
        </div>
        
        <div class="row" style="margin-bottom:12px">
          <label style="min-width:120px">Severity 
            <select id="alarmSeverity" style="width:150px">
              <option value="warning">⚠️ Warning</option>
              <option value="critical">🔴 Critical</option>
              <option value="improving">🟢 Improving</option>
              <option value="wean_ok">🔵 Wean OK</option>
            </select>
          </label>
          <label style="min-width:120px">Category 
            <select id="alarmCategory" style="width:200px">
              <option value="congestion">Congestion</option>
              <option value="metabolic">Metabolic</option>
              <option value="perfusion">Perfusion</option>
              <option value="trends">Trends</option>
              <option value="mcs">MCS-specific</option>
              <option value="weaning">Weaning</option>
              <option value="other">Other</option>
            </select>
          </label>
        </div>
        
  <!-- Condition Builder -->
  <div class="condition-builder-panel" style="margin-bottom:12px">
          <h4 style="margin:0 0 12px">Condition Builder</h4>
          <div id="conditionsContainer">
            <div class="condition-row" data-condition="0">
              <div class="row" style="align-items:center;margin-bottom:8px">
                <select class="condition-variable" style="width:120px">
                  <option value="">Select Variable</option>
                  <option value="HR">HR</option>
                  <option value="SBP">SBP</option>
                  <option value="DBP">DBP</option>
                  <option value="MAP">MAP</option>
                  <option value="ESP">ESP</option>
                  <option value="sPAP">sPAP</option>
                  <option value="dPAP">dPAP</option>
                  <option value="PCWP">PCWP</option>
                  <option value="RAP">RAP</option>
                  <option value="CO">CO</option>
                  <option value="CI">CI</option>
                  <option value="SVI">SVI</option>
                  <option value="LVEF">LVEF</option>
                  <option value="EDV">EDV</option>
                  <option value="ESV">ESV</option>
                  <option value="Ea">Ea</option>
                  <option value="Ees">Ees</option>
                  <option value="VAC">VAC</option>
                  <option value="CPO">CPO</option>
                  <option value="CPI">CPI</option>
                  <option value="SVR">SVR</option>
                  <option value="PVR_WU">PVR (WU)</option>
                  <option value="PAPI">PAPI</option>
                  <option value="Lactate">Lactate</option>
                  <option value="pH">pH</option>
                  <option value="ALT">ALT</option>
                  <option value="SvO2">SvO2</option>
                  <option value="creatinine">Creatinine</option>
                  <option value="LVIS">LVIS</option>
                  <option value="SVI">SVI</option>
                  <option value="Eff">Eff</option>
                  <option value="OPP">OPP</option>
                  <option value="CPP">CPP</option>
                  <option value="LVSWi">LVSWi</option>
                  <option value="RVSWi">RVSWi</option>
                  <option value="SCAI">SCAI</option>
                  <option value="devicesOn">devicesOn</option>
                  <option value="drugsOn">drugsOn</option>
                  <option value="IABP">IABP</option>
                  <option value="Impella">Impella</option>
                  <option value="ECMO">ECMO</option>
                  <option value="VAD">VAD</option>
                  <option value="On_IABP">On IABP</option>
                  <option value="On_Impella">On Impella</option>
                  <option value="On_ECMO">On ECMO</option>
                  <option value="Impella_flow_Lmin">Impella Flow</option>
                  <option value="Dobut">Dobutamine</option>
                  <option value="Dopa">Dopamine</option>
                  <option value="Norepi">Norepinephrine</option>
                  <option value="Milrinone">Milrinone</option>
                  <option value="Epi">Epinephrine</option>
                  <option value="Vasopressin">Vasopressin</option>
                  <option value="Levosimendan">Levosimendan</option>
                </select>
                
                <select class="condition-operator" style="width:80px;margin-left:8px">
                  <option value="">Op</option>
                  <option value=">">></option>
                  <option value=">=">≥</option>
                  <option value="<"><</option>
                  <option value="<=">≤</option>
                  <option value="==">=</option>
                  <option value="!=">≠</option>
                </select>
                
                <input type="text" class="condition-value" placeholder="Value" style="width:100px;margin-left:8px">
                
                <select class="condition-logic" style="width:60px;margin-left:8px">
                  <option value="">End</option>
                  <option value="&&">AND</option>
                  <option value="||">OR</option>
                </select>
                
                <button class="btn" onclick="removeCondition(this)" style="margin-left:8px">🗑️</button>
              </div>
            </div>
          </div>
          
          <div class="row" style="margin-top:12px">
            <button class="btn" id="btnAddCondition">➕ Add Condition</button>
            <button class="btn" id="btnAddAdvanced" style="margin-left:8px">⚙️ Advanced Expression</button>
          </div>
        </div>
        
        <!-- Expression Preview (Editable) -->
        <div style="margin-bottom:12px">
          <label style="display:block;margin-bottom:4px">
            <strong>Expression Preview:</strong>
            <span style="font-size:12px;color:#666;margin-left:8px">💡 Editable - modify directly or use builder below</span>
          </label>
          <textarea id="expressionPreview" 
                   placeholder="Enter your expression here, e.g.: RAP >= 12 && PAPI < 1.85" 
                   style="width:100%;background:#f0f4ff;border:1px solid #c9d7f8;border-radius:4px;padding:8px;font-family:monospace;min-height:60px;resize:vertical;box-sizing:border-box"></textarea>
          <div style="font-size:11px;color:#666;margin-top:4px">
            🔄 Changes here sync automatically with the Condition Builder
          </div>
        </div>
        
        <!-- Clinical Text Fields - Inline -->
        <div style="margin-bottom:12px">
          <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
            <label style="min-width:120px">
              <strong>Clinical:</strong>
              <span style="font-size:11px;color:#666">💬 Clinical description</span>
            </label>
            <input type="text" id="clinicalWording" 
                   placeholder="e.g., Right ventricular failure. Elevated RAP with low PAPI suggests impaired RV systolic function." 
                   style="flex:1;background:var(--dark-panel);border:1px solid #c9d7f8;border-radius:4px;padding:8px;box-sizing:border-box">
          </div>
          
          <div style="display:flex;align-items:center;gap:12px">
            <label style="min-width:120px">
              <strong>Suggest:</strong>
              <span style="font-size:11px;color:#666">🎯 Therapeutic actions</span>
            </label>
            <input type="text" id="suggestedActions" 
                   placeholder="e.g., Consider echocardiography to assess RV function. Optimize preload. Evaluate inotropic therapy or mechanical support if persistent." 
                   style="flex:1;background:var(--dark-panel);border:1px solid #c9d7f8;border-radius:4px;padding:8px;box-sizing:border-box">
          </div>
        </div>
        
        <!-- Advanced Expression (hidden by default) -->
        <div id="advancedExpressionContainer" style="display:none;margin-bottom:12px">
          <label style="display:block;margin-bottom:4px"><strong>Advanced Expression:</strong></label>
          <textarea id="advancedExpression" placeholder="Enter complex expression manually..." style="width:100%;height:80px;font-family:monospace"></textarea>
          <div class="small" style="margin-top:4px">Examples: "Stage in ['C','D','E']", "CountTrue([CI>=2.0, svo2>=55, Lact<=2.5]) >= 3", "Lactate_clearance_<20pct_12h"</div>
        </div>
        
        <div class="row" style="justify-content:space-between">
          <div>
            <button class="btn primary" id="btnAddAlarm">➕ Add Alarm Rule</button>
            <button class="btn" id="btnValidateExpression" style="margin-left:8px">✅ Validate</button>
            <button class="btn" id="btnShowMultipleAlarms" style="margin-left:8px;background:#e8f4fd">📝 Multiple Alarms</button>
          </div>
          <div id="validationResult" class="small"></div>
        </div>
      </div>
      
      <!-- Multiple Alarms Editor (Hidden by default) -->
      <div class="card" id="multipleAlarmsCard" style="margin-top:16px;display:none">
        <h3 style="margin-bottom:12px">📝 Multiple Alarms Editor</h3>
        <div class="small" style="margin-bottom:12px;color:#666">
          Create multiple alarm rules at once using JSON or structured text format.        </div>
        
        <div style="margin-bottom:12px">
          <label style="display:block;margin-bottom:4px"><strong>Multiple Rule Format:</strong></label>
          <textarea id="multipleAlarmsEditor" 
                   placeholder="Pipe-separated format (Name | Severity | Category | Expression | Clinical | Suggest):

RV Failure | critical | congestion | RAP >= 12 && PAPI < 1.85 | Right ventricular failure with elevated RAP and low PAPI | Consider echocardiography and RV support
BiV Congestion | warning | congestion | RAP >= 12 && PCWP >= 18 | Biventricular congestion with elevated filling pressures | Optimize diuretics and vasodilators
Severe Shock | critical | perfusion | CI < 2.0 && Lactate >= 8 | Severe cardiogenic shock with reduced output and hypoperfusion | Immediate hemodynamic support, consider MCS
Low Output | warning | perfusion | CI < 2.2 && MAP < 65 | Reduced cardiac output with hypotension | Optimize inotropes and vasopressors
Pulm HTN | warning | congestion | sPAP >= 50 && PCWP < 15 | Isolated pulmonary hypertension | Evaluate for pulmonary vascular disease

Format: Each line = one alarm rule
Fields: Name | Severity | Category | Expression | Clinical | Suggest
Required: Name, Expression (first and fourth fields)
Severities: critical, warning, improving, wean_ok
Categories: perfusion, congestion, metabolic, weaning, mcs, trends, other"
                   style="width:100%;height:300px;font-family:monospace;padding:12px;border:1px solid #c9d7f8;border-radius:4px;resize:vertical;box-sizing:border-box"></textarea>
        </div>
        
        <div class="row" style="justify-content:space-between">
          <div>
            <button class="btn primary" id="btnProcessMultipleAlarms">⚡ Process Multiple Alarms</button>
            <button class="btn" id="btnValidateMultiple" style="margin-left:8px">✅ Validate Format</button>
          </div>
          <div>
            <button class="btn" id="btnHideMultipleAlarms">❌ Close</button>
          </div>
        </div>
        <div id="multipleValidationResult" class="small" style="margin-top:8px"></div>
      </div>
      
      <!-- Current Alarm Rules -->
      <div class="card" style="margin-top:16px">
        <div class="row" style="justify-content:space-between;align-items:center">
          <h3>Current Alarm Rules</h3>
          <button class="btn" id="btnClearAllAlarms">🗑️ Clear All</button>
        </div>
        <div id="currentAlarmsContainer" style="max-height:400px;overflow-y:auto">
          <div class="small" style="color:#666;font-style:italic">No custom alarm rules created yet.</div>
        </div>
      </div>
      
      <!-- Template Library -->
      <div class="card" style="margin-top:16px">
        <h3>Template Library</h3>
        <div class="small" style="margin-bottom:12px">Quick-start templates based on common clinical scenarios:</div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px">
          <div class="template-card" data-template="hypoperfusion">
            <strong>Hypoperfusion Warning</strong>
            <div class="small">Lactate ≥ 2 mmol/L</div>
          </div>
          <div class="template-card" data-template="severe-shock">
            <strong>Severe Shock</strong>
            <div class="small">CI < 2.2 AND Lact ≥ 5</div>
          </div>
          <div class="template-card" data-template="rv-failure">
            <strong>RV Failure</strong>
            <div class="small">RAP ≥ 12 AND PAPI < 1.85</div>
          </div>
          <div class="template-card" data-template="congestion">
            <strong>BiV Congestion</strong>
            <div class="small">RAP ≥ 12 AND PCWP ≥ 18</div>
          </div>
          <div class="template-card" data-template="impella-wean">
            <strong>Impella Wean Ready</strong>
            <div class="small">Complex multi-parameter wean criteria</div>
          </div>
          <div class="template-card" data-template="metabolic-crisis">
            <strong>Metabolic Crisis</strong>
            <div class="small">pH ≤ 7.20 OR Lact ≥ 10</div>
          </div>
        </div>
      </div>
      
      <!-- Variables Reference -->
      <div class="card" style="margin-top:16px">
        <h3 style="margin-bottom:12px">📋 Available Variables</h3>
        <div class="small" style="margin-bottom:8px;color:#666">
          All variables you can use in alarm expressions. Click on any variable to copy it to clipboard.
        </div>
        <div class="small" style="margin-bottom:8px;padding:8px;background:#fff3cd;border:1px solid #ffeaa7;border-radius:4px">
          <strong>Standard Variables:</strong> Common hemodynamic and laboratory variables for alarm expressions. 
          The system automatically maps variable variants.
        </div>
        
        <details style="margin-bottom:12px">
          <summary style="cursor:pointer;color:#2563eb;font-weight:600">🔄 View Variable Mapping Table</summary>
          <div style="margin-top:8px;padding:8px;background:#f8f9fa;border-radius:4px">
            <table style="width:100%;font-size:12px;border-collapse:collapse">
              <thead>
                <tr style="background:#e9ecef">
                  <th style="padding:4px;text-align:left;border:1px solid #dee2e6">✅ Standard Variable</th>
                  <th style="padding:4px;text-align:left;border:1px solid #dee2e6">↔️ Mapped Variants</th>
                  <th style="padding:4px;text-align:left;border:1px solid #dee2e6">📝 Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace"><strong>Lactate</strong></td>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace">Lact</td>
                  <td style="padding:4px;border:1px solid #dee2e6">Serum lactate</td>
                </tr>
                <tr>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace"><strong>SvO2</strong></td>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace">svo2</td>
                  <td style="padding:4px;border:1px solid #dee2e6">Mixed venous saturation</td>
                </tr>
                <tr>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace"><strong>Dobutamine</strong></td>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace">Dobut</td>
                  <td style="padding:4px;border:1px solid #dee2e6">Dobutamine (dose)</td>
                </tr>
                <tr>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace"><strong>Dopamine</strong></td>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace">Dopa</td>
                  <td style="padding:4px;border:1px solid #dee2e6">Dopamine (dose)</td>
                </tr>
                <tr>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace"><strong>Norepinephrine</strong></td>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace">Norepi</td>
                  <td style="padding:4px;border:1px solid #dee2e6">Norepinephrine (dose)</td>
                </tr>
                <tr>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace"><strong>Epinephrine</strong></td>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace">Epi</td>
                  <td style="padding:4px;border:1px solid #dee2e6">Epinephrine (dose)</td>
                </tr>
                <tr>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace"><strong>Levosimendan</strong></td>
                  <td style="padding:4px;border:1px solid #dee2e6;font-family:monospace">Levo</td>
                  <td style="padding:4px;border:1px solid #dee2e6">Levosimendan (dose)</td>
                </tr>
              </tbody>
            </table>
          </div>
        </details>
        
        <!-- Search box -->
        <div style="margin-bottom:12px">
          <input type="text" id="variableSearch" placeholder="🔍 Search variables..." 
                 style="width:100%;padding:8px;border:1px solid #c9d7f8;border-radius:4px;box-sizing:border-box">
        </div>
        
        <div class="variables-grid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:16px">
          <!-- Hemodynamics -->
          <div class="variable-category">
            <h4 style="color:#2563eb;margin-bottom:8px;border-bottom:1px solid #e5e7eb">💓 Hemodynamics</h4>
            <div class="variable-list" style="display:flex;flex-wrap:wrap;gap:4px">
              <span class="variable-item" data-var="HR">HR</span>
              <span class="variable-item" data-var="SBP">SBP</span>
              <span class="variable-item" data-var="DBP">DBP</span>
              <span class="variable-item" data-var="MAP">MAP</span>
              <span class="variable-item" data-var="RAP">RAP</span>
              <span class="variable-item" data-var="PCWP">PCWP</span>
              <span class="variable-item" data-var="sPAP">sPAP</span>
              <span class="variable-item" data-var="dPAP">dPAP</span>
              <span class="variable-item" data-var="mPAP">mPAP</span>
              <span class="variable-item" data-var="CO">CO</span>
              <span class="variable-item" data-var="CI">CI</span>
              <span class="variable-item" data-var="SV">SV</span>
              <span class="variable-item" data-var="SVI">SVI</span>
              <span class="variable-item" data-var="SVR">SVR</span>
              <span class="variable-item" data-var="SVRI">SVRI</span>
              <span class="variable-item" data-var="PVR_WU">PVR_WU</span>
              <span class="variable-item" data-var="PVRI_WU">PVRI_WU</span>
              <span class="variable-item" data-var="PAPI">PAPI</span>
            </div>
          </div>
          
          <!-- Laboratory -->
          <div class="variable-category">
            <h4 style="color:#dc2626;margin-bottom:8px;border-bottom:1px solid #e5e7eb">🧪 Laboratory</h4>
            <div class="variable-list" style="display:flex;flex-wrap:wrap;gap:4px">
              <span class="variable-item" data-var="pH">pH</span>
              <span class="variable-item" data-var="Lactate">Lactate</span>
              <span class="variable-item" data-var="Creat">Creat</span>
              <span class="variable-item" data-var="ALT">ALT</span>
              <span class="variable-item" data-var="SvO2">SvO2</span>              
              </div>
          </div>
          
          <!-- PV Loop -->
          <div class="variable-category">
            <h4 style="color:#16a34a;margin-bottom:8px;border-bottom:1px solid #e5e7eb">📈 PV Loop</h4>
            <div class="variable-list" style="display:flex;flex-wrap:wrap;gap:4px">
              <span class="variable-item" data-var="ESP">ESP</span>
              <span class="variable-item" data-var="EDV">EDV</span>
              <span class="variable-item" data-var="ESV">ESV</span>
              <span class="variable-item" data-var="SV">SV</span>
              <span class="variable-item" data-var="SVI">SVI</span>
              <span class="variable-item" data-var="EF">EF</span>
              <span class="variable-item" data-var="Ees">Ees</span>
              <span class="variable-item" data-var="Ea">Ea</span>
              <span class="variable-item" data-var="VAC">VAC</span>
              <span class="variable-item" data-var="SW">SW</span>
              <span class="variable-item" data-var="PE">PE</span>
              <span class="variable-item" data-var="PVA">PVA</span>
              <span class="variable-item" data-var="Eff">Eff</span>
              <span class="variable-item" data-var="CPO">CPO</span>
              <span class="variable-item" data-var="CPI">CPI</span>
              <span class="variable-item" data-var="CPOa">CPOa</span>
              <span class="variable-item" data-var="CPIa">CPIa</span>
            </div>
          </div>
          
          <!-- Derived Indices -->
          <div class="variable-category">
            <h4 style="color:#8b5cf6;margin-bottom:8px;border-bottom:1px solid #e5e7eb">📊 Derived Indices</h4>
            <div class="variable-list" style="display:flex;flex-wrap:wrap;gap:4px">
              <span class="variable-item" data-var="OPP">OPP</span>
              <span class="variable-item" data-var="CPP">CPP</span>
              <span class="variable-item" data-var="LVSWi">LVSWi</span>
              <span class="variable-item" data-var="RVSWi">RVSWi</span>
              <span class="variable-item" data-var="SCAI">SCAI</span>
              <span class="variable-item" data-var="devicesOn">devicesOn</span>
              <span class="variable-item" data-var="drugsOn">drugsOn</span>
              <span class="variable-item" data-var="inotropesOn">inotropesOn</span>
              <span class="variable-item" data-var="pressorsOn">pressorsOn</span>
            </div>
          </div>
          
          <!-- Devices -->
          <div class="variable-category">
            <h4 style="color:#7c3aed;margin-bottom:8px;border-bottom:1px solid #e5e7eb">🔧 Devices</h4>
            <div class="variable-list" style="display:flex;flex-wrap:wrap;gap:4px">
              <span class="variable-item" data-var="SCAI">SCAI</span>
              <span class="variable-item" data-var="Impella">Impella</span>
              <span class="variable-item" data-var="Impella_flow_Lmin">Impella_flow_Lmin</span>
              <span class="variable-item" data-var="Impella_level">Impella_level</span>
              <span class="variable-item" data-var="IABP">IABP</span>
              <span class="variable-item" data-var="IABP_ratio">IABP_ratio</span>
              <span class="variable-item" data-var="ECMO">ECMO</span>
              <span class="variable-item" data-var="ECMO_flow_Lmin">ECMO_flow_Lmin</span>
              <span class="variable-item" data-var="ECMO_rpm">ECMO_rpm</span>
              <span class="variable-item" data-var="LVAD">LVAD</span>
              <span class="variable-item" data-var="Temp_device">Temp_device</span>
            </div>
          </div>
          
          <!-- Medications -->
          <div class="variable-category">
            <h4 style="color:#f59e0b;margin-bottom:8px;border-bottom:1px solid #e5e7eb">💊 Medications</h4>
            <div class="variable-list" style="display:flex;flex-wrap:wrap;gap:4px">
              <span class="variable-item" data-var="Dobutamine">Dobutamine</span>
              <span class="variable-item" data-var="Dopamine">Dopamine</span>
              <span class="variable-item" data-var="Norepinephrine">Norepinephrine</span>
              <span class="variable-item" data-var="Epinephrine">Epinephrine</span>
              <span class="variable-item" data-var="Milrinone">Milrinone</span>
              <span class="variable-item" data-var="Levosimendan">Levosimendan</span>
              <span class="variable-item" data-var="Vasopressin">Vasopressin</span>
              <span class="variable-item" data-var="LVIS">LVIS</span>
            </div>
          </div>
          
          <!-- Functions -->
          <div class="variable-category">
            <h4 style="color:#059669;margin-bottom:8px;border-bottom:1px solid #e5e7eb">⚙️ Functions</h4>
            <div class="variable-list" style="display:flex;flex-wrap:wrap;gap:4px">
              <span class="variable-item" data-var="CountTrue([])">CountTrue([condition1, condition2])</span>
              <span class="variable-item" data-var="Delta()">Delta(variable)</span>
              <span class="variable-item" data-var="isRising()">isRising(variable)</span>
              <span class="variable-item" data-var="isDecreasing()">isDecreasing(variable)</span>
              <span class="variable-item" data-var="Math.abs()">Math.abs(number)</span>
              <span class="variable-item" data-var="Math.max()">Math.max(a, b)</span>
              <span class="variable-item" data-var="Math.min()">Math.min(a, b)</span>
            </div>
          </div>
          
          <!-- Custom Variables (Dynamic) -->
          <div class="variable-category" id="customVariablesCategory" style="display:none">
            <h4 style="color:#8b5cf6;margin-bottom:8px;border-bottom:1px solid #e5e7eb">🧮 Custom Variables</h4>
            <div class="variable-list" id="customVariablesPanel" style="display:flex;flex-wrap:wrap;gap:4px">
              <!-- Custom variables will be added here dynamically -->
            </div>
          </div>
        </div>
      </div>
      
      <!-- Variable Descriptions removed per user request -->
      
      <!-- Variable Builder -->
      <div class="card" style="margin-top:16px">
        <h3 style="margin-bottom:12px">🧮 Variable Builder</h3>
        <div class="small">Create custom variables that can be used in alarm expressions. Variables are automatically saved to /lib/variablesbuild.js</div>
        
        <div class="row" style="margin-top:12px">
          <div style="flex:1">
            <label>Variable Name:</label>
            <input type="text" id="variableName" placeholder="e.g., MyCustomIndex" style="width:100%" />
          </div>
          <div style="flex:2">
            <label>Expression:</label>
            <input type="text" id="variableExpression" placeholder="e.g., (CI * MAP) / RAP" style="width:100%" />
          </div>
          <div>
            <label>&nbsp;</label>
            <button class="btn primary" id="btnAddVariable">➕ Add Variable</button>
            <button class="btn" id="btnShowMultipleVariables" style="margin-left:8px;background:#e8f4fd">📝 Multiple Variables</button>
            <button class="btn" id="btnSetupVariablesDirect" title="Setup direct file update for variables (bypass CORS)" style="margin-left:8px;background:#d4edda">🔧 Setup Direct Update</button>
          </div>
        </div>

        <div style="margin-top:12px">
          <label>Description (optional):</label>
          <input type="text" id="variableDescription" placeholder="Brief description of what this variable represents" style="width:100%" />
        </div>

        <div id="variableValidationResult" style="margin-top:8px;min-height:20px"></div>

        <!-- Custom Variables List -->
        <div style="margin-top:16px">
          <h4>📝 Custom Variables</h4>
          <div class="small">Click a variable to copy to clipboard</div>
          <div id="customVariablesList" style="margin-top:8px"></div>
        </div>
        
        <!-- Multiple Variables Editor (Hidden by default) -->
        <div class="card" id="multipleVariablesCard" style="margin-top:16px;display:none">
          <h4 style="margin-bottom:12px">📝 Multiple Variables Editor</h4>
          <div class="small" style="margin-bottom:12px;color:#666">
            Create multiple custom variables at once using JSON format.
          </div>
          
          <div style="margin-bottom:12px">
            <label style="display:block;margin-bottom:4px"><strong>Multiple Variables Format:</strong></label>
            <textarea id="multipleVariablesEditor" 
                     placeholder="JSON Format Example:
[
  {
    name: 'PerfusionIndex',
    expression: '(CI * MAP) / RAP',
    description: 'Custom perfusion assessment index'
  },
  {
    name: 'ShockIndex',
    expression: 'HR / SBP',
    description: 'Simple shock index calculation'
  },
  {
    name: 'CongestiveLoad',
    expression: 'RAP + PCWP',
    description: 'Combined congestion indicator'
  }
]

Each variable needs: name (required), expression (required), description (optional)"
                     style="width:100%;height:300px;font-family:monospace;padding:12px;border:1px solid #c9d7f8;border-radius:4px;resize:vertical;box-sizing:border-box"></textarea>
          </div>
          
          <div class="row" style="justify-content:space-between">
            <div>
              <button class="btn primary" id="btnProcessMultipleVariables">⚡ Process Multiple Variables</button>
              <button class="btn" id="btnValidateMultipleVariables" style="margin-left:8px">✅ Validate Format</button>
              <button class="btn" id="btnHideMultipleVariables" style="margin-left:8px">❌ Cancel</button>
            </div>
          </div>
          <div id="multipleVariablesValidationResult" class="small" style="margin-top:8px"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- ABOUT -->
  <section id="sec-about" class="section">
    <div class="card mono">
      <h2>About PV-One App</h2>
      <div class="small" style="margin-top:6px">
  <strong>Version:</strong> v3.0 &nbsp;&nbsp;|&nbsp;&nbsp; <strong>Build Date:</strong> October 2025<br>
        <strong>Authors:</strong> Dr. Jorge A. Ortega-Hernández, MD, FESC, FACC · Dr. Luca Baldetti, MD · Dr. Guglielmo Gallone, MD · Dr. Pier Paolo Bocchino, MD · Dr. Giulio Cacioli, MD<br>
        <strong>Lead Institution:</strong> Instituto Nacional de Cardiología Ignacio Chávez, Mexico City<br>
        <strong>Collaborative Network:</strong> ITA-MEX Cardiogenic Shock Registry
      </div>

      <h3 style="margin-top:12px">Author Affiliations</h3>
      <div class="small">
        • <strong>Dr. Jorge A. Ortega-Hernández, MD, FESC, FACC</strong> — Coronary Care Unit, Instituto Nacional de Cardiología Ignacio Chávez, Mexico City, Mexico<br>
        • <strong>Dr. Luca Baldetti, MD</strong> — Cardiac Intensive Care Unit, IRCCS San Raffaele Scientific Institute, Milan, Italy<br>
        • <strong>Dr. Guglielmo Gallone, MD</strong> — Division of Cardiology, Cardiovascular and Thoracic Department, "Città della Salute e della Scienza" Hospital, Turin, Italy<br>
        • <strong>Dr. Pier Paolo Bocchino, MD</strong> — Division of Cardiology, Cardiovascular and Thoracic Department, "Città della Salute e della Scienza" Hospital, Turin, Italy<br>
        • <strong>Dr. Giulio Cacioli, MD</strong> — Cardiac Surgery and Heart Transplant Unit, Azienda Ospedaliera San Camillo Forlanini, Rome, Italy
      </div>

      <h3 style="margin-top:12px">Purpose</h3>
      <div class="small">PV-One Clinical Dashboard is an independent, open-source research and educational platform developed to help clinicians and investigators visualize and interpret hemodynamic, echocardiographic, and pressure–volume loop-derived data in acute heart failure and cardiogenic shock. It aims to enhance understanding and research, not to provide automated diagnosis or treatment guidance.</div>

      <h3 style="margin-top:12px">Intended Use</h3>
      <div class="small">PV-One is designed for use by qualified healthcare professionals and researchers familiar with cardiovascular critical care. It supports interpretation and learning but does not replace clinical judgment or institutional decision-making. All therapeutic or procedural actions must be confirmed by a licensed physician.</div>

      <h3 style="margin-top:12px">Notice</h3>
      <div class="small">PV-One is not a certified medical device and has not been reviewed or approved by any regulatory agency.</div>

      <h3 style="margin-top:12px">Legal Disclaimer</h3>
      <div class="small">PV-One is provided “as is”, without warranty of any kind, express or implied, including but not limited to accuracy, reliability, or fitness for a particular purpose. Use of the software implies full responsibility for any interpretations or actions based on its outputs. The developers and institutions assume no liability for any consequence, direct or indirect, arising from its use.</div>

      <h3 style="margin-top:12px">Attribution and Modifications</h3>
      <div class="small">PV-One is distributed under a non-commercial academic open-source license. You may use, copy, or modify the code for research and educational purposes provided that proper credit is given to the original authors and institutions in any derived work, publication, or redistributed version. All modified or extended versions must include a visible acknowledgment in the About or Credits section stating:<br>
        <em>"Based on PV-One Clinical Dashboard, developed by Dr. Jorge A. Ortega-Hernández, Dr. Luca Baldetti, Dr. Guglielmo Gallone, Dr. Pier Paolo Bocchino, Dr. Giulio Cacioli, of the ITA-MEX Cardiogenic Shock Registry."</em>
        Maintaining this attribution ensures transparency, collaboration, and recognition of all co-authors and contributors.</div>

      <h3 style="margin-top:12px">Privacy and Data Protection</h3>
      <div class="small">PV-One runs entirely offline and does not transmit or store identifiable patient data. Users are responsible for compliance with local data-protection laws.</div>

      <h3 style="margin-top:12px">Open Science Commitment</h3>
      <div class="small">PV-One is part of the ITA-MEX Open Cardiogenic Shock Research Initiative. All computational methods are publicly documented to promote reproducibility, scientific exchange, and international collaboration.</div>

      <h3 style="margin-top:12px">Formula References</h3>
      <div class="small">
        <span style="font-size:11px">
        1. Kremer N, et al. Method for generating right ventricular pressure-volume loops in routine practice. J Heart Lung Transplant 2025;0:1–9.<br>
        2. Monge García MI, et al. Understanding arterial load. Intensive Care Med 2016;42:1625–1627.<br>
        3. Chen CH, et al. Noninvasive single-beat determination of left ventricular end-systolic elastance in humans. J Am Coll Cardiol 2001;38:2028–2034.<br>
        4. Kelly RP, et al. Effective arterial elastance as index of arterial vascular load in humans. Circulation 1992;86:513–521.<br>
        5. Holm H, et al. How to calculate ventricular–arterial coupling? Eur J Heart Fail 2022;24:600–602.<br>
        6. Fazzini L, et al. Left ventricular-arterial coupling and mortality in the cardiac intensive care unit. Eur Heart J Acute Cardiovasc Care 2025;00:1–9.<br>
        7. Arvidsson PM, et al. Noninvasive Pressure-Volume Loops Predict Major Adverse Cardiac Events in Heart Failure With Reduced Ejection Fraction. JACC: Advances 2024;3.<br>
        8. Hieda M, Goto Y. Cardiac Mechanoenergetics in Patients with Acute Myocardial Infarction: From Pressure-Volume Loop Diagram Related to Cardiac Oxygen Consumption. Heart Fail Clin 2020;16:255–269.<br>
        9. Shin WJ, et al. Effect of ventriculo-arterial coupling on transplant outcomes in cirrhotics: Analysis of pressure-volume curve relations. J Hepatol 2017;66:328–337.<br>
        10. Klotz S, et al. A computational method of prediction of the end-diastolic pressure-volume relationship by single beat. Nat Protoc 2007;2:2152–2158.<br>
        11. Klotz S, et al. Single-beat estimation of end-diastolic pressure-volume relationship: A novel method with potential for noninvasive application. Am J Physiol Heart Circ Physiol 2006;291:403–412.
        </span>
      </div>

      <h3 style="margin-top:12px">Contact</h3>
      <div class="small">For feedback, collaboration, or academic inquiries: <a href="mailto:jorgeoh1992@gmail.com">jorgeoh1992@gmail.com</a></div>
    </div>
  </section>
  <!-- timeline section removed; gauges moved into dashboard -->

  <!-- SUMMARIES -->
  <section id="sec-summaries" class="section">
    <div class="card">
      <h2>Copy-ready clinical summaries</h2>
      
  <!-- Modern Summary Controls -->
  <div class="summary-controls" style="display:flex;gap:12px;align-items:center;margin-top:16px;padding:12px 16px;background:linear-gradient(135deg, #f8fafb 0%, #ffffff 100%);border:1px solid #e2e8f0;border-radius:10px;flex-wrap:wrap;box-shadow:0 1px 3px rgba(0,0,0,0.04)">
        
        <!-- Language Pills -->
        <div style="display:flex;align-items:center;gap:8px">
          <span style="font-size:13px;color:#64748b;font-weight:500">Language</span>
          <div id="summaryLangPills" style="display:flex;gap:4px;background:#fff;padding:3px;border-radius:8px;border:1px solid #e2e8f0">
            <button class="lang-pill" data-lang="es" title="Español" aria-label="Español" style="padding:6px 12px;border:none;border-radius:6px;font-size:18px;line-height:1;cursor:pointer;transition:all 0.15s;background:transparent;color:#64748b">
              <span class="flag-icon" aria-hidden="true" style="display:inline-flex;gap:6px;align-items:center">
                <!-- Spain (ES) - more detailed with simple coat-of-arms mark -->
                <svg class="flag" width="24" height="14" viewBox="0 0 24 14" xmlns="http://www.w3.org/2000/svg" role="img" focusable="false">
                  <defs>
                    <linearGradient id="esGrad" x1="0" x2="0" y1="0" y2="1">
                      <stop offset="0" stop-color="#e31b23"/>
                      <stop offset="1" stop-color="#c60b1e"/>
                    </linearGradient>
                  </defs>
                  <rect width="24" height="14" fill="url(#esGrad)"/>
                  <rect y="4" width="24" height="6" fill="#ffc400"/>
                  <!-- simplified coat-of-arms at left center -->
                  <g transform="translate(4,5)">
                    <rect x="-1" y="0" width="3" height="4" fill="#8b5a2b" rx="0.4"/>
                    <circle cx="0.5" cy="2" r="0.9" fill="#fff"/>
                    <path d="M0 1 L1 3 L-1 3 Z" fill="#b22234"/>
                  </g>
                </svg>
                <!-- Mexico (MX) - more detailed with eagle emblem hint -->
                <svg class="flag" width="24" height="14" viewBox="0 0 24 14" xmlns="http://www.w3.org/2000/svg" role="img" focusable="false">
                  <rect width="8" height="14" x="0" fill="#007b43"/>
                  <rect width="8" height="14" x="8" fill="#ffffff"/>
                  <rect width="8" height="14" x="16" fill="#ce1126"/>
                  <!-- emblem: stylized eagle + wreath (very simplified) -->
                  <g transform="translate(12,7) scale(0.9)">
                    <path d="M-1.2,-1.2 C-1.0,-0.2 0.6,-0.2 1.0,-1.0 C0.4,-0.6 0.0,-0.6 -0.6,-0.9 C-0.9,-1.0 -1.3,-1.4 -1.2,-1.2 Z" fill="#8b5a2b"/>
                    <circle cx="0" cy="0.4" r="0.6" fill="#2e7d32"/>
                    <circle cx="0" cy="0.4" r="0.25" fill="#ce1126"/>
                  </g>
                </svg>
              </span>
            </button>
            <button class="lang-pill active" data-lang="en" title="English" aria-label="English" style="padding:6px 12px;border:none;border-radius:6px;font-size:18px;line-height:1;cursor:pointer;transition:all 0.15s;background:#2563eb;color:#fff">
              <span class="flag-icon" aria-hidden="true" style="display:inline-flex;gap:6px;align-items:center">
                <!-- United States (US) - more realistic with stars grid -->
                <svg class="flag" width="24" height="14" viewBox="0 0 24 14" xmlns="http://www.w3.org/2000/svg" role="img" focusable="false">
                  <rect width="24" height="14" fill="#b22234"/>
                  <g fill="#fff">
                    <rect y="1.2" width="24" height="1.2"/>
                    <rect y="3.6" width="24" height="1.2"/>
                    <rect y="6.0" width="24" height="1.2"/>
                    <rect y="8.4" width="24" height="1.2"/>
                    <rect y="10.8" width="24" height="1.2"/>
                  </g>
                  <rect width="9.6" height="6.6" fill="#3c3b6e"/>
                  <!-- small star grid -->
                  <g fill="#fff" transform="translate(1.6,1.2) scale(0.8)">
                    <circle cx="1" cy="1" r="0.4" />
                    <circle cx="3" cy="1" r="0.4" />
                    <circle cx="5" cy="1" r="0.4" />
                    <circle cx="2" cy="2" r="0.4" />
                    <circle cx="4" cy="2" r="0.4" />
                    <circle cx="1" cy="3" r="0.4" />
                    <circle cx="3" cy="3" r="0.4" />
                    <circle cx="5" cy="3" r="0.4" />
                  </g>
                </svg>
                <!-- United Kingdom (GB) - refined Union Jack -->
                <svg class="flag" width="24" height="14" viewBox="0 0 24 14" xmlns="http://www.w3.org/2000/svg" role="img" focusable="false">
                  <rect width="24" height="14" fill="#012169"/>
                  <!-- Diagonal white -->
                  <g stroke="#fff" stroke-width="2">
                    <path d="M0 0 L24 14 M24 0 L0 14" stroke-linecap="square"/>
                  </g>
                  <!-- Diagonal red -->
                  <g stroke="#C8102E" stroke-width="1.1">
                    <path d="M0 0 L24 14 M24 0 L0 14" stroke-linecap="square"/>
                  </g>
                  <!-- Cross -->
                  <g stroke="#fff" stroke-width="2">
                    <path d="M12 0 L12 14 M0 7 L24 7"/>
                  </g>
                  <g stroke="#C8102E" stroke-width="1.6">
                    <path d="M12 0 L12 14 M0 7 L24 7"/>
                  </g>
                </svg>
              </span>
            </button>
            <button class="lang-pill" data-lang="it" title="Italiano" aria-label="Italiano" style="padding:6px 12px;border:none;border-radius:6px;font-size:18px;line-height:1;cursor:pointer;transition:all 0.15s;background:transparent;color:#64748b">
              <span class="flag-icon" aria-hidden="true" style="display:inline-flex;gap:6px;align-items:center">
                <!-- Italy (IT) - cleaner tricolor -->
                <svg class="flag" width="24" height="14" viewBox="0 0 24 14" xmlns="http://www.w3.org/2000/svg" role="img" focusable="false">
                  <rect width="8" height="14" x="0" fill="#009246"/>
                  <rect width="8" height="14" x="8" fill="#ffffff"/>
                  <rect width="8" height="14" x="16" fill="#ce2b37"/>
                  <rect x="9.6" y="2.2" width="0.4" height="9.6" fill="#e6e6e6" opacity="0.08"/>
                </svg>
              </span>
            </button>
          </div>
        </div>

        <!-- Divider -->
        <div style="width:1px;height:32px;background:#e2e8f0"></div>

        <!-- Time Selector -->
        <div style="display:flex;align-items:center;gap:8px">
          <span style="font-size:13px;color:#64748b;font-weight:500">Time</span>
          <select id="summaryTimeFilter" class="input" style="padding:7px 12px;border:1px solid #e2e8f0;border-radius:7px;font-size:13px;min-width:110px;background:#fff">
            <option value="all">All timepoints</option>
          </select>
        </div>

        <div style="flex:1"></div>

        <!-- Action Buttons -->
        <div style="display:flex;gap:8px">
          <button class="btn" id="btnCopySummary" style="display:flex;align-items:center;gap:6px;padding:7px 14px;background:#2563eb;color:#fff;border:none;border-radius:7px;font-size:13px;font-weight:500;cursor:pointer">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
            Copy
          </button>
          <button class="btn" id="btnSaveSummary" style="display:flex;align-items:center;gap:6px;padding:7px 14px;border:1px solid #e2e8f0;background:#fff;color:#334155;border-radius:7px;font-size:13px;font-weight:500;cursor:pointer">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
            Save
          </button>
          <button class="btn" onclick="generateSummaries()" style="display:flex;align-items:center;gap:6px;padding:7px 14px;border:1px solid #e2e8f0;background:#fff;color:#334155;border-radius:7px;font-size:13px;font-weight:500;cursor:pointer">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
            Regenerate
          </button>
        </div>
      </div>

      <!-- Single Summary Display Area -->
      <div style="margin-top:16px">
        <!-- Summary Header with Stats -->
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
          <div style="display:flex;align-items:center;gap:12px">
            <h3 id="summaryLangLabel" style="margin:0;font-size:16px;color:#1e293b">English</h3>
            <div class="summary-stats-badge" style="display:flex;align-items:center;gap:8px;padding:4px 10px;background:#f1f5f9;border-radius:6px">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline></svg>
              <span id="summaryStats" style="font-size:12px;color:#64748b;font-weight:500">0 lines · 0 chars</span>
            </div>
          </div>
          <div style="font-size:12px;color:#94a3b8">Generated with visible timepoints</div>
        </div>

        <!-- Main Summary Box -->
        <div id="summaryDisplay" class="summaryBox" style="min-height:320px;padding:16px;border-radius:10px;background:#fbfcfd;border:1px solid #e2e8f0;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;line-height:1.7;overflow:auto;box-shadow:inset 0 1px 2px rgba(0,0,0,0.02);color:#1e293b"></div>
      </div>

      <!-- Hidden storage for all languages -->
      <div style="display:none">
        <div id="sumES"></div>
        <div id="sumEN"></div>
        <div id="sumIT"></div>
      </div>
    </div>
  </section>

</div>

  <script>
  // canonical alias map used for deduplication and normalization
  const VAR_ALIAS = {
    'lact':'Lactate','lactate':'Lactate','lactato':'Lactate',
    'creat':'Creat','creatinine':'Creat',
    'svo2':'SvO2','svo':'SvO2','svO2':'SvO2',
    'dobut':'Dobutamine','dobutamine':'Dobutamine',
    'dopa':'Dopamine','dopamine':'Dopamine',
    'norepi':'Norepinephrine','norepinephrine':'Norepinephrine','norep':'Norepinephrine',
    'epi':'Epinephrine','epinephrine':'Epinephrine',
    'levo':'Levosimendan','levos':'Levosimendan','levosimendan':'Levosimendan'
  };

  function canonicalOfVar(s){ if(!s) return s; const t = String(s).trim(); const k = t.toLowerCase(); return VAR_ALIAS[k] || t; }

  function dedupeCustomVariables(){
    // Deduplicate variable chips (.variable-item)
    const seen = new Set();
    document.querySelectorAll('.variable-item').forEach(el=>{
      const v = el.dataset.var || el.textContent || '';
      const canon = canonicalOfVar(v);
      if(seen.has(canon)){
        el.remove();
      } else {
        if((el.dataset.var && el.dataset.var !== canon) || el.textContent.trim() !== canon){
          el.dataset.var = canon; el.textContent = canon;
        }
        seen.add(canon);
      }
    });
    // For the descriptions table we rebuild deterministically (see rebuildVariableDescriptionsTable)
    try{ rebuildVariableDescriptionsTable(); }catch(e){ console.debug('rebuildVariableDescriptionsTable failed', e); }
    console.debug('variable dedupe: completed, canonicalized variables:', Array.from(seen).slice(0,50));
  }

  // Rebuild the Variable Descriptions table from the existing rows.
  // - canonicalizes variable names using VAR_ALIAS
  // - removes duplicates (keeps first-seen description)
  // - preserves category headers and order
  // - sorts variables alphabetically within each category
  function rebuildVariableDescriptionsTable(){
    const tbody = document.getElementById('variableDescriptionsTableBody');
    if(!tbody) return;
    const rows = Array.from(tbody.querySelectorAll('tr'));
    const categories = [];
    let curCat = null;
    const seen = new Set();

    rows.forEach(row => {
      // Detect category header rows (convention: have class 'category-header' or only one cell)
      const cells = Array.from(row.querySelectorAll('td'));
      if(cells.length === 1 && row.classList.contains('category-header')){
        curCat = { name: cells[0].textContent.trim() || 'General', items: [] };
        categories.push(curCat);
        return;
      }
      if(cells.length >= 1){
        const rawName = cells[0].textContent.trim();
        if(!rawName) return;
        const desc = (cells[1] ? cells[1].textContent.trim() : '');
        const name = canonicalOfVar(rawName) || rawName;
        if(seen.has(name)) return; // skip duplicates, keep first seen
        seen.add(name);
        if(!curCat){ curCat = { name: 'Variables', items: [] }; categories.push(curCat); }
        curCat.items.push({ name, desc });
      }
    });

    // Sort items within each category
    categories.forEach(cat => { cat.items.sort((a,b)=> a.name.localeCompare(b.name)); });

    // Rebuild tbody
    tbody.innerHTML = '';
    categories.forEach(cat => {
      const trCat = document.createElement('tr');
      const td = document.createElement('td'); td.colSpan = 2; td.className = 'category-header'; td.textContent = cat.name;
      trCat.appendChild(td);
      tbody.appendChild(trCat);
      cat.items.forEach(it => {
        const tr = document.createElement('tr');
        const td1 = document.createElement('td'); td1.textContent = it.name;
        const td2 = document.createElement('td'); td2.textContent = it.desc;
        tr.appendChild(td1); tr.appendChild(td2);
        tbody.appendChild(tr);
      });
    });
  }

  // Handlers moved into initGaugeTimeControls() to avoid duplicate listeners and to position the menu consistently

  // Initialize gauge controls after DOM is ready — helper to ensure elements exist
  function initGaugeTimeControls(){
    const btn = byId('btnGaugeTime');
    const menu = byId('gaugeTimesMenu');
    const useLast = byId('btnGaugeTimeUseLast');
    const clearBtn = byId('btnGaugeTimeClear');
    // attach handlers only if elements exist
    if(btn && menu && !btn.dataset.gaugeWired){
      btn.dataset.gaugeWired = '1';
      btn.addEventListener('click', (e)=>{
        e.stopPropagation(); e.preventDefault();
        const isShown = menu.style.display && menu.style.display !== 'none';
        if(isShown){ menu.style.display = 'none'; return; }
        // populate menu
        populateGaugeTimesMenu();
        // ensure menu is attached to body so it's not clipped by parent containers
        if(menu.parentElement !== document.body) document.body.appendChild(menu);
        // position menu just below the button
        const rect = btn.getBoundingClientRect();
        menu.style.position = 'absolute';
        menu.style.left = (rect.left + window.scrollX) + 'px';
        menu.style.top = (rect.bottom + window.scrollY + 6) + 'px';
        menu.style.right = 'auto';
        menu.style.display = 'block';
        menu.style.zIndex = 10000;
      });
    }
    if(useLast && !useLast.dataset.gaugeWired){
      useLast.dataset.gaugeWired = '1';
      useLast.addEventListener('click', ()=>{
        const cards = Array.from(document.querySelectorAll('.tpCard'));
        if(!cards.length) return; const idx = cards.length - 1;
        document.querySelectorAll('input[name="activeTP"]').forEach(r=> r.checked = false);
        const targetRadio = byId(`t_active_${idx}`); if(targetRadio) targetRadio.checked=true;
        const onChk = byId(`t_on_${idx}`); if(onChk) onChk.checked=true;
        if(menu) menu.style.display='none'; renderGauges(collectAll());
      });
    }
    if(clearBtn && !clearBtn.dataset.gaugeWired){
      clearBtn.dataset.gaugeWired = '1';
      clearBtn.addEventListener('click', ()=>{
        document.querySelectorAll('input[name="activeTP"]').forEach(r=> r.checked = false);
        if(menu) menu.style.display='none'; renderGauges(collectAll());
      });
    }
    // ensure outside-click close works (add only once)
    if(!window._gaugeOutsideClickWired){
      window._gaugeOutsideClickWired = true;
      document.addEventListener('click', (ev)=>{
        const _menu = byId('gaugeTimesMenu'); const _btn = byId('btnGaugeTime');
        if(!_menu) return;
        if(_menu.style.display === 'none' || _menu.style.display === '') return;
        const path = ev.composedPath ? ev.composedPath() : (ev.path || []);
        if(path && (path.includes(_menu) || path.includes(_btn))) return;
        if(_menu.contains && (_btn && _btn.contains && (_btn.contains(ev.target) || _menu.contains(ev.target)))) return;
        _menu.style.display = 'none';
      });
    }
  }

    // Populate the gauge times menu dynamically (created here so the menu works even if init ran earlier)
    function populateGaugeTimesMenu(){
      const menu = byId('gaugeTimesMenu'); if(!menu) return;
      try{
        menu.innerHTML = '';
        const header = document.createElement('div'); header.style.padding = '8px 10px'; header.style.display='flex'; header.style.justifyContent='space-between'; header.style.alignItems='center'; header.innerHTML = '<strong>Timepoints</strong>';
        menu.appendChild(header);

        const cards = Array.from(document.querySelectorAll('.tpCard'));
        const list = document.createElement('div'); list.style.maxHeight = '220px'; list.style.overflow = 'auto'; list.style.padding = '6px 10px';
        if(!cards.length){ list.innerHTML = '<div class="small">No timepoints</div>'; menu.appendChild(list); return; }

        cards.forEach((c,i)=>{
          const row = document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.justifyContent='space-between'; row.style.padding='6px 0';
          const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center'; left.style.gap='8px';
          const timeVal = byId(`t_time_${i}`)?.value || `T${i}`;
          const lbl = document.createElement('div'); lbl.textContent = timeVal; lbl.style.minWidth = '60px'; lbl.style.fontWeight = '600';
          left.appendChild(lbl);
          row.appendChild(left);

          const right = document.createElement('div');
          const selBtn = document.createElement('button'); selBtn.className = 'btn small'; selBtn.textContent = 'Select';
          selBtn.addEventListener('click', ()=>{
            // unset other actives
            document.querySelectorAll('input[name="activeTP"]').forEach(r=> r.checked = false);
            const rd = byId(`t_active_${i}`); if(rd) rd.checked = true;
            const onChk = byId(`t_on_${i}`); if(onChk) onChk.checked = true;
            if(menu) menu.style.display = 'none'; try{ renderGauges(collectAll()); }catch(e){}
          });
          right.appendChild(selBtn);
          row.appendChild(right);
          list.appendChild(row);
        });
        menu.appendChild(list);

        const foot = document.createElement('div'); foot.style.display='flex'; foot.style.justifyContent='space-between'; foot.style.padding='8px 10px';
        const leftF = document.createElement('div'); leftF.style.display='flex'; leftF.style.gap='8px';
        const btnUseLast = document.createElement('button'); btnUseLast.id = 'btnGaugeTimeUseLast'; btnUseLast.className = 'btn'; btnUseLast.textContent = 'First & Last';
        btnUseLast.addEventListener('click', ()=>{
          const n = cards.length; if(n===0) return; const idx = n-1;
          document.querySelectorAll('input[name="activeTP"]').forEach(r=> r.checked = false);
          const rd = byId(`t_active_${idx}`); if(rd) rd.checked = true;
          const onChk = byId(`t_on_${idx}`); if(onChk) onChk.checked = true;
          if(menu) menu.style.display='none'; try{ renderGauges(collectAll()); }catch(e){}
        });
        const btnClear = document.createElement('button'); btnClear.id = 'btnGaugeTimeClear'; btnClear.className='btn'; btnClear.textContent='Clear';
        btnClear.addEventListener('click', ()=>{
          document.querySelectorAll('input[name="activeTP"]').forEach(r=> r.checked = false);
          if(menu) menu.style.display='none'; try{ renderGauges(collectAll()); }catch(e){}
        });
        leftF.appendChild(btnUseLast); leftF.appendChild(btnClear);
        foot.appendChild(leftF);
        menu.appendChild(foot);

        // adjust position if helper exists
        try{ if(typeof adjustPopoverPosition === 'function') adjustPopoverPosition(menu); }catch(e){}
      }catch(e){ console.warn('populateGaugeTimesMenu failed', e); }
    }
  </script>

<!-- Alarm Explain Modal -->
<div id="explainModal" class="modal">
  <div class="modal-content">
    <span class="modal-close" onclick="closeModal('explainModal')">&times;</span>
    <div class="modal-header">
      <h3 id="explainModalTitle">Clinical Explanation</h3>
    </div>
    <div id="explainModalContent"></div>
    <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--line);">
      <details>
        <summary style="cursor: pointer; color: var(--acc); font-weight: 600;">Technical Expression</summary>
        <div id="explainTechnicalDetails" style="margin-top: 10px; padding: 10px; background: var(--panel); border-radius: 6px; font-family: monospace; font-size: 13px;"></div>
      </details>
    </div>
  </div>
</div>

<!-- Alarm Suggest Modal -->
<div id="suggestModal" class="modal">
  <div class="modal-content">
    <span class="modal-close" onclick="closeModal('suggestModal')">&times;</span>
    <div class="modal-header">
      <h3 id="suggestModalTitle">Suggested Actions</h3>
    </div>
    <div id="suggestModalContent"></div>
  </div>
</div>

<script>
/* ===================== State ===================== */
const DEV_KEYS = ["IABP","Impella","ECMO","VAD"];
const DOSE_KEYS = {
  Norepinephrine:{unit:"µg/kg/min"}, Epinephrine:{unit:"µg/kg/min"}, Dobutamine:{unit:"µg/kg/min"},
  Dopamine:{unit:"µg/kg/min"}, Milrinone:{unit:"µg/kg/min"},
  Vasopressin:{unit:"U/min"}, Levosimendan:{unit:"µg/kg/min"}
};
const TP_DEFAULTS = {
  time:'T0', on:true, active:false,
  HR:85, SBP:120, DBP:70, sPAP:45, dPAP:25, PCWP:18, RAP:12, CO:4.0, LVEF:50, EDV:150, ESV:70, Lactate:2.0,
  ALT:32, pH:7.40, OHCA:false,
  prior_therapy:false, mcs_for_CS:true,
  IABP:false, Impella:false, ECMO:false, VAD:false,
  Norepinephrine:0, Epinephrine:0, Dobutamine:0, Dopamine:0, Milrinone:0, Vasopressin:0, Levosimendan:0
};

/* ===================== Helpers ===================== */
// Use existing global helper if present (injected early) or fallback to document.getElementById
const byId = (typeof window.byId === 'function') ? window.byId.bind(window) : (id => document.getElementById(id));
  // Safe Plotly resize helper: only call resize when element is in DOM and has visible size
  window.safePlotlyResize = function(el){ try{ if(!el) return; if(typeof el === 'string') el = document.getElementById(el); if(!el) return; if(!document.body.contains(el)) return; const rect = el.getBoundingClientRect(); if(rect.width > 1 && rect.height > 1){ if(window.Plotly && window.Plotly.Plots && typeof window.Plotly.Plots.resize === 'function'){ try{ window.Plotly.Plots.resize(el); }catch(e){ /* ignore */ } } } }catch(e){} };
// Safety: by default do NOT perform automatic physical writes to avoid DevServer reloads.
// Set window.allowAutoPhysicalWrites = true in console or via UI only when you intentionally want automatic writes.
window.allowAutoPhysicalWrites = window.allowAutoPhysicalWrites === true;
  // ALARM debug: disabled by default. Enable via ?alarmDebug=1 or localStorage.ALARM_DEBUG="1".
  // You can also set `window.ALARM_DEBUG = true` in the console before evaluating rules.
  if(typeof window.ALARM_DEBUG === 'undefined'){
    try{
      const qs = (typeof URLSearchParams !== 'undefined') ? new URLSearchParams(location.search) : null;
      const fromQs = qs && qs.get('alarmDebug');
      const fromStore = (typeof localStorage !== 'undefined') ? localStorage.getItem('ALARM_DEBUG') : null;
      const parseBool = (v) => /^(1|true|yes|on)$/i.test(String(v||''));
      window.ALARM_DEBUG = parseBool(fromQs) || parseBool(fromStore) || false;
      if(window.ALARM_DEBUG){ try{ console.info('ALARM-DEBUG: enabled'); }catch(e){} }
    }catch(e){ window.ALARM_DEBUG = false; }
  }
// Default professional palette (contrasting, journal-style: Plotly/Tableau 10)
const DEFAULT_PV_COLORS = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'];
// hslColor kept as a compatibility function name: returns a color from the professional palette
const hslColor = i => DEFAULT_PV_COLORS[i % DEFAULT_PV_COLORS.length];
// Browser directory handle (File System Access API) when not running under Electron
let browserDirHandle = null;

// Persist directory handle in IndexedDB so Chrome can remember selected folder across sessions
const DB_NAME = 'pv-one-storage-v1';
const DB_STORE = 'handles';
function openDb(){
  return new Promise((resolve, reject)=>{
    try{
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = ()=>{ req.result.createObjectStore(DB_STORE); };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error || new Error('IndexedDB open failed'));
    }catch(e){ reject(e); }
  });
}
async function storeDirHandle(handle){
  if(!handle) return;
  try{
    const db = await openDb();
    const tx = db.transaction(DB_STORE, 'readwrite');
    tx.objectStore(DB_STORE).put(handle, 'browserDirHandle');
    return new Promise((res, rej)=>{ tx.oncomplete = ()=>{ db.close(); res(true); }; tx.onerror = ()=>{ db.close(); rej(tx.error); }; });
  }catch(e){ console.warn('storeDirHandle failed', e); }
}
async function loadStoredDirHandle(){
  try{
    const db = await openDb();
    return await new Promise((resolve, reject)=>{
      const tx = db.transaction(DB_STORE, 'readonly');
      const req = tx.objectStore(DB_STORE).get('browserDirHandle');
      req.onsuccess = ()=>{ try{ resolve(req.result); }catch(e){ resolve(null); } finally{ db.close(); } };
      req.onerror = ()=>{ db.close(); resolve(null); };
    });
  }catch(e){ console.warn('loadStoredDirHandle failed', e); return null; }
}

// Try to rehydrate stored browser directory handle on load (if supported)
;(async function(){
  try{
    if(window.showDirectoryPicker && typeof indexedDB !== 'undefined'){
      const stored = await loadStoredDirHandle();
      if(stored){
        // Do NOT call requestPermission automatically — it requires a user gesture.
        // Instead, check current permission state (queryPermission) and if granted restore the handle.
        try{
          const perm = (typeof stored.queryPermission === 'function') ? await stored.queryPermission({ mode: 'readwrite' }) : 'prompt';
          if(perm === 'granted'){
            browserDirHandle = stored;
            try{ byId('patientFolder').textContent = `Folder: ${browserDirHandle.name || 'Selected folder'}`; }catch(e){}
            try{ console.debug('Loaded stored browserDirHandle'); }catch(e){}
          } else {
            // Permission is not granted. Do not auto-request. Inform the user and ask them to click Folder to re-grant access.
            try{ byId('patientMsg').textContent = 'Stored folder available — click Folder to restore access'; }catch(e){}
            try{ console.debug('Stored browserDirHandle present but permission not granted'); }catch(e){}
            // Expose a flag for other code to show UI if needed
            window.hasStoredBrowserDir = true;
          }
        }catch(e){
          // Some browsers throw when calling queryPermission on a serialized handle — ignore silently and prompt user to re-select
          console.warn('Permission check failed for stored handle', e);
          try{ byId('patientMsg').textContent = 'Stored folder present but requires user action: click Folder to restore access'; }catch(_){}
          window.hasStoredBrowserDir = true;
        }
      }
    }
  }catch(e){ /* ignore */ }
})();

// Funciones de formulas.js ya están disponibles como globales

/* Shared color map for normal / warning / critical (used across gauges/tables/plots) */
const LEVEL_COLOR = { ok:'#16a34a', warn:'#f59e0b', bad:'#dc2626' };

/* ---- Alarm rule evaluator helpers (dynamic rules from datosalarmas.js) ---- */
// Compute simple rolling-window metrics (same logic used previously inside renderAlarms)
function computeRollingMetricsFor(vis, windowH){
  if(!vis || !vis.length) return null;
  const last = vis[vis.length-1];
  // helper to parse time as hours
  const asHoursLocal = (r)=>{
    const raw = r.time; const parseISO = byId('chkTimeISO')?.checked;
    if(parseISO){ const ms = Date.parse(raw); if(Number.isFinite(ms)){ const first = vis.find(x=>x.time); const firstMs = first? Date.parse(first.time) : null; if(firstMs) return (ms-firstMs)/3600000; return ms/3600000; } }
    const t = parseFloat(raw); return Number.isFinite(t)? t : null;
  };
  const lastH = asHoursLocal(last);
  const inWin = vis.filter(r=>{ const h = asHoursLocal(r); return h!=null ? (h >= lastH - windowH && h <= lastH) : true; });
  if(!inWin.length) return null;
  const first = inWin[0];
  const lactFirst = (first.Lactate !== undefined ? first.Lactate : first.Lact);
  const lactLast = (last.Lactate !== undefined ? last.Lactate : last.Lact);
  const lactClearPct = (Number.isFinite(lactFirst) && lactFirst>0 && Number.isFinite(lactLast))? ((lactFirst - lactLast)/lactFirst*100) : null;
  const lvPeaks = inWin.map(x=>Number.isFinite(x.LVIS)? x.LVIS : 0); const LVIS_peak = lvPeaks.length? Math.max(...lvPeaks) : null;
  const visPeaks = inWin.map(x=>Number.isFinite(x.LVIS)? x.LVIS : 0); const VIS_peak = visPeaks.length? Math.max(...visPeaks) : null;
  const dPCWP = (Number.isFinite(first.PCWP) && Number.isFinite(last.PCWP))? (last.PCWP - first.PCWP)/Math.max(1e-6, first.PCWP)*100 : null;
  const dRAP  = (Number.isFinite(first.RAP) && Number.isFinite(last.RAP))? (last.RAP - first.RAP)/Math.max(1e-6, first.RAP)*100 : null;
  return { lactClearPct, LVIS_peak, VIS_peak, dPCWP, dRAP, hoursWindow: windowH };
}

// Compile a rule expression string into a safe function (r = timepoint, ctx = helpers)
// This enhanced compiler supports a small DSL used in datosalarmas.js and attaches an
// `.explain(r,ctx)` helper to the returned function which evaluates clause-level
// truth for operator-level explainability.
function compileAlarmExpr(expr){
  if(!expr || typeof expr !== 'string') return (()=>false);
  // Basic sanitation: allow typical token chars and common operators. If totally weird, bail.
  const allowed = /^[A-Za-z0-9_\s"'()\[\].<>!=&|+\-*\/%,:?~]+$/;
  if(!allowed.test(expr)){
    return (()=>false);
  }

  // Work on a copy for transformation (preserve original for explain)
  const raw = expr.toString();
  let e = raw.replace(/\bAND\b/gi,'&&').replace(/\bOR\b/gi,'||').replace(/\bNOT\b/gi,'!');

  // Pre-process DSL constructs BEFORE the generic identifier -> r.<id> rewrite
  // 1) Delta(VAR) -> Delta('VAR') (Delta provided in ctx)
  e = e.replace(/Delta\(\s*([A-Za-z_]\w*)\s*\)/g, "Delta('$1')");

  // 2) Stage in ['C','D']  ->  (['C','D'].includes(r.Stage))
  e = e.replace(/\b([A-Za-z_]\w*)\s+in\s+(\[[^\]]+\])/g, (m, id, list)=>{
    return `(${list}.includes(${ 'r.'+id }))`;
  });

  // 3) Lactate_clearance_<20pct_12h  (support forms like _<20pct_12h, _<30pct_24h, _>=20pct_6to12h)
  e = e.replace(/Lactate_clearance_([<>]=?)(\d+)pct_(\d+)(?:to\d+)?h/g, (m, op, pct, win)=>{
    // use ctx.win{win} (e.g., ctx.win12) computed in renderAlarms; if missing expression yields false
    return `( (ctx.win${win} && ctx.win${win}.lactClearPct!=null) ? (ctx.win${win}.lactClearPct ${op} ${pct}) : false )`;
  });

  // 4) Creatinine_doubled -> compare to first value
  e = e.replace(/\bCreatinine_doubled\b/g, `( (Number(r.creatinine)||0) >= 2*(Number(ctx.first?.creatinine)||0) )`);

  // 5) >=2_failed_weans (shorthand) -> ctx.failedWeans >= 2
  e = e.replace(/>=\s*(\d+)_failed_weans/g, (m,n)=> `( (Number(ctx.failedWeans)||0) >= ${n} )`);

  // 6) CountTrue([ ... ]) — leave syntax but ensure CountTrue is available in ctx
  //    (we don't rewrite; CountTrue will be provided in ctx at runtime)

  // After DSL rewrites, convert bare identifiers into r.<id> (but leave ctx helpers and literals)
  // Avoid touching string literals (e.g. Delta("creatinine")) during identifier rewrite.
  // Save string literals to placeholders, perform identifier rewrite, then restore them.
  const stringLiterals = [];
  e = e.replace(/(['"])(.*?)\1/g, function(m){ stringLiterals.push(m); return '__STR_REPL_' + (stringLiterals.length-1) + '__'; });

  const helpers = ['vis','first','last','win6','win12','win24','computeRollingMetricsFor','CountTrue','Delta','failedWeans','Math','prev','isRising','isDecreasing','Inotrope_combination','Lactate_rising','Lactate_decreasing','Inotrope_combination'];
  e = e.replace(/\b([A-Za-z_]\w*)\b/g, (m)=>{
    // if this token is one of our string-literal placeholders, leave it alone
    if(/^__STR_REPL_\d+__$/.test(m)) return m;
    if(/^(true|false|null|undefined)$/i.test(m)) return m.toLowerCase();
    if(helpers.includes(m)) return m; // keep helper names as-is
    if(m==='Math') return 'Math';
    // numeric-only tokens left as-is
    if(/^[0-9]+$/.test(m)) return m;
    return 'r.'+m;
  });

  // Restore string literals
  e = e.replace(/__STR_REPL_(\d+)__/g, function(m, idx){ return stringLiterals[Number(idx)]; });

  // Build a wrapper function that returns boolean and also exposes an explain() method
  try{
    const mainFn = new Function('r','ctx', 'with(ctx){ try{ return Boolean(' + e + '); }catch(e){ return false; } }');

    // explain - attempt to split top-level clauses by && (best-effort) and evaluate each clause
    function splitTopLevel(src, sep){
      const out=[]; let depth=0, cur='';
      for(let i=0;i<src.length;i++){
        const ch = src[i];
        if(ch==='(') depth++; else if(ch===')') depth--; 
        if(depth===0 && src.slice(i, i+sep.length)===sep){ out.push(cur.trim()); cur=''; i+=sep.length-1; continue; }
        cur += ch;
      }
      if(cur.trim()) out.push(cur.trim());
      return out;
    }

    const wrapper = function(r, ctx){ return mainFn(r, ctx); };

    wrapper.explain = function(r, ctx){
      try{
        const clauses = splitTopLevel(e, '&&');
        const details = clauses.map(cl => {
          const fn = new Function('r','ctx', 'with(ctx){ try{ return Boolean(' + cl + '); }catch(e){ return false; } }');
          let res=false; try{ res = Boolean(fn(r,ctx)); }catch(e){ res=false; }
          return { clause: cl, result: res };
        });
        return { result: Boolean(mainFn(r,ctx)), details, expression: raw };
      }catch(err){ return { result: mainFn(r,ctx), details:[], expression: raw }; }
    };

    return wrapper;
  }catch(err){ return (()=>false); }
}

// Initialize compiled functions for ALARM_RULES (called once)
function initAlarmEvaluators(){
  if(!window.ALARM_RULES) return;
  window.ALARM_RULES.forEach(group=>{
    (group.items||[]).forEach(item=>{ item._fn = compileAlarmExpr(item.expr||item.expression||item.rule||''); });
  });
  if(window.ALARM_RULES_EXTRA){ window.ALARM_RULES_EXTRA.forEach(group=>{ (group.items||[]).forEach(item=>{ item._fn = compileAlarmExpr(item.expr||item.expression||item.rule||''); }); }); }
}

// Run init once now if rules are already loaded
try{ initAlarmEvaluators(); }catch(e){}
try{ renderAlarmsReference(); }catch(e){}

/* Tabs */
document.querySelectorAll('.tab').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    btn.classList.add('active');
    const key = btn.dataset.tab;
    document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
    const section = byId('sec-'+key);
    if(section) section.classList.add('active');
    if(key==='dash') { generateAll(); }
    if(key==='summaries') { generateSummaries(); }
  });
});

/* Dark mode toggle wiring */
byId('btnDarkToggle').addEventListener('click', ()=>{
  document.body.classList.toggle('dark');
  // re-render plots so Plotly picks up bg colors
  generateAll();
});

/* ===== Timepoint compact cards ===== */
function addTP(vals=TP_DEFAULTS){
  const i = document.querySelectorAll('.tpCard').length;
  const d = (k)=> (vals[k] ?? TP_DEFAULTS[k]);

  const card = document.createElement('div');
  card.className = 'tpCard mini';
  card.innerHTML = `
    <div class="tpHead" onclick="this.closest('.tpCard').classList.toggle('collapsed')">
      <label class="chip">✔ <input type="checkbox" id="t_on_${i}" ${d('on')?'checked':''}></label>
      <label class="chip">● <input type="radio" name="activeTP" id="t_active_${i}" ${d('active')?'checked':''}></label>
  <label class="chip">Time <input id="t_time_${i}" value="${d('time') || 'T0'}" style="width:90px"></label>
      <label class="chip">Color <input type="color" id="t_color_${i}" value="${d('color') || hslColor(i)}" title="Loop color" style="width:46px;height:28px;padding:0;border:0;background:transparent"></label>
      <span class="small" id="lock_${i}" style="margin-left:auto;display:none">🔒 Hybrid EDV/ESV</span>
      <button class="btn" onclick="toggleTP(this)" style="margin-left:8px">👁️ Hide</button>
      <button class="btn" onclick="delTP(this)" style="margin-left:6px">🗑️</button>
    </div>

  <div class="gcol-3"><label>HR <input type="number" id="t_hr_${i}" value="${d('HR')}"></label></div>
  <div class="gcol-3"><label>CO (L/min) <input type="number" step="0.1" id="t_co_${i}" value="${d('CO')}"></label></div>
  <div class="gcol-3"><label>LVEF (%) <input type="number" id="t_lvef_${i}" value="${d('LVEF')}"></label></div>
  <div class="gcol-3"><label>Lactate <input type="number" step="0.1" id="t_lac_${i}" value="${d('Lactate') || d('Lact') || 2.0}"></label></div>

  <div class="gcol-3"><label>SBP <input type="number" id="t_sbp_${i}" value="${d('SBP')}"></label></div>
  <div class="gcol-3"><label>DBP <input type="number" id="t_dbp_${i}" value="${d('DBP')}"></label></div>
  <div class="gcol-3"><label>sPAP <input type="number" id="t_spap_${i}" value="${d('sPAP')}"></label></div>
  <div class="gcol-3"><label>dPAP <input type="number" id="t_dpap_${i}" value="${d('dPAP')}"></label></div>

  <div class="gcol-3"><label>PCWP <input type="number" id="t_pwp_${i}" value="${d('PCWP')}"></label></div>
  <div class="gcol-3"><label>RAP <input type="number" id="t_rap_${i}" value="${d('RAP')}"></label></div>
  <div class="gcol-3"><label>ALT <input type="number" id="t_alt_${i}" value="${d('ALT')}"></label></div>
  <div class="gcol-3"><label>pH <input type="number" step="0.01" id="t_ph_${i}" value="${d('pH')}"></label></div>

  <div class="gcol-3"><label>EDV <input type="number" id="t_edv_${i}" value="${d('EDV')}"></label></div>
  <div class="gcol-3"><label>ESV <input type="number" id="t_esv_${i}" value="${d('ESV')}"></label></div>
  <div class="gcol-3"><label>OHCA <input type="checkbox" id="t_ohca_${i}" ${d('OHCA')?'checked':''}></label></div>

    <div class="gcol-12">
  <label class="chip">Prior therapy <input type="checkbox" id="t_prev_${i}" ${d('prior_therapy')?'checked':''}></label>
  <label class="chip">MCS for CS <input type="checkbox" id="t_mcs_cs_${i}" ${d('mcs_for_CS')?'checked':''}></label>
    </div>

    <div class="gcol-12">
      <div class="small" style="margin:6px 0;font-weight:500">Devices</div>
      <div class="devices-grid">
  <input type="checkbox" id="t_dev_IABP_${i}" ${d('IABP')?'checked':''}>
  <span>IABP</span>
  <select id="t_iabp_ratio_${i}" style="width:80px">${['1:1','1:2','>=1:4'].map(p=>`<option value="${p}" ${p===d('IABP_ratio')?'selected':''}>${p}</option>`).join('')}</select>
        
        <input type="checkbox" id="t_dev_Impella_${i}" ${d('Impella')?'checked':''}>
        <span>Impella</span>
        <div>
          <select id="t_impella_level_${i}" style="width:60px">${['P2','P3','P4','P5','P6','P7','P8','P9'].map(p=>`<option value="${p}" ${p===d('Impella_level')?'selected':''}>${p}</option>`).join('')}</select>
          <label style="margin:0;font-size:0.9em">Flow(L/min) <input type="number" step="0.1" id="t_impella_flow_${i}" value="${(d('Impella_flow_Lmin')!==undefined && d('Impella_flow_Lmin')!==null)? d('Impella_flow_Lmin') : (d('Impella')?1:0)}" style="width:60px"></label>
        </div>
        
        <input type="checkbox" id="t_dev_ECMO_${i}" ${d('ECMO')?'checked':''}>
        <span>ECMO</span>
        <div>
          <label style="margin:0;font-size:0.9em">RPM <input type="number" id="t_ecmo_rpm_${i}" value="${d('ECMO_rpm')||0}" style="width:80px"></label>
          <label style="margin:0;font-size:0.9em">Flow(L/min) <input type="number" step="0.1" id="t_ecmo_flow_${i}" value="${(d('ECMO_flow_Lmin')!==undefined && d('ECMO_flow_Lmin')!==null)? d('ECMO_flow_Lmin') : 0}" style="width:60px"></label>
        </div>
        
        <input type="checkbox" id="t_dev_VAD_${i}" ${d('VAD')?'checked':''}>
        <span>VAD</span>
  <span></span>
        
        <input type="checkbox" id="t_weaning_${i}" ${d('WEANING')?'checked':''}>
        <span>Weaning</span>
        <span></span>
      </div>
    </div>

    <div class="gcol-12">
      <div class="small" style="margin:6px 0">Doses (ON if &gt; 0):</div>
      <div class="row mono">
        ${Object.keys(DOSE_KEYS).map(k=>`
          <label>${k} (${DOSE_KEYS[k].unit}) <input type="number" step="0.01" id="t_dose_${k}_${i}" value="${d(k)}" style="width:90px"></label>
        `).join('')}
      </div>
    </div>

    <div class="gcol-3"><label>Creatinine (mg/dL) <input type="number" step="0.01" id="t_cr_${i}" value="${d('Cr')||''}" placeholder="optional"></label></div>
    <div class="gcol-3"><label>SvO2 (%) <input type="number" step="0.1" id="t_svo2_${i}" value="${d('SvO2')||''}" placeholder="optional"></label></div>
  `;
  byId('tpInputs').appendChild(card);
  applyReadOnly();
  if(!document.querySelector('input[name="activeTP"]:checked')) byId(`t_active_${i}`).checked=true;
  card.addEventListener('input', debounce(generateAll, 120));
  if(byId('tpInputs').style.display === 'none'){
    byId('tpInputs').style.display = '';
    byId('btnToggleInputs').textContent = '▼ Hide timepoints';
  }
}
function delTP(btn){
  btn.closest('.tpCard').remove();
  applyReadOnly(); generateAll();
}

function toggleTP(btn){
  // Toggle the 'on' checkbox for this specific timepoint card (avoid relying on numeric IDs)
  const card = btn.closest('.tpCard');
  const ch = card.querySelector('input[type="checkbox"][id^="t_on_"]');
  if(!ch) return;
  ch.checked = !ch.checked;
  btn.textContent = ch.checked ? '👁️ Hide' : '🙈 Hidden';
  // collapse visually when hidden
  card.classList.toggle('collapsed', !ch.checked);
  // Only refresh the PV loops plot when the per-timepoint hide button is used
  updatePVOnly();
}

// Re-render only the PV-loop plot (used when toggling visibility of a single timepoint)
function updatePVOnly(){
  try{
    const all = collectAll();
    // keep a snapshot of the last computed series for other incremental ops
    window._lastSeries = all;
    renderPV(all);
  }catch(e){ console.warn('updatePVOnly failed', e); }
}

/* Lock EDV/ESV in Hybrid */
function applyReadOnly(){
  const isHybrid = byId('method').value==='hybrid';
  document.querySelectorAll('.tpCard').forEach((row,idx)=>{
    const edv=byId(`t_edv_${idx}`), esv=byId(`t_esv_${idx}`), tag=byId(`lock_${idx}`);
    if(!edv||!esv||!tag) return;
    edv.readOnly=isHybrid; esv.readOnly=isHybrid; tag.style.display=isHybrid?'inline':'none';
  });
}
byId('method').addEventListener('change', ()=>{applyReadOnly(); generateAll();});

/* Debounce */
function debounce(fn,ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); } }

/* ================= Core calculations ================= */


// delegate to logic.calcOne if available
function calcOne(i){
  try{ 
    if(window.logic && typeof window.logic.calcOne === 'function') return window.logic.calcOne(i, document); 
  } catch(e){ 
    console.warn('logic.calcOne failed', e); 
  }
  
  // Fallback: create timepoint from form data
  try {
    const get = id => byId(id)?.type==='checkbox'? byId(id).checked : byId(id)?.value;
    const tp = {
      time: get(`t_time_${i}`), on: get(`t_on_${i}`), active: get(`t_active_${i}`),
      HR: parseFloat(get(`t_hr_${i}`))||0, CO: parseFloat(get(`t_co_${i}`))||0, LVEF: parseFloat(get(`t_lvef_${i}`))||0,
      EDV: parseFloat(get(`t_edv_${i}`))||0, ESV: parseFloat(get(`t_esv_${i}`))||0,
      SBP: parseFloat(get(`t_sbp_${i}`))||0, DBP: parseFloat(get(`t_dbp_${i}`))||0,
      sPAP: parseFloat(get(`t_spap_${i}`))||0, dPAP: parseFloat(get(`t_dpap_${i}`))||0,
      PCWP: parseFloat(get(`t_pwp_${i}`))||0, RAP: parseFloat(get(`t_rap_${i}`))||0,
  Lactate: parseFloat(get(`t_lac_${i}`))||0,
  Lact: parseFloat(get(`t_lac_${i}`))||0,
      ALT: parseFloat(get(`t_alt_${i}`))||0, pH: parseFloat(get(`t_ph_${i}`))||0,
      OHCA: !!byId(`t_ohca_${i}`)?.checked,
      prior_therapy: !!byId(`t_prev_${i}`)?.checked,
      mcs_for_CS: !!byId(`t_mcs_cs_${i}`)?.checked,
      devicesOn: 0, drugsOn: 0
    };
    // read lab/device fields that are not always provided by the centralized logic module
    try{
      const vcr = byId(`t_cr_${i}`)?.value; const ncr = parseFloat(vcr); tp.creatinine = Number.isFinite(ncr)? ncr : (vcr? vcr : null);
    }catch(e){ tp.creatinine = null; }
    try{ const vs = byId(`t_svo2_${i}`)?.value; const ns = parseFloat(vs); tp.svo2 = Number.isFinite(ns)? ns : (vs? vs : null); }catch(e){ tp.svo2 = null; }
    // maintain short aliases for compatibility
    if(tp.creatinine !== undefined && tp.Cr === undefined) tp.Cr = tp.creatinine;
    if(tp.svo2 !== undefined && tp.SvO2 === undefined) tp.SvO2 = tp.svo2;
    
    // Calculate derived values
    if (tp.SBP && tp.DBP) tp.MAP = (tp.SBP + 2 * tp.DBP) / 3;
    if (tp.CO && tp.HR) tp.SV = tp.CO * 1000 / tp.HR;
    
    return tp;
  } catch(e) {
    console.warn('calcOne fallback failed', e);
    return null;
  }
}

/* Collect & order */
function collectAll(){
  const rows=[...document.querySelectorAll('.tpCard')];
  const out=[]; rows.forEach((_,i)=>{ const r = (window.logic && typeof window.logic.calcOne==='function')? window.logic.calcOne(i, document) : calcOne(i); if(r) out.push(r);});
  out.forEach((r,i)=>{ 
    r.on = byId(`t_on_${i}`)?.checked; 
    r.active = byId(`t_active_${i}`)?.checked; 
    // prefer a user-selected color (color picker) if present, else fallback to generated HSL
    try{ r.color = (byId(`t_color_${i}`) && byId(`t_color_${i}`).value) ? byId(`t_color_${i}`).value : hslColor(i); }catch(e){ r.color = hslColor(i); }
    r.WEANING = !!byId(`t_weaning_${i}`)?.checked; 
  });
  out.sort((a,b)=>{ const an=parseFloat(a.time), bn=parseFloat(b.time); if(Number.isFinite(an)&&Number.isFinite(bn)) return an-bn; else return 0;});
  // Compute per-timepoint percent change in lactate vs previous timepoint and attach as delta_lactate
  for(let i=0;i<out.length;i++){
    const cur = out[i];
    const prev = out[i-1];
    const prevL = (prev && prev.Lactate !== undefined) ? prev.Lactate : (prev? prev.Lact : undefined);
    const curL = (cur && cur.Lactate !== undefined) ? cur.Lactate : (cur? cur.Lact : undefined);
    if(prev && Number.isFinite(prevL) && Number.isFinite(curL) && prevL !== 0){
      cur.delta_lactate = pct(prevL, curL);
    } else {
      cur.delta_lactate = null;
    }
  }

  try{ if(window.logic && typeof window.logic.computeSCAI === 'function') window.logic.computeSCAI(out); else computeSCAI(out); }catch(e){ computeSCAI(out); }
  return out;
}

/* ====== CSWG-SCAI logic (con separaciones de soporte) ====== */
function computeSCAI(vis){
  for(let i=0;i<vis.length;i++){
    const r = vis[i];
    const hypot_mild = (Number.isFinite(r.SBP)&&r.SBP>=60&&r.SBP<90) || (Number.isFinite(r.MAP)&&r.MAP>=50&&r.MAP<65);
    const hypot_sev  = (Number.isFinite(r.SBP)&&r.SBP<60) || (Number.isFinite(r.MAP)&&r.MAP<50);
  const lacVal = (r.Lactate !== undefined) ? r.Lactate : r.Lact;
  const hypoperf   = (Number.isFinite(lacVal)&&lacVal>2) || (Number.isFinite(r.pH)&&r.pH<7.30) || (Number.isFinite(r.ALT)&&r.ALT>200);
  const hypo_severe= (Number.isFinite(lacVal)&&lacVal>=10) || (Number.isFinite(r.pH)&&r.pH<=7.20);
  const hypoperf_grave = (Number.isFinite(lacVal)&&lacVal>=5) || (Number.isFinite(r.ALT)&&r.ALT>=500);
    const totalSupports = r.devicesOn + r.drugsOn;
    const deviceCS = r.mcs_for_CS && r.devicesOn>=1;

    // E primero
    if(hypot_sev || hypo_severe || r.drugsOn>=3 || r.devicesOn>=3 || r.OHCA){
      r.SCAI='E'; r.SCAI_reason = reasonText(r, {hypot_sev, hypo_severe, supportsTotal: totalSupports, OHCA:r.OHCA}) || '≥3 vasoactive drugs/devices'; continue;
    }
    // D por soporte muy alto (si no cumple E)
    if(totalSupports>=5){
      r.SCAI='D'; r.SCAI_reason = 'D by high total support (≥5)'; continue;
    }
    // D - hipotensión + hipoperfusión grave
    if( ( (hypot_mild || hypot_sev) && hypoperf_grave ) ){
      r.SCAI='D'; r.SCAI_reason = 'D due to hypotension + severe hypoperfusion'; continue;
    }
    // D/C por escalación/persistencia
    const D_escalation = (totalSupports>=2) || (totalSupports===1 && (hypot_mild || hypoperf));
    if(D_escalation){
      if(!r.prior_therapy){
        r.SCAI='C'; r.SCAI_reason='C (downgrade) for new therapy without prior support'; r.SCAI_downgrade_flag=1; r.SCAI_downgrade_reason='D by escalation without prior therapy';
        continue;
      } else {
        r.SCAI='D'; r.SCAI_reason='D by escalation/persistence'; continue;
      }
    }
    // C por dispositivo para CS
    if(deviceCS){
      r.SCAI='C'; r.SCAI_reason = 'C due to device (MCS for CS)'; continue;
    }
    // C (otras reglas)
    if( ( (hypot_mild||hypot_sev) && hypoperf ) || (totalSupports===1) ){
      r.SCAI='C'; r.SCAI_reason = 'C due to hypotension + hypoperfusion or single support'; continue;
    }
    // B
    const lacCheck = (r.Lactate !== undefined) ? r.Lactate : r.Lact;
    if(hypot_mild || (Number.isFinite(lacCheck)&&lacCheck>=2&&lacCheck<5) || (Number.isFinite(r.ALT)&&r.ALT>=200&&r.ALT<500) || (Number.isFinite(r.pH)&&r.pH>=7.20&&r.pH<7.30)){
      r.SCAI='B'; r.SCAI_reason = 'B with mild hypotension/hypoperfusion without support'; continue;
    }
    // A
    r.SCAI='A'; r.SCAI_reason = 'A stable (no hypotension/hypoperfusion/support)';
  }
}
function reasonText(r, flags){
  const arr=[];
  if(flags.hypot_sev) arr.push('severe hypotension');
  if(flags.hypo_severe) arr.push('severe hypoperfusion (lact ≥10 or pH ≤7.2)');
  if(flags.supportsTotal!=null) arr.push(`total supports=${flags.supportsTotal}`);
  if(flags.OHCA) arr.push('OHCA');
  return arr.join(' · ');
}

/* ======= Rendering ======= */
function renderPV(all){
  // If a module-based renderer exists (migrated to lib/renderers.js), prefer it.
  try{
    if(window.renderers && typeof window.renderers.renderPV === 'function'){
      try{ window.renderers.renderPV(all); return; }catch(err){ console.warn('renderers.renderPV failed, falling back to inline renderer', err); }
    }
  }catch(e){ /* ignore */ }
  
  // Check if Plotly is loaded, if not, load it asynchronously
  if (!window.Plotly) {
    window.loadPlotly().then(() => {
      renderPV(all); // Retry once Plotly is loaded
    }).catch(error => {
      console.error('Failed to load Plotly:', error);
    });
    return;
  }
  // Build traces only for timepoints that are 'on' so hidden timepoints are fully removed from the PV plot
  const traces = [];
  const vis = all.filter(r => r.on);
  const Nvis = vis.length;
  // Determine clinic mode by checking whether the dashboard plot container is inside a .clinic-theme ancestor
  const plotEl = document.getElementById('plotPV');
  const clinicMode = !!(plotEl && plotEl.closest && plotEl.closest('.clinic-theme'));
  function timeHue(i){ return 200 - ( (i / Math.max(1, Nvis-1)) * 180 ); } // hue from ~200 -> ~20
  vis.forEach((r, idx)=>{
    const h = timeHue(idx);
    // Prefer explicit color (from picker) else use shared palette via hslColor()
    const defaultCol = (typeof hslColor === 'function') ? hslColor(idx) : '#1f6fff';
    const timeColor = (r && r.color) ? r.color : defaultCol;
    // Fill: make a low-alpha variant of the chosen color (support hex and hsl)
    const fillColor = (r && r.color) ? (function(col){ try{ if(col.startsWith('hsl')) return col.replace('hsl','hsla').replace(')',',0.15)'); if(col.startsWith('#')){ const c = col.replace('#',''); const bigint = parseInt(c.length===3? c.split('').map(ch=>ch+ch).join('') : c,16); const rch = (bigint>>16)&255; const gch = (bigint>>8)&255; const bch = bigint&255; return `rgba(${rch},${gch},${bch},0.15)`; } return col; }catch(e){ return 'rgba(31,111,255,0.15)'; } })(r.color) : (function(col){ try{ if(col.startsWith('hsl')) return col.replace('hsl','hsla').replace(')',',0.15)'); if(col.startsWith('#')){ const cc = col.replace('#',''); const bigint = parseInt(cc.length===3? cc.split('').map(ch=>ch+ch).join('') : cc,16); const rch = (bigint>>16)&255; const gch = (bigint>>8)&255; const bch = bigint&255; return `rgba(${rch},${gch},${bch},0.15)`; } return col; }catch(e){ return `hsla(${Math.round(h)},70%,45%,0.15)`; } })(defaultCol);
    try{ if(!r._pvColor) r._pvColor = timeColor; if(!r._pvFillColor) r._pvFillColor = fillColor; }catch(e){}
    const base = { x:r.V_loop, y:r.P_loop, mode:'lines', name:`${r.time}`, line:{color:timeColor,width:r.active?4:3}, showlegend:false };
    traces.push({...base});
    if(r.active){
      // Use the same time-based color for auxiliary lines/fill when in clinic mode so each TP is visually consistent
      traces.push({x:r.V, y:r.P_EDPVR, mode:'lines', name:`EDPVR ${r.time}`, line:{color:timeColor, dash:'dot', width:2}, showlegend:false});
      traces.push({x:r.V_espvr, y:r.P_espvr, mode:'lines', name:`Ees (ESPVR) ${r.time}`, line:{color:timeColor, dash:'dash', width:2}, showlegend:false});
      traces.push({x:r.V_ea, y:r.P_ea, mode:'lines', name:`Ea ${r.time}`, line:{color:timeColor, dash:'dot', width:2}, showlegend:false});
      traces.push({x:r.V_loop.concat([r.V_loop[0]]), y:r.P_loop.concat([0]),
                   fill:'toself', mode:'lines', line:{color:timeColor,width:0}, fillcolor:fillColor,
                   name:`SW area ${r.time}`, showlegend:false, hoverinfo:'skip', opacity:1});
    }
  });
  // Prefer an active, visible trace for annotations; fallback to the first visible, then any
  const active = all.find(r=>r.active && r.on) || all.find(r=>r.on) || all[0];
  // If nothing is visible, clear the plot
  if(traces.length===0){ Plotly.purge('plotPV'); byId('pvLegend').innerHTML=''; return; }
  // Hide helper annotations when the plot is inside a clinical/dashboard themed container
  const ann = (active && !clinicMode)? [
    {x:active.V0_EDPVR, y:0, text:`V₀ ${active.V0_EDPVR.toFixed(1)} mL`, showarrow:true, ax:-20, ay:-30, bgcolor: document.body.classList.contains('dark') ? 'rgba(10,22,34,0.8)' : '#fff', bordercolor:'#c9d7f8'},
    {x:(active.EDV+active.ESV)/2, y:active.ESP*0.47, text:`VAC ${active.VAC.toFixed(2)} · Eff ${Number.isFinite(active.Eff)?active.Eff.toFixed(1):''}%`, showarrow:false, bgcolor: document.body.classList.contains('dark') ? 'rgba(10,22,34,0.8)' : '#fff', bordercolor:'#c9d7f8'}
  ] : [];
  const dark = document.body.classList.contains('dark');
  Plotly.newPlot('plotPV', traces, {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    xaxis:{title:'Volume (mL)', color: dark ? 'var(--dark-text)' : '#0b1b33', gridcolor: dark ? 'rgba(255,255,255,0.05)' : '#e7eefc'}, 
    yaxis:{title:'Pressure (mmHg)', color: dark ? 'var(--dark-text)' : '#0b1b33', gridcolor: dark ? 'rgba(255,255,255,0.05)' : '#e7eefc', range:[0,150]},
    showlegend:false, annotations:ann, margin:{t:30},
    font: { family: 'Inter, Arial, sans-serif', size: 14, color: dark ? 'var(--dark-text)' : '#0b1b33' }
  }, {displaylogo:false,responsive:true,modeBarButtonsToRemove:['lasso2d','select2d']});

  // Populate PV legend with key metrics for the active trace
  const act = all.find(r=>r.active) || all[0];
  if(act){
    const items = [
      {k:'Ees', v:act.Ees}, {k:'Ea', v:act.Ea}, {k:'ESP', v:act.ESP}, {k:'VAC', v:act.VAC},
      {k:'EDV', v:act.EDV}, {k:'ESV', v:act.ESV},
      {k:'Eff', v:act.Eff},
      {k:'PVA', v:act.PVA}, {k:'SW', v:act.SW}, {k:'PE', v:act.PE}, {k:'V0', v:act.V0_EDPVR},
      {k:'β', v:act.beta}, {k:'α', v:act.alpha}
    ];
    // prefer PV-specific color attached during plotting so legend swatches match the plot
  const pvCol = act._pvColor || (act.color || ((typeof hslColor === 'function')? hslColor(0) : '#1f6fff'));
  const pvFill = act._pvFillColor || (function(col){ try{ const c = col || ((typeof hslColor === 'function')? hslColor(0) : '#1f6fff'); if(c.startsWith('hsl')) return c.replace('hsl','hsla').replace(')',',0.15)'); if(c.startsWith('#')){ const cc = c.replace('#',''); const bigint = parseInt(cc.length===3? cc.split('').map(ch=>ch+ch).join('') : cc,16); const rch = (bigint>>16)&255; const gch = (bigint>>8)&255; const bch = bigint&255; return `rgba(${rch},${gch},${bch},0.15)`; } return c; }catch(e){ return 'rgba(31,111,255,0.15)'; } })(pvCol);
    byId('pvLegend').innerHTML = items.map(it=>{
      let val = it.v;
      if(it.k === 'α'){
        val = (Number.isFinite(it.v))? it.v.toExponential(2) : it.v;
      } else {
        val = Number.isFinite(it.v)? (typeof it.v==='number'? it.v.toFixed(2): it.v) : it.v;
      }
      const sw = (it.k==='Ees' || it.k==='Ea')? pvCol : (it.k==='SW' ? pvFill : '#5b82c7');
      return `<div class="legendItem"><div class="swatch" style="background:${sw};border-color:#365b9f"></div><div>${it.k}: <b>${val}</b></div></div>`;
    }).join('');
  }
}

function statusFromSeries(series){
  const vis = series.filter(r=>r.on);
  const N=vis.length; if(N<2) return 'stable';
  const delta=(arr)=>arr.at(-1)-arr[0];
  const dCI=delta(vis.map(x=>x.CI??0)), dPWP=delta(vis.map(x=>x.PCWP??0)), dL=delta(vis.map(x=> (x.Lactate !== undefined ? x.Lactate : x.Lact) ?? 0));
  if(dCI>0.2 && dPWP<-2 && dL<-0.5) return 'improve';
  if(dCI<-0.2 && dPWP>2 && dL>0.5)  return 'worse';
  return 'stable';
}

function renderKPIs(all){
  const active = (all.find(r=>r.active) || all[0]);
  if(!active){ byId('kpis').innerHTML=''; return; }

  const pill = byId('statusPill');
  const st = statusFromSeries(all);
  pill.className = `status ${st==='improve'?'improve':(st==='worse'?'worse':'stable')}`;
  pill.textContent = st==='improve'?'↑ Improving':(st==='worse'?'↓ Worsening':'● Stable');

  const fmt=(x,d=1)=> Number.isFinite(x)? x.toFixed(d) : '—';
  const ageVal = (()=>{ const n = byId('ptAge')?.value; const k = parseInt(n,10); return Number.isFinite(k) && k>0 ? k : null; })();
  const sexVal = (()=>{ const s = (byId('ptSex')?.value||'').toUpperCase(); if(s==='M' || s==='F') return s; return null; })();
  const metaBits = [
    `${active.time} h`,
    (ageVal!=null? `${ageVal} y`: null),
    (sexVal? `${sexVal}`: null),
    `BSA ${fmt(active.BSA,2)} m²`,
    `Devices ${active.devicesOn}`,
    `Drugs ${Object.values(active.doses).filter(v=>v>0).length}`,
    `Prior therapy ${active.prior_therapy?'Yes':'No'}`
  ].filter(Boolean).join(' · ');
  byId('kpis').innerHTML = `
    <div class="small" style="margin:6px 0 10px"><b>${byId('patientName').value}</b> — ${metaBits}</div>
  <div>MAP <b>${fmt(active.MAP,1)}</b> · PCWP <b>${fmt(active.PCWP,1)}</b> · RAP <b>${fmt(active.RAP,1)}</b> · Lactate <b>${fmt(active.Lactate ?? active.Lact,1)}</b> · pH <b>${fmt(active.pH,2)}</b> · ALT <b>${fmt(active.ALT,0)}</b></div>
    <div>CI <b>${fmt(active.CI,2)}</b> L/min/m² · SVI <b>${fmt(active.SVI,1)}</b> mL/m²</div>
      <div>ESP <b>${fmt(active.ESP,1)}</b> · Ea <b>${fmt(active.Ea,2)}</b> · Ees <b>${fmt(active.Ees,2)}</b> · VAC <b>${fmt(active.VAC,2)}</b></div>
      <div>CPO <b>${fmt(active.CPO,2)}</b> W · CPI <b>${fmt(active.CPI,2)}</b> W/m² · <b>CPI_adj_RAP</b> <b>${fmt(active.CPIa,2)}</b> W/m²</div>
    <div>SVR <b>${fmt(active.SVR,0)}</b> dyn·s·cm⁻⁵ · SVRI <b>${fmt(active.SVRI,0)}</b> dyn·s·cm⁻⁵·m² · PVR <b>${fmt(active.PVR_WU,2)}</b> WU · PVRI <b>${fmt(active.PVRI_WU,2)}</b> WU·m² · PAPI <b>${fmt(active.PAPI,2)}</b></div>
  `;
  byId('pillSCAI').textContent = `CSWG-SCAI: ${active.SCAI ?? '—'} (${active.SCAI_reason||'—'})`;
  renderAlarms(all);
}

// Helper: compact/clinical formatting for expressions shown in the UI
function formatExpr(s){
  try{
    if(!s) return '';
    let t = s.toString();
    // Replace common JS-like operators with clinical symbols
    t = t.replace(/>=/g,' ≥ ').replace(/<=/g,' ≤ ').replace(/!=/g,' ≠ ').replace(/!==/g,' ≠ ');
    t = t.replace(/==/g,' = ').replace(/===/g,' = ');
    // Logical operators
    t = t.replace(/&&/g,' & ').replace(/\|\|/g,' | ');
    // Normalize spacing and remove duplicate spaces
    t = t.replace(/\s+/g,' ').trim();
    // Shorten verbose words (optional): 'and'/'or' kept as &/|
    return t;
  }catch(e){ return s; }
}

function renderAlarms(all, targetId){
  const vis = all.filter(r=>r.on);
  let act = vis.find(r=>r.active) || vis[vis.length-1];
  // Determine if the currently shown timepoint is the first (basal). If so, we must not
  // show or activate any Trend/Delta-based alarms because no natural evolution exists yet.
  const activeIndexNow = (function(){
    try{
      const r = document.querySelector('input[name="activeTP"]:checked');
      if(r){ const idx = parseInt(String(r.id||'').split('_').pop()||'0', 10); if(Number.isFinite(idx)) return idx; }
    }catch(e){}
    try{ const i = vis.findIndex(v=>v && v.active); if(i>=0) return i; }catch(e){}
    return Math.max(vis.length-1, 0);
  })();
  const isFirstSelectedTP = (vis.length <= 1) || activeIndexNow === 0;
  const groups = { congestion:[], metabolic:[], perfusion:[], trends:[], mcs:[], weaning:[], other:[] };
  // Helper: map arbitrary subtitles into canonical group keys (include 'trend' mapping)
  function mapSubtitleToGroupKey(subtitle){
    if(!subtitle) return 'other';
    const s = String(subtitle).toLowerCase();
    // IMPORTANT: check MCS keywords first to avoid matching 'ci' inside words like 'specific'
    if(s.includes('mcs') || s.includes('impella') || s.includes('ecmo') || s.includes('iabp')) return 'mcs';
    // Map perfusion/power/EF without using bare 'ci' to prevent false positives
    if(s.includes('perf') || s.includes('shock') || s.includes('power') || s.includes('eject') || s === 'ef' || s.includes(' ef ') || s.includes('ef ')) return 'perfusion';
    if(s.includes('congest') || s.includes('pcwp') || s.includes('rap') || s.includes('biventric')) return 'congestion';
    if(s.includes('metab') || s.includes('lact') || s.includes('creatinine') || s.includes('ph')) return 'metabolic';
    if(s.includes('wean') || s.includes('weaning')) return 'weaning';
    if(s.includes('trend') || s.includes('trends')) return 'trends';
    return 'other';
  }
  // Build a stable mapping from original authored groups to canonical keys so Smart Alarms respects authored subtitles
  // Prefer window._ALARM_RULES_ORIGINAL (created by alarms.bundle.js before desagrupar) and fall back to window.ALARM_RULES
  (function ensureOriginalGroupMaps(){
    try{
      const originals = Array.isArray(window._ALARM_RULES_ORIGINAL) ? window._ALARM_RULES_ORIGINAL
                        : (Array.isArray(window.ALARM_RULES) ? window.ALARM_RULES : []);
      const refToGroup = new WeakMap();
      const byId = new Map();
      const byExpr = new Map();
      (originals||[]).forEach(g=>{
        if(!g || !Array.isArray(g.items)) return;
        const key = mapSubtitleToGroupKey(g.subtitle || g.title || g.group || '');
        g.items.forEach(r=>{
          try{ refToGroup.set(r, key); }catch(e){}
          const id = (r && (r.id||r.tag||r.label||'')).toString(); if(id) byId.set(id, key);
          const expr = (r && (r.expr||r.expression||r.rule||'')).toString().trim(); if(expr) byExpr.set(expr, key);
        });
      });
      window._ORIG_REF_TO_GROUP = refToGroup;
      window._RULE_GROUP_MAP = { byId, byExpr };
    }catch(e){}
  })();
  // Pre-populate groups based on loaded alarm bundles so each subtitle becomes a visible section
  try{
    // Prefer original authored groups if available
    const srcGroups = Array.isArray(window._ALARM_RULES_ORIGINAL) ? window._ALARM_RULES_ORIGINAL : window.ALARM_RULES;
    if(Array.isArray(srcGroups)){
      srcGroups.forEach(g => {
        try{ const subtitle = g.subtitle || g.title || g.group || ''; const key = mapSubtitleToGroupKey(subtitle); if(!groups[key]) groups[key] = []; }catch(e){}
      });
    }
  }catch(e){}
  // Helper: build window.signals (time-ordered numeric series per variable) from the vis array.
  // This central function is called early so Delta() can rely on a consistent signals store.
  function buildSignalsFromVis(visArray){
    try{
      const out = {};
      for(var vi=0; vi < (visArray||[]).length; vi++){
        const tp = visArray[vi] || {};
        // Track which canonical variables we've already added for this timepoint
        const addedCanon = new Set();
        Object.keys(tp).forEach(function(k){
          if(k === 'devs' || k === 'doses' || k === 't' || k === 'time' || k === 'timestamp') return;
          var v = tp[k]; if(v === undefined || v === null) return;
          // tolerant numeric parsing: accept numeric strings, percentages like '55%' and commas as decimal separators
          var num = Number(v);
          if(!Number.isFinite(num) && typeof v === 'string'){
            try{
              const cleaned = String(v).replace(/%/g,'').replace(/\s+/g,'').replace(/,/g,'.').trim();
              num = Number(cleaned);
            }catch(e){ num = NaN; }
          }
          if(!Number.isFinite(num)) return;

          // Determine base canonical key for this variable (e.g., svo2 -> SvO2)
          let base = k;
          try{
            if(typeof canonicalOfVar === 'function'){
              const canon = canonicalOfVar(k);
              if(canon) base = canon;
            }
          }catch(e){}

          // Create the base series if missing
          out[base] = out[base] || [];

          // Push only once per canonical key per timepoint to avoid duplicate adjacent samples
          if(!addedCanon.has(base)){
            const sample = { v: num };
            out[base].push(sample);
            addedCanon.add(base);
          }

          // Ensure aliases (original key, lower-case, and canonical lower-case) reference the same array
          try{
            const lower = String(k).toLowerCase();
            if(!out[k]) out[k] = out[base]; else out[k] = out[base];
            if(lower && lower !== k){ out[lower] = out[base]; }
            const baseLower = String(base).toLowerCase();
            if(baseLower && !out[baseLower]) out[baseLower] = out[base];
          }catch(e){}
        });
      }
      // Ensure common clinical variable aliases (upper/lower) share the same arrays.
      try{
        const ensureAliases = [
          "on","active","BSA","bsa","HR","hr","CO","co","CI","ci","SVI","svi",
          "SBP","sbp","DBP","dbp","MAP","map","sPAP","spap","dPAP","dpap","mPAP","mpap",
          "PCWP","pcwp","RAP","rap","Lactate","lactate","ALT","alt","pH","ph","OHCA","ohca",
          "prior_therapy","mcs_for_CS","mcs_for_cs","ESP","esp","Ea","ea","Ees","ees","VAC","vac",
          "SW","sw","PE"
        ];

        ensureAliases.forEach(k => {
          try{
            if(!k) return;
            const lower = String(k).toLowerCase();
            const upper = String(k).toUpperCase();
            // If any variant exists, point missing variants to the same array reference
            if(out[k] && !out[lower]) out[lower] = out[k];
            if(out[k] && !out[upper]) out[upper] = out[k];
            if(out[lower] && !out[k]) out[k] = out[lower];
            if(out[upper] && !out[k]) out[k] = out[upper];
            // Also try canonicalOfVar mapping if available
            if(typeof canonicalOfVar === 'function'){
              const canon = canonicalOfVar(k);
              if(canon){
                if(out[canon] && !out[k]) out[k] = out[canon];
                if(out[k] && !out[canon]) out[canon] = out[k];
                const canonLower = String(canon).toLowerCase();
                if(out[canonLower] && !out[k]) out[k] = out[canonLower];
                if(out[k] && !out[canonLower]) out[canonLower] = out[k];
              }
            }
          }catch(e){}
        });
      }catch(e){}

      window.signals = out;
    }catch(e){ /* ignore build errors */ }
  }
  // pushGroup now accepts an optional `src` (the original rule object) and `explain` so the UI can show tag/label and clause-level explain
  const pushGroup = function(group, msg, level, devices, src, explain){ devices = devices || []; groups[group] = groups[group] || []; groups[group].push({msg,level,devices,src,explain}); };
  // Debug wrapper removed: keep pushGroup unwrapped to avoid any logging side-effects
  if(!act){ byId('alarms').innerHTML = `<div class="status stable">No data</div>`; return; }

  // Normalize field names for compatibility (ensure both SvO2 and svo2 are available)
  if(act && (act.SvO2 !== undefined || act.svo2 !== undefined)){
    act = {...act}; // Make a copy to avoid modifying original
    if(act.SvO2 !== undefined && act.svo2 === undefined) act.svo2 = act.SvO2;
    if(act.svo2 !== undefined && act.SvO2 === undefined) act.SvO2 = act.svo2;
  }
  
  // CRITICAL FIX: Add comprehensive variable mapping to standard names
  if(act){
    act = {...act}; // Make a copy to avoid modifying original
    
    // STANDARD VARIABLE MAPPING - Always map to these standard names (Full Names):
    // Laboratory variables (Full names are standard)
    if(act.Lact !== undefined && act.Lactate === undefined) act.Lactate = act.Lact;
    if(act.svo2 !== undefined && act.SvO2 === undefined) act.SvO2 = act.svo2;
    
    // Medication variables (Full names are standard)
    if(act.Dobut !== undefined && act.Dobutamine === undefined) act.Dobutamine = act.Dobut;
    if(act.Dopa !== undefined && act.Dopamine === undefined) act.Dopamine = act.Dopa;  
    if(act.Norepi !== undefined && act.Norepinephrine === undefined) act.Norepinephrine = act.Norepi;
    if(act.Epi !== undefined && act.Epinephrine === undefined) act.Epinephrine = act.Epi;
    if(act.Levo !== undefined && act.Levosimendan === undefined) act.Levosimendan = act.Levo;
    
    // Also maintain backward compatibility (both directions)
    if(act.Lactate !== undefined && act.Lact === undefined) act.Lact = act.Lactate;
    if(act.SvO2 !== undefined && act.svo2 === undefined) act.svo2 = act.SvO2;
    if(act.Dobutamine !== undefined && act.Dobut === undefined) act.Dobut = act.Dobutamine;
    if(act.Dopamine !== undefined && act.Dopa === undefined) act.Dopa = act.Dopamine;
    if(act.Norepinephrine !== undefined && act.Norepi === undefined) act.Norepi = act.Norepinephrine;
    if(act.Epinephrine !== undefined && act.Epi === undefined) act.Epi = act.Epinephrine;
    if(act.Levosimendan !== undefined && act.Levo === undefined) act.Levo = act.Levosimendan;

    // Creatinine mapping (aliases observed in data)
    if(act.creatinine === undefined){
      if(act.Cr !== undefined) act.creatinine = act.Cr;
      else if(act.Creat !== undefined) act.creatinine = act.Creat;
      else if(act.creat !== undefined) act.creatinine = act.creat;
    }
    // Backward compatibility: ensure short names exist when full name is present
    if(act.creatinine !== undefined && act.Cr === undefined) act.Cr = act.creatinine;

    // EF / LVEF mapping (UI uses LVEF field but rules reference EF)
    if(act.EF === undefined){
      if(act.LVEF !== undefined) act.EF = act.LVEF;
      else if(act.ef !== undefined) act.EF = act.ef;
    }
    if(act.EF !== undefined && act.LVEF === undefined) act.LVEF = act.EF;
    // LVSWi aliasing (legacy LSVWi spelling in some rules)
    if(act.LVSWi !== undefined && act.LSVWi === undefined) act.LSVWi = act.LVSWi;
    if(act.LSVWi !== undefined && act.LVSWi === undefined) act.LVSWi = act.LSVWi;
  }
  
  // CRITICAL FIX: Add device fields from devs object to main act object
  if(act && act.devs && typeof act.devs === 'object'){
    act = {...act}; // Make a copy to avoid modifying original
    DEV_KEYS.forEach(k => {
      if(act.devs[k] !== undefined) act[k] = act.devs[k];
    });
  }
  
  // CUSTOM VARIABLES: Evaluate custom variables from Variable Builder
  if(window.CUSTOM_VARIABLES && Array.isArray(window.CUSTOM_VARIABLES)) {
    // Provide a local Delta helper so custom variable expressions can call Delta(...) safely
    // This mirrors the Delta helper used in other evaluation contexts and uses the current vis array
    function _DeltaLocal(k){ try{ const a = (vis[0]||{})[k]; const b = (vis[vis.length-1]||{})[k]; return (Number.isFinite(b) && Number.isFinite(a))? (b - a) : null; }catch(e){return null;} }

    // Evaluate custom variables using a controlled function with a 'with' context so expressions
    // can reference variable names directly and call Delta(...) without fragile string replacement.
    window.CUSTOM_VARIABLES.forEach(customVar => {
      try {
        if (act[customVar.name] === undefined) {
          // Build context object and expose Delta + Math
          const ctx = Object.assign({}, act, { Delta: _DeltaLocal, Math: Math });

          // Create a small safe wrapper function that evaluates the expression within the ctx
          // Using 'with' lets expressions reference variable names directly (e.g., CPO, CI)
          const wrapper = new Function('ctx', 'with(ctx){ try{ return (' + customVar.expression + '); }catch(e){ return undefined; } }');

          // Execute and assign result
          act[customVar.name] = wrapper(ctx);
        }
      } catch (e) {
        console.warn('Error evaluating custom variable', customVar.name, e);
        act[customVar.name] = undefined;
      }
    });
  }
  
  // CRITICAL FIX: Add dose fields from doses object to main act object
  if(act && act.doses && typeof act.doses === 'object'){
    act = {...act}; // Make a copy to avoid modifying original
    Object.keys(DOSE_KEYS).forEach(k => {
      if(act.doses[k] !== undefined) act[k] = act.doses[k];
    });
  }
  
  // CRITICAL FIX: Ensure device-specific parameters are available at top level
  const deviceParams = ['Impella_flow_Lmin', 'Impella_level', 'IABP_ratio', 'ECMO_flow_Lmin', 'ECMO_rpm'];
  deviceParams.forEach(param => {
    if(act && act[param] === undefined && vis && vis.length > 0) {
      // Look for the parameter in the raw vis data
      const lastVis = vis[vis.length - 1];
      if(lastVis && lastVis[param] !== undefined) {
        act = {...act};
        act[param] = lastVis[param];
      }
    }
  });
  
  // EMERGENCY FIX: Direct DOM reading to bypass vis mapping issues
  if(act){
    act = {...act};
    
    // Get the current active timepoint index
    const activeRadio = document.querySelector('input[name="activeTP"]:checked');
    const activeIndex = activeRadio ? activeRadio.id.split('_').pop() : '0';
    
    // Direct DOM mappings for devices
    const impellaCheckbox = document.getElementById(`t_dev_Impella_${activeIndex}`);
    if(impellaCheckbox) act.Impella = impellaCheckbox.checked;
    
    // Direct DOM mapping for Impella flow
    const impellaFlowInput = document.getElementById(`t_impella_flow_${activeIndex}`);
    if(impellaFlowInput && impellaFlowInput.value !== '') {
      const flowValue = parseFloat(impellaFlowInput.value);
      if(!isNaN(flowValue)) act.Impella_flow_Lmin = flowValue;
    }
    
    // Direct DOM mapping for SvO2
    const svo2Input = document.getElementById(`t_svo2_${activeIndex}`);
    if(svo2Input && svo2Input.value !== '') {
      const svo2Value = parseFloat(svo2Input.value);
      if(!isNaN(svo2Value)) {
        act.svo2 = svo2Value;
        act.SvO2 = svo2Value;
      }
    }
    
    // Direct DOM mapping for medications
    const dobutInput = document.getElementById(`t_dose_Dobut_${activeIndex}`);
    if(dobutInput && dobutInput.value !== '') {
      const dobutValue = parseFloat(dobutInput.value);
      if(!isNaN(dobutValue)) act.Dobut = dobutValue;
    }
    
    const dopaInput = document.getElementById(`t_dose_Dopa_${activeIndex}`);
    if(dopaInput && dopaInput.value !== '') {
      const dopaValue = parseFloat(dopaInput.value);
      if(!isNaN(dopaValue)) act.Dopa = dopaValue;
    }
    
    const milrinoneInput = document.getElementById(`t_dose_Milrinone_${activeIndex}`);
    if(milrinoneInput && milrinoneInput.value !== '') {
      const milrinoneValue = parseFloat(milrinoneInput.value);
      if(!isNaN(milrinoneValue)) act.Milrinone = milrinoneValue;
    }
    
    const norepiInput = document.getElementById(`t_dose_Norepi_${activeIndex}`);
    if(norepiInput && norepiInput.value !== '') {
      const norepiValue = parseFloat(norepiInput.value);
      if(!isNaN(norepiValue)) act.Norepi = norepiValue;
    }
  }
  
  // Also normalize the vis array for context using standard variable mapping
  vis.forEach(v => {
    if(v){
      // Apply same standard variable mapping to vis array
      // Laboratory variables
      if(v.Lactate !== undefined && v.Lact === undefined) v.Lact = v.Lactate;
      if(v.SvO2 !== undefined && v.svo2 === undefined) v.svo2 = v.SvO2;
      
      // Medication variables  
      if(v.Dobutamine !== undefined && v.Dobut === undefined) v.Dobut = v.Dobutamine;
      if(v.Dopamine !== undefined && v.Dopa === undefined) v.Dopa = v.Dopamine;  
      if(v.Norepinephrine !== undefined && v.Norepi === undefined) v.Norepi = v.Norepinephrine;
      if(v.Epinephrine !== undefined && v.Epi === undefined) v.Epi = v.Epinephrine;
      
      // Backward compatibility
      if(v.Lact !== undefined && v.Lactate === undefined) v.Lactate = v.Lact;
      if(v.svo2 !== undefined && v.SvO2 === undefined) v.SvO2 = v.svo2;
  // Stroke work aliases on each timepoint
  if(v.LVSWi !== undefined && v.LSVWi === undefined) v.LSVWi = v.LVSWi;
  if(v.LSVWi !== undefined && v.LVSWi === undefined) v.LVSWi = v.LSVWi;
    }
    // Also add device fields for vis array
    if(v && v.devs && typeof v.devs === 'object'){
      DEV_KEYS.forEach(k => {
        if(v.devs[k] !== undefined) v[k] = v.devs[k];
      });
    }
    // Map LVEF -> EF so rules referencing EF find values
    try{ if(v && v.LVEF !== undefined && v.EF === undefined) v.EF = v.LVEF; }catch(e){}
    // Also add dose fields for vis array
    if(v && v.doses && typeof v.doses === 'object'){
      Object.keys(DOSE_KEYS).forEach(k => {
        if(v.doses[k] !== undefined) v[k] = v.doses[k];
      });
    }
    // Ensure device parameters are available
    const deviceParams = ['Impella_flow_Lmin', 'Impella_level', 'IABP_ratio', 'ECMO_flow_Lmin', 'ECMO_rpm'];
    deviceParams.forEach(param => {
      if(v && v[param] === undefined) {
        // Check if it exists anywhere else in the object
        const keys = Object.keys(v);
        keys.forEach(key => {
          if(key.includes(param.split('_')[0]) && v[key] !== undefined) {
            v[param] = v[key];
          }
        });
      }
    });
  });

  // Ensure creatinine alias mapping exists on each vis entry so Delta('creatinine') works
  try{
    vis.forEach(v => {
      if(!v) return;
      // Common creatinine aliases observed in the project
      if(v.creatinine === undefined){
        if(v.Cr !== undefined) v.creatinine = v.Cr;
        else if(v.Creat !== undefined) v.creatinine = v.Creat;
        else if(v.creat !== undefined) v.creatinine = v.creat;
      }
    });
  }catch(e){}

  // If dynamic rules present, evaluate them
  if(window.ALARM_RULES){
    // Prepare context
  // Provide a canonical window.Delta implementation (safe, uses window.signals by default)
  (function(){
    // Only define once to avoid overwriting any developer overrides
    if(typeof window.Delta !== 'function'){
      // Helper: signals store time-ordered samples per variable name
      window.signals = window.signals || {};
      function getSample(name, lookback = 0){
        try{
          const tryKeys = [];
          if(typeof name === 'string'){
            tryKeys.push(name);
            // if canonicalOfVar exists, try it (maps aliases)
            if(typeof canonicalOfVar === 'function') tryKeys.push(canonicalOfVar(name));
            // lowercase fallback
            tryKeys.push(name.toLowerCase());
          } else {
            tryKeys.push(String(name));
          }
          for(let k=0;k<tryKeys.length;k++){
            const key = tryKeys[k];
            if(!key) continue;
            const arr = (window.signals && window.signals[key]) || [];
            const i = arr.length - 1 - lookback;
            if(i < 0 || !arr[i]) continue;
            const val = Number(arr[i].v ?? arr[i]);
            if(Number.isFinite(val)) return val;
          }
        }catch(e){}
        return NaN;
      }
      window.getSample = getSample;
      // Canonical Delta: return (now - previous) when both samples exist.
      // Falls back to reading window.signals arrays directly (handles objects like {v:..} or raw numbers).
      // Returns null when not enough data is available (keeps older null behavior for callers).
      window.Delta = function Delta(name, lookback = 1){
        try{
          const keyStr = String(name || '');
          // 1) fast path: try getSample for common cases
          const now = getSample(keyStr, 0);
          const prev = getSample(keyStr, lookback);
          if(Number.isFinite(now) && Number.isFinite(prev)) return now - prev;

          // 2) fallback: inspect window.signals directly and attempt canonical / lowercase keys
          const candidates = [keyStr];
          if(typeof canonicalOfVar === 'function') candidates.push(canonicalOfVar(keyStr));
          candidates.push(keyStr.toLowerCase());
          for(let k of candidates){
            if(!k) continue;
            const arr = (window.signals && window.signals[k]) || [];
            const iNow = arr.length - 1;
            const iPrev = iNow - lookback;
            if(iPrev >= 0 && arr[iNow] !== undefined && arr[iPrev] !== undefined){
              const a = Number(arr[iNow].v ?? arr[iNow]);
              const b = Number(arr[iPrev].v ?? arr[iPrev]);
              if(Number.isFinite(a) && Number.isFinite(b)) return a - b;
            }
          }

          // 3) no valid numeric pair found — return null so expression comparisons remain false-safe
          return null;
        }catch(e){ return null; }
      };
      window.DeltaPct = function DeltaPct(name, lookback = 1){
        const now = getSample(name, 0);
        const prev = getSample(name, lookback);
        if(!Number.isFinite(now) || !Number.isFinite(prev) || prev === 0) return NaN;
        return ((now - prev) / prev) * 100;
      };
      window.isRising = window.isRising || function isRising(name, n = 3){
        const arr = (window.signals && window.signals[name]) || [];
        if(arr.length < n) return false;
        for(let k=0;k<n-1;k++){
          const a = getSample(name, k+1);
          const b = getSample(name, k);
          if(!Number.isFinite(a) || !Number.isFinite(b) || b <= a) return false;
        }
        return true;
      };
      window.CountTrue = window.CountTrue || function CountTrue(list){ return Array.isArray(list)? list.filter(Boolean).length : 0; };
    }
  })();

  const win6  = computeRollingMetricsFor(vis,6);
  const win12 = computeRollingMetricsFor(vis,12);
  const win24 = computeRollingMetricsFor(vis,24);
  // Small runtime helpers exposed to compiled alarm functions (use function declarations for compatibility)
  function CountTrue(arr){ return Array.isArray(arr)? arr.filter(Boolean).length : 0; }
  // Build window.signals early from vis so Delta can be used reliably when rules evaluate
  try{
    // Diagnostic: print raw vis entries' keys and EF/LVEF values so we can see
    // whether LVEF/EF exist on the timepoint objects before signals are built.
    try{
      if(window.ALARM_DEBUG){
        try{ console.info('ALARM-DEBUG: vis raw summary (idx, keys, LVEF, EF, lvef):', vis.map((v, idx) => ({ idx, keys: Object.keys(v || {}).slice(0,200), LVEF: v && v.LVEF, EF: v && v.EF, lvef: v && v.lvef }))); }catch(e){}
        try{ console.info('ALARM-DEBUG: vis LVEF values:', vis.map(v => (v && (v.LVEF !== undefined ? v.LVEF : (v && v.lvef !== undefined ? v.lvef : null))))); }catch(e){}
      }
    }catch(e){}
    buildSignalsFromVis(vis);
  }catch(e){ /* ignore */ }

  // DEBUG: print a short summary of window.signals keys and creatinine last samples
  try{
    if(window.ALARM_DEBUG){
      const keys = Object.keys(window.signals||{}).slice(0,200);
      const creatKeys = ['creatinine','Cr','Creat','creat'].map(k=>k).filter(Boolean);
      const creatSamples = {};
      creatKeys.forEach(k=>{ try{ const arr = (window.signals&&window.signals[k])||[]; const last = arr.length? arr[arr.length-1].v ?? arr[arr.length-1] : undefined; creatSamples[k]= last; }catch(e){} });
  console.info('ALARM-DEBUG: signals keys (sample):', keys.slice(0,50));
  console.info('ALARM-DEBUG: creatinine last samples:', creatSamples);
      // Add explicit SvO2 / svo2 samples and computed Delta
      try{
        const svKeys = ['SvO2','svO2','svo2'];
        const svSamples = {};
        svKeys.forEach(k=>{ try{ const arr=(window.signals&&window.signals[k])||[]; svSamples[k] = arr.map(s=> Number(s.v ?? s)); }catch(e){ svSamples[k]=null; } });
        const d1 = (typeof window.Delta==='function')? window.Delta('svO2', 1) : null;
        const d1b = (typeof window.Delta==='function')? window.Delta('SvO2', 1) : null;
        console.info('ALARM-DEBUG: SvO2 signals & Delta:', { samples: svSamples, Delta_svo2: d1, Delta_SvO2: d1b });
      }catch(e){ console.warn('ALARM-DEBUG: SvO2 signals debug failed', e); }
    }
  }catch(e){}

  // Debug: show active snapshot EF/LVEF before evaluating rules
  try{
    if(window.ALARM_DEBUG){
      try{ console.info('ALARM-DEBUG: active snapshot EF/LVEF:', { EF: act && act.EF, LVEF: act && act.LVEF }); }catch(e){}
    }
  }catch(e){}

  // Also print EF (Ejection Fraction) samples for debugging EF Delta rules
  try{
    if(window.ALARM_DEBUG){
      const efKeys = ['EF','LVEF','ef','lvef'];
      const efSamples = {};
      efKeys.forEach(k=>{ try{ const arr = (window.signals&&window.signals[k])||[]; const last = arr.length? arr[arr.length-1].v ?? arr[arr.length-1] : undefined; efSamples[k]= last; }catch(e){} });
      console.info('ALARM-DEBUG: EF last samples:', efSamples);
    }
  }catch(e){}

  // Ensure percent-change variables exist on the active snapshot using prev vs last samples from signals
  try{
    const computePctFromSignals = (name) => {
      const arr = (window.signals && window.signals[name]) ? window.signals[name] : null;
      if(!Array.isArray(arr) || arr.length < 2) return null;
      const last = Number(arr[arr.length-1].v ?? arr[arr.length-1]);
      const prev = Number(arr[arr.length-2].v ?? arr[arr.length-2]);
      if(!Number.isFinite(last) || !Number.isFinite(prev)) return null;
      const d = last - prev;
      const pct = (d / Math.max(prev, 1e-9)) * 100;
      return pct;
    };
    const ciPct = computePctFromSignals('CI');
    const cpoPct = computePctFromSignals('CPO');
    if(ciPct !== null) act.CI_pct_change = ciPct;
    if(cpoPct !== null) act.CPO_pct_change = cpoPct;
    if(window.ALARM_DEBUG){ try{ console.info('ALARM-DEBUG: set pct-change on act', { CI_pct_change: act.CI_pct_change, CPO_pct_change: act.CPO_pct_change }); }catch(e){} }
  }catch(e){ /* non-fatal */ }

  // Local wrapper delegates to window.Delta but keeps old null behavior when NaN
  function Delta(k, lookback){
    try{
      var lb = (typeof lookback === 'number') ? lookback : 1;
      var res = (typeof window.Delta === 'function') ? window.Delta(String(k), lb) : NaN;
      return Number.isFinite(res) ? res : null;
    }catch(e){ return null; }
  }
  var failedWeans = (function(){ try{ return vis.filter(function(x){ return x && (x.failedWean || x.failed_wean || x.failed_weans); }).length || 0; }catch(e){ return 0; } })();
  var prev = vis.length>1? vis[vis.length-2] : null;
  function isRising(key){ const a = (vis[0]||{})[key]; const b = (vis[vis.length-1]||{})[key]; return Number.isFinite(a) && Number.isFinite(b) ? (b>a) : false; }
  function isDecreasing(key){ const a = (vis[0]||{})[key]; const b = (vis[vis.length-1]||{})[key]; return Number.isFinite(a) && Number.isFinite(b) ? (b<a) : false; }
  function Inotrope_combination(){ try{ var act = vis[vis.length-1]||{}; return (act.inotropesOn||0) >= 2; }catch(e){return false;} }
  function Lactate_rising(win){ return win && Number.isFinite(win.lactClearPct) ? (win.lactClearPct < 0) : false; }
  function Lactate_decreasing(win){ return win && Number.isFinite(win.lactClearPct) ? (win.lactClearPct > 0) : false; }
  const ctx = { vis:vis, first: vis[0], last: vis[vis.length-1], win6:win6, win12:win12, win24:win24, computeRollingMetricsFor:computeRollingMetricsFor, Math:Math,
          CountTrue:CountTrue, Delta:Delta, failedWeans:failedWeans, prev:prev, isRising:isRising, isDecreasing:isDecreasing, Inotrope_combination:Inotrope_combination, Lactate_rising:Lactate_rising, Lactate_decreasing:Lactate_decreasing };

    const allGroups = Array.isArray(window.ALARM_RULES)? window.ALARM_RULES.concat(window.ALARM_RULES_EXTRA||[]) : [];
    allGroups.forEach(g=>{
      const subtitle = g.subtitle || g.title || g.group || 'Misc';
      (g.items||[]).forEach(it=>{
        const fn = it._fn || compileAlarmExpr(it.expr||it.expression||it.rule||'');
        try{
          let truth = fn(act, ctx);
          // If the first/basal timepoint is selected (or there is only one timepoint),
          // suppress any Trend/Delta-driven alarms by forcing them inactive here.
          try{
            if(isFirstSelectedTP){
              const exprStr = (it && (it.expr||it.expression||it.rule||'')) + '';
              const isTrendLike = /Delta\s*\(|_pct_change|pct_change/i.test(exprStr);
              // Also treat authored Trend groups as trend-like even without explicit Delta in the expr
              const authoredSub = (g && (g.subtitle||g.title||g.group||'')) + '';
              const authoredLooksTrend = /trend/i.test(authoredSub);
              if(isTrendLike || authoredLooksTrend){ truth = false; }
            }
          }catch(e){}
          // Cache last evaluation so other UI pieces (Alarms Reference) can show the
          // same active state without re-evaluating against possibly different snapshots.
              try{
                if(it){
                  it._lastActive = !!truth;
                  // If this clone carries a direct reference to its original (added by
                  // alarms.bundle.js during desagrupar as _originalRef), update the
                  // original's _lastActive deterministically to match the evaluated clone.
                  try{
                    if(it._originalRef){
                      try{ it._originalRef._lastActive = !!truth; }catch(e){}
                    }
                    // legacy fallback: if originals snapshot exists but clones did not have
                    // _originalRef (older bundles), keep the previous best-effort propagation
                    // logic to maximize compatibility.
                    if(window._ALARM_RULES_ORIGINAL && !it._originalLastActivePropagated && !it._originalRef){
                      const findKey = (candidate) => {
                        if(!candidate) return '';
                        return (candidate.id || candidate.tag || candidate.msg || (candidate.expr||candidate.expression||candidate.rule||candidate.trigger) || '').toString();
                      };
                      const targetKey = findKey(it);
                      const searchIn = (arr) => {
                        if(!Array.isArray(arr)) return null;
                        for(const g of arr){ if(!g || !Array.isArray(g.items)) continue; for(const o of g.items){ if(findKey(o) === targetKey){ try{ o._lastActive = !!truth; }catch(e){} return o; } }
                        }
                        return null;
                      };
                      searchIn(window._ALARM_RULES_ORIGINAL);
                      it._originalLastActivePropagated = true;
                    }
                  }catch(e){}
                }
              }catch(e){}
          // Temporary debug: when evaluating creatinine-related rules, optionally log prev/last and Delta
          try{
            const isCreatRule = (it && (it.id||'').toString().toLowerCase().includes('creatin') ) || (it && it.expr && /Delta\(\"?creat/i.test(it.expr));
            if(isCreatRule && window.ALARM_DEBUG){
              try{
                // compute delta via available helper(s)
                const dd = (typeof Delta === 'function') ? (Delta('Creat') ?? Delta('creatinine') ?? Delta('Creatinine') ?? Delta('Cr')) : null;
                const prevTP = (vis.length>1) ? vis[vis.length-2] : null;
                const lastTP = (vis.length>0) ? vis[vis.length-1] : null;
                // snapshot signals for common creat keys
                const samples = {};
                ['creatinine','Creat','Cr','creat'].forEach(k=>{
                  try{ samples[k] = (window.signals && window.signals[k]) ? window.signals[k].map(s=> Number(s.v ?? s)) : null; }catch(e){ samples[k]=null; }
                });
                console.info('ALARM-DEBUG creatinine rule eval', { id: it.id, label: it.label, expr: it.expr||it.expression||it.rule, truth: !!truth, delta: dd, prev: prevTP, last: lastTP, samples });
              }catch(e){ console.warn('ALARM-DEBUG creatinine logging failed', e); }
            }
          }catch(e){}
          // EF rule debug logging (Delta and direct EF checks)
          try{
            const isEfRule = (it && (it.id||'').toString().toLowerCase().includes('ef')) || (it && it.expr && /\bEF\b/.test(it.expr)) || (it && it.expr && /Delta\(\"?EF/i.test(it.expr));
            if(isEfRule && window.ALARM_DEBUG){
              try{
                const efDelta = (typeof Delta === 'function') ? (Delta('EF') ?? Delta('LVEF') ?? Delta('ef')) : null;
                const prevTP = (vis.length>1) ? vis[vis.length-2] : null;
                const lastTP = (vis.length>0) ? vis[vis.length-1] : null;
                const samplesEf = {};
                ['EF','LVEF','ef','lvef'].forEach(k=>{ try{ samplesEf[k] = (window.signals && window.signals[k]) ? window.signals[k].map(s=> Number(s.v ?? s)) : null; }catch(e){ samplesEf[k]=null; } });
                console.info('ALARM-DEBUG EF rule eval', { id: it.id, label: it.label, expr: it.expr||it.expression||it.rule, truth: !!truth, delta: efDelta, prev: prevTP, last: lastTP, samples: samplesEf, actEF: act && act.EF });
              }catch(e){ console.warn('ALARM-DEBUG EF logging failed', e); }
            }
          }catch(e){}
          // SvO2 trend rule debug logging
          try{
            const isSvo2Trend = (it && it.id && /svo2_(rising|falling)/i.test(String(it.id))) || (it && it.expr && /Delta\(\"?svO2\"?\)/i.test(it.expr));
            if(isSvo2Trend && window.ALARM_DEBUG){
              const d = (typeof Delta==='function')? (Delta('svO2') ?? Delta('SvO2')) : null;
              const prevTP = (vis.length>1) ? vis[vis.length-2] : null;
              const lastTP = (vis.length>0) ? vis[vis.length-1] : null;
              const samples = {};
              ['SvO2','svO2','svo2'].forEach(k=>{ try{ samples[k] = (window.signals && window.signals[k]) ? window.signals[k].map(s=> Number(s.v ?? s)) : null; }catch(e){ samples[k]=null; } });
              console.info('ALARM-DEBUG SvO2 trend rule eval', { id: it.id, label: it.label, expr: it.expr||it.expression||it.rule, truth: !!truth, delta: d, prev: prevTP && (prevTP.SvO2 ?? prevTP.svo2), last: lastTP && (lastTP.SvO2 ?? lastTP.svo2), samples });
            }
          }catch(e){}
          // CPO/CI percent-change rule debug logging
          try{
            const exprText = (it && (it.expr || it.expression || it.rule)) || '';
            const isCpoPct = /\bCPO_pct_change\b/.test(String(exprText));
            const isCiPct  = /\bCI_pct_change\b/.test(String(exprText));
            if(window.ALARM_DEBUG && (isCpoPct || isCiPct)){
              const calcPct = (name) => {
                try{
                  const d = (typeof Delta==='function') ? Delta(name) : null;
                  const arr = (window.signals && window.signals[name]) ? window.signals[name] : null;
                  const last = Array.isArray(arr) && arr.length ? Number(arr[arr.length-1].v ?? arr[arr.length-1]) : null;
                  const prev = (last!==null && d!==null) ? (last - d) : null;
                  const pct = (d!==null && prev!==null) ? (d / Math.max(prev, 1e-9)) * 100 : null;
                  const samples = Array.isArray(arr) ? arr.map(s=> Number(s.v ?? s)) : null;
                  return { delta: d, last, prev, pct, samples };
                }catch(e){ return { delta:null, last:null, prev:null, pct:null, samples:null }; }
              };
              if(isCpoPct){
                const res = calcPct('CPO');
                try{ console.info('ALARM-DEBUG CPO% rule eval', { id: it.id, label: it.label, expr: exprText, truth: !!truth, pct: res.pct, delta: res.delta, prev: res.prev, last: res.last, samples: res.samples }); }catch(e){}
              }
              if(isCiPct){
                const res = calcPct('CI');
                try{ console.info('ALARM-DEBUG CI% rule eval', { id: it.id, label: it.label, expr: exprText, truth: !!truth, pct: res.pct, delta: res.delta, prev: res.prev, last: res.last, samples: res.samples }); }catch(e){}
              }
            }
          }catch(e){}
          // MASTER DEBUG: Complete Impella evaluation
          // Impella rule debug logging removed for production; keep evaluation as-is
          if(truth){
            // If the compiled function provides an explain() helper, call it and attach the details
            let explainObj = null;
            try{ if(fn && typeof fn.explain === 'function'){ explainObj = fn.explain(act, ctx); } }catch(e){ explainObj = null; }
            // map levels to our categories — accept several naming conventions used in rules files
            const _c = (it.color||'').toString().toLowerCase();
            const _l = (it.level||'').toString().toLowerCase();
            const badNames = ['red','critical','bad','danger','critical'];
            const warnNames = ['orange','warning','warn','caution'];
            const okNames = ['green','improving','wean_ok','ok','improve','good'];
            let level = 'other';
            if(badNames.includes(_c) || badNames.includes(_l)) level = 'bad';
            else if(warnNames.includes(_c) || warnNames.includes(_l)) level = 'warn';
            else if(okNames.includes(_c) || okNames.includes(_l)) level = 'ok';
              // choose a group by explicit tag or subtitle mapping
            // Determine group: prefer explicit tag/group matching engine's canonical groups,
            // otherwise infer from subtitle keywords or devices. This improves mapping of
            // bundle subtitles like 'Perfusion Rules', 'Congestion Rules', 'Weaning Rules'.
            let grp = 'other';
              // Heuristic: if the rule expression references Delta(...) or percent-change vars,
              // categorize it as a 'trends' rule so it appears in the Trend changes section.
              // Once set by this heuristic, avoid overwriting grp below (use a flag to lock grouping).
              let _grpLocked = false;
              // 0) Try to respect authored grouping: use original group if available
              try{
                if(it && it._originalRef && window._ORIG_REF_TO_GROUP instanceof WeakMap){
                  const mapped = window._ORIG_REF_TO_GROUP.get(it._originalRef);
                  if(mapped){ grp = mapped; _grpLocked = true; }
                } else if(window._RULE_GROUP_MAP){
                  const idKey = (it && (it.id||it.tag||it.label||'')).toString();
                  const exprKey = (it && (it.expr||it.expression||it.rule||'')).toString().trim();
                  if(idKey && window._RULE_GROUP_MAP.byId && window._RULE_GROUP_MAP.byId.get(idKey)){
                    grp = window._RULE_GROUP_MAP.byId.get(idKey); _grpLocked = true;
                  } else if(exprKey && window._RULE_GROUP_MAP.byExpr && window._RULE_GROUP_MAP.byExpr.get(exprKey)){
                    grp = window._RULE_GROUP_MAP.byExpr.get(exprKey); _grpLocked = true;
                  }
                }
              }catch(e){}
              try{
                const exprStr = (it && it.expr) ? String(it.expr) : '';
                const pctVarPattern = /_pct_change|pct_change|Delta\(/i;
                if(pctVarPattern.test(exprStr)){
                  grp = 'trends';
                  _grpLocked = true;
                }
              }catch(e){}
            if(!_grpLocked){
              if(it.tag && groups[it.tag]) {
                grp = it.tag;
              } else if(it.group && groups[it.group]) {
                grp = it.group;
              } else {
              const s = (subtitle||'').toString().toLowerCase();
              // Prioritize MCS to avoid 'ci' in 'specific' misclassifying the group
              if(s.includes('mcs') || s.includes('impella') || s.includes('ecmo') || s.includes('iabp')) grp = 'mcs';
              // Map ejection/EF related subtitles to perfusion (avoid bare 'ci' to prevent false positives)
              else if(s.includes('perf') || s.includes('shock') || s.includes('power') || s.includes('eject') || s === 'ef' || s.includes(' ef ') || s.includes('ef ')) grp = 'perfusion';
              else if(s.includes('congest') || s.includes('pcwp') || s.includes('rap') || s.includes('biventric')) grp = 'congestion';
              else if(s.includes('metab') || s.includes('lact') || s.includes('creatinine') || s.includes('ph')) grp = 'metabolic';
              else if(s.includes('wean') || s.includes('weaning')) grp = 'weaning';
              else if(it.devices && it.devices.length) grp = 'mcs';
              else grp = 'other';
            }
            }
            
            // Helper function to get emoji based on severity
            const getSeverityEmoji = (color) => {
              const sev = (color || '').toString().toLowerCase();
              if (sev === 'critical') return '🔴';
              if (sev === 'warning') return '⚠️';
              if (sev === 'improving') return '🟢';
              if (sev === 'wean_ok') return '🔵';
              return '⚪'; // default/unknown
            };
            
            // Build message with automatic emoji prefix based on severity
            let alarmMessage = `${it.id || ''} ${it.label || it.desc || it.name || ''}`.trim();
            const emoji = getSeverityEmoji(it.color);
            if (alarmMessage && !alarmMessage.includes('🔴') && !alarmMessage.includes('⚠️') && !alarmMessage.includes('🟢') && !alarmMessage.includes('🔵')) {
              alarmMessage = emoji + ' ' + alarmMessage;
            }
            
            // Save the original rule object as `src` so the UI can display narrative (tag/label) rather than raw expr
            // Debug: log pushes for creatinine-related rules to diagnose grouping
            try{
              const isCreatPush = (it && (it.id||'').toString().toLowerCase().includes('creatin')) || (it && it.expr && /Delta\(\"?creat/i.test(it.expr));
              if(isCreatPush){
                // Debug: ALARM-PUSH-DEBUG removed (was logging pushes to groups)
              }
            }catch(e){}
            pushGroup(grp, alarmMessage, level, it.devices||[], it, explainObj);
          }
        }catch(e){ /* ignore rule errors */ }
      });
    });

    // AUDIT: print a compact table of all evaluated rules showing group, id, label, expr and whether they were active
    try{
      if(window.ALARM_DEBUG){
        const auditRows = [];
        try{
          (window.ALARM_RULES||[]).forEach(group=>{ const subtitle = group.subtitle||group.title||group.group||'Misc'; (group.items||[]).forEach(it=>{ auditRows.push({ group: subtitle, id: it.id||it.tag||'', label: it.label||it.name||'', expr: it.expr||it.expression||it.rule||'', active: !!it._lastActive }); }); });
        }catch(e){}
        try{ console.info('ALARM-DEBUG: rules audit'); console.table(auditRows); }catch(e){}
      }
    }catch(e){}

    // Run the optional expert engine if available to produce actionable recommendations
    try{
      if(window.expertShockEngine && typeof window.expertShockEngine.evaluateAlarms === 'function'){
        try{
          const expertOpts = { minSerialHits: 2, cooldownMs: 15*60*1000, activeDevices: act };
          const expertAlerts = window.expertShockEngine.evaluateAlarms(vis, expertOpts) || [];
          // keep a copy for the Alarms Reference UI to show live expert suggestions
          window.EXPERT_ALARMS = (expertAlerts || []).map(ea => ({
            id: ea.id||ea.tag||ea.msg,
            group: ea.group,
            msg: ea.msg,
            level: ea.level,
            tag: ea.tag,
            evidence: ea.evidence,
            confidence: ea.confidence,
            actions: ea.actions || [],
            trigger: ea.rationale || ea.expr || (ea.evidence && ea.evidence.expr) || ''
          }));
          // helper to map arbitrary expert group names into the renderer's canonical groups
            const mapGroup = (g)=>{
            if(!g) return 'other';
            const s = g.toString().toLowerCase();
            // also map EF/ejection references to perfusion
            if(s.includes('perf') || s.includes('shock') || s.includes('power') || s.includes('ci') || s.includes('eject') || s === 'ef' || s.includes(' ef ') || s.includes('ef ')) return 'perfusion';
            if(s.includes('wean') || s.includes('weaning')) return 'weaning';
            if(s.includes('iabp') || s.includes('impella') || s.includes('ecmo') || s.includes('mcs')) return 'mcs';
            if(s.includes('congest') || s.includes('pcwp') || s.includes('rap') || s.includes('biventric')) return 'congestion';
            if(s.includes('lact') || s.includes('metab') || s.includes('creatinine') || s.includes('ph')) return 'metabolic';
            return 'other';
          };
          // Helper to produce a short/professional title for expert alerts
          const shortTitleFor = (ea)=>{
            try{
              const t = (ea.msg||ea.id||ea.tag||'').toString().toLowerCase();
              if(t.includes('rv') && t.includes('failure')) return 'RV Failure (Right Ventricular Failure)';
              if(t.includes('rv failure') || t.includes('right ventr')) return 'RV Failure (Right Ventricular Failure)';
              if(t.includes('ecmo')) return 'ECMO systemic perfusion adequacy';
              if(t.includes('vasopressor') || t.includes('pressor')) return 'Vasopressor inefficacy';
              if(t.includes('pvr') || t.includes('pulmonary vascular')) return 'Elevated PVR with low flow';
              if(t.includes('impella')) return 'Impella support / wean assessment';
              if(t.includes('iabp')) return 'IABP support adequacy';
              if(t.includes('wean')) return 'Weaning candidate';
              return (ea.msg||ea.id||ea.tag||'Expert alert');
            }catch(e){ return (ea.msg||ea.id||ea.tag||'Expert alert'); }
          };

          expertAlerts.forEach((ea)=>{
            // ea should have { group, msg, level, devices, evidence }
            const grp = mapGroup(ea.group || ea.tag || ea.msg);
            const level = ea.level || 'warn';
            const devices = ea.devices || [];
            // mark source as expert so UI can render a human-friendly explain text instead of raw rule details
            const shortTitle = shortTitleFor(ea);
            const src = { label: shortTitle, expert: true, id: ea.id, tag: ea.tag, evidence: ea.evidence, confidence: ea.confidence, level: ea.level, actions: ea.actions || [], trigger: ea.rationale || ea.expr || (ea.evidence && ea.evidence.expr) || '' };
            // For expert alerts we intentionally omit the raw clause explain and surface a concise Recommendation
            // push the short professional title as the displayed message and attach a small explain object for backwards compatibility
            const explainObj = { text: shortTitle, actions: src.actions || [], confidence: src.confidence || ea.confidence };
            pushGroup(grp, shortTitle, level, devices, src, explainObj);
          });
          // refresh reference so clinicians can see live expert suggestions in the Alarms Reference
          try{ if(typeof renderAlarmsReference === 'function') renderAlarmsReference(); }catch(e){}
        }catch(e){ console.warn('Expert engine evaluation failed', e); }
      }
    }catch(e){ /* ignore expert engine errors */ }

  } else {
    // No dynamic alarm rules loaded - only custom rules from Alarms Builder will appear
    // when ALARM_RULES is populated via generateAlarmsBundle()
  }

  // Render groups as collapsible panels with device badges (same rendering as before)
  const groupOrder = ['congestion','metabolic','perfusion','trends','mcs','weaning','other'];
  // DEBUG: dump group contents to console to help diagnose missing alarms in the UI
  try{ /* ALARM-GROUPS DUMP removed for cleaner console; re-enable temporarily for debugging */ }catch(e){}
  const gTitle = { congestion:'Congestion', metabolic:'Metabolic / Labs', perfusion:'Perfusion / Power', trends:'Trend changes', mcs:'MCS-specific', weaning:'Weaning candidates', other:'Other / Escalation' };
  let html = '';
  groupOrder.forEach(key=>{
    const items = groups[key] || [];
    const cnt = items.length;
    // Always render the group header so users see all Smart Alarm sections; show a placeholder when empty
  // Pass the targetId into the Toggle button so toggleAlarmGroup knows which container to operate on
  const tgt = targetId || 'alarms';
  // Unified palette now; no need to detect Clinic vs Dashboard for alarm styling
  html += `<div class="card" data-group-key="${key}" style="margin:6px 0;padding:8px">`;
  html += `<div style="display:flex;align-items:center;justify-content:space-between"><strong>${gTitle[key]} (${cnt})</strong><button class="btn" onclick="toggleAlarmGroup('${key}','${tgt}')">Toggle</button></div>`;
  // Start collapsed by default
  html += `<div style="display:none;margin-top:8px">`;
    if(items.length===0){
      html += `<div class="status stable" style="padding:8px;margin-top:8px">No active alarms in this section.</div>`;
    }
    items.forEach((it, idx)=>{
      // Use a unified palette for Clinic and Dashboard: warn -> warning (amber), ok/improving -> improve (green), bad -> worse (red)
      const cls = it.level==='bad' ? 'worse' : (it.level==='warn' ? 'warning' : (it.level==='ok' ? 'improve' : 'stable'));
  // For expert items we intentionally omit the device pills and lengthy header pills
  const devs = (it.src && it.src.expert) ? '' : ((it.devices && it.devices.length)? it.devices.map(d=>`<span class="pill" style="margin-left:6px">${d}</span>`).join('') : '');
      // Helper function to get emoji based on severity
      const getSeverityEmoji = (severity) => {
        const sev = (severity || '').toString().toLowerCase();
        if (sev === 'critical') return '🔴';
        if (sev === 'warning') return '⚠️';
        if (sev === 'improving') return '🟢';
        if (sev === 'wean_ok') return '🔵';
        return '⚪'; // default/unknown
      };
      
      // Determine a clinician-friendly narrative (prefer label/tag/desc)
      // Build a short, display-friendly narrative: prefer clinical text when available, otherwise use label
      let rawTitle = '';
      if (it.src && it.src.clinical) {
        rawTitle = it.src.clinical;
      } else if (it.src && (it.src.label || it.src.tag || it.src.desc || it.src.name)) {
        rawTitle = it.src.label || it.src.tag || it.src.desc || it.src.name;
      } else {
        // Avoid forcing a generic 'Alarm' here — prefer to try the raw message/id first and
        // fall back to a compact expression so rules without labels are still visible.
        rawTitle = it.msg || it.id || '';
      }
      // Fallback: if still empty, show the formatted expression so users can see why the rule fired
      try{
        if(!rawTitle){
          const exprTextFallback = (it.src && (it.src.expression || it.src.expr || it.src.rule || it.src.trigger)) || it.expr || it.expression || it.rule || it.trigger || '';
          rawTitle = exprTextFallback ? formatExpr(exprTextFallback) : 'Alarm';
        }
      }catch(e){ if(!rawTitle) rawTitle = 'Alarm'; }
      
      // Add severity emoji if not already present in the title
      const severityEmoji = getSeverityEmoji(it.src && it.src.color || it.color || it.level);
      if (rawTitle && !rawTitle.includes('🔴') && !rawTitle.includes('⚠️') && !rawTitle.includes('🟢') && !rawTitle.includes('🔵')) {
        rawTitle = severityEmoji + ' ' + rawTitle;
      }
      // Try to find an expression from several possible fields (rule files use different keys)
      let exprRaw = '';
      let exprText = '';
      try{
        exprRaw = (it.src && (it.src.expression || it.src.expr || it.src.rule || it.src.trigger)) || it.expr || it.expression || it.rule || it.trigger || '';
        exprRaw = exprRaw ? exprRaw.toString().trim() : '';
        exprText = exprRaw ? formatExpr(exprRaw) : '';
      }catch(e){ exprRaw = ''; exprText = ''; }
      let narrative = rawTitle;
      // If this is an expert-sourced alert, prefer a professional/concise title using heuristics
      if(it.src && it.src.expert){
        const tagStr = (it.src.tag||'').toString().toLowerCase();
        const mapTitle = () => {
          if(tagStr.includes('ecmo')) return 'ECMO systemic perfusion adequacy';
          if(tagStr.includes('vasopressor') || tagStr.includes('pressor')) return 'Vasopressor inefficacy';
          if(tagStr.includes('impella')) return 'Impella support / wean assessment';
          if(tagStr.includes('iabp')) return 'IABP support adequacy';
          if(tagStr.includes('wean')) return 'Weaning candidate / success signal';
          if(tagStr.includes('mixed') && tagStr.includes('shock')) return 'Mixed shock — vasoplegic component likely';
          return it.msg || narrative;
        };
        narrative = mapTitle();
      }

      // Build explanation / recommendation. For expert alerts show an inline Recommendation block (no Explain toggle).
      const explainId = `alarm_explain_${key}_${idx}`;
      let explainBtn = '';
      let snapshot = '';
      try{
        if(it.src && it.src.expert){
          // Expert: render a concise inline recommendation. Include a 'Why' line and Confidence when available.
          const recText = (it.explain && (it.explain.text||it.explain)) ? (it.explain.text||it.explain) : '';
          const actions = (it.src && it.src.actions) || (it.explain && it.explain.actions) || [];
          let actionsHtml = '';
          if(Array.isArray(actions) && actions.length){
            actionsHtml = `<div style="margin-top:6px"><strong>Actions:</strong><ul style="margin:6px 0 0 18px">${actions.map(a=>`<li>${escapeHtml(a)}</li>`).join('')}</ul></div>`;
          }
          // Build Why and Confidence from src when available
          let whyHtml = '';
          try{
            if(it.src && it.src.evidence && typeof it.src.evidence === 'object'){
              const parts = [];
              Object.keys(it.src.evidence).forEach(k=>{ const v = it.src.evidence[k]; if(typeof v === 'number' && Number.isFinite(v)) parts.push(`${k}=${v.toFixed(2)}`); else parts.push(`${k}=${v}`); });
              if(parts.length) whyHtml = `<div style="margin-top:6px"><strong>Why:</strong> ${escapeHtml(parts.join(' · '))}</div>`;
            }
          }catch(e){ whyHtml=''; }
          const conf = (it.src && (typeof it.src.confidence === 'number' || it.src.confidence)) ? `<div style="margin-top:6px"><strong>Confidence:</strong> ${escapeHtml((typeof it.src.confidence==='number')? Math.round(it.src.confidence)+'%': it.src.confidence)}</div>` : '';
          snapshot = `<div class="recommendation" style="margin-top:6px;padding:8px;border-left:3px solid #2563eb;background:#f8fbff;border-radius:4px"><div style="font-weight:700;margin-bottom:6px">${escapeHtml(recText||'Recommendation')}</div>${whyHtml}${conf}${actionsHtml}</div>`;
        } else {
          // No buttons needed - all info is displayed inline
          explainBtn = '';
          snapshot = '';
        }
      }catch(e){ snapshot = ''; explainBtn=''; }

      // Build inline clinical and suggest display with Why section
      let inlineInfo = '';
      if (it.src && (it.src.clinical || it.src.suggest || exprText)) {
        const parts = [];
        if (it.src.clinical) parts.push(`Clinical: ${escapeHtml(it.src.clinical)}`);
        if (it.src.suggest) parts.push(`Suggest: ${escapeHtml(it.src.suggest)}`);
        
        let infoHtml = '';
        if (parts.length > 0) {
          infoHtml += `<div style="font-size:12px;color:#666;margin-top:4px">${parts.join(' | ')}</div>`;
        }
        
        // Add Why section with formatted expression and, for CI/CPO pct-change rules, show current values
        if (exprText) {
          const formattedExpr = exprText; // already formatted above
          infoHtml += `<div style="font-size:11px;color:#888;margin-top:2px;font-family:monospace">Why: ${escapeHtml(formattedExpr)}</div>`;
          try{
            const wantsCPO = /\bCPO_pct_change\b/.test(String(exprRaw));
            const wantsCI  = /\bCI_pct_change\b/.test(String(exprRaw));
            if(wantsCPO || wantsCI){
              const computePct = (name)=>{
                try{
                  const arr = (window.signals && window.signals[name]) ? window.signals[name] : null;
                  if(!Array.isArray(arr) || arr.length < 2) return null;
                  const last = Number(arr[arr.length-1].v ?? arr[arr.length-1]);
                  const prev = Number(arr[arr.length-2].v ?? arr[arr.length-2]);
                  if(!Number.isFinite(last) || !Number.isFinite(prev)) return null;
                  const d = last - prev;
                  const pct = (d / Math.max(prev, 1e-9)) * 100;
                  return { pct, d, prev, last };
                }catch(e){ return null; }
              };
              const partsNow = [];
              if(wantsCPO){
                const r = computePct('CPO');
                if(r){ partsNow.push(`CPO% ${r.pct.toFixed(1)}% (Δ ${r.d.toFixed(2)}; ${r.prev.toFixed(2)} → ${r.last.toFixed(2)})`); }
              }
              if(wantsCI){
                const r = computePct('CI');
                if(r){ partsNow.push(`CI% ${r.pct.toFixed(1)}% (Δ ${r.d.toFixed(2)}; ${r.prev.toFixed(2)} → ${r.last.toFixed(2)})`); }
              }
              if(partsNow.length){
                infoHtml += `<div style="font-size:11px;color:#666;margin-top:2px">Now: ${escapeHtml(partsNow.join(' · '))}</div>`;
              }
            }
          }catch(e){ /* ignore pct-change UI extras */ }
        }
        
        inlineInfo = infoHtml;
      }
      
      html += `<div class="status ${cls}" style="display:flex;flex-direction:column;gap:6px;margin:6px 0;padding:6px;border-radius:6px">
        <div style="display:flex;align-items:center;gap:10px">
          <div style="flex:1">• <strong>${escapeHtml(narrative)}</strong></div>
          <div style="white-space:nowrap">${devs}</div>
        </div>
        ${inlineInfo}
        ${snapshot}
      </div>`;
    });
    html += `</div></div>`;
  });
  // Expose a flat list of the currently active alarms so other UI (like Clinic Badges) can consume it
  try{
    const flat = [];
    groupOrder.forEach(function(key){
      const items = groups[key] || [];
      items.forEach(function(it){
        const color = (it && it.src && it.src.color) || (it && it.color) || (it && it.level) || '';
        const label = (it && it.src && (it.src.label || it.src.name || it.src.tag)) || it.msg || '';
        const tag = (it && it.src && (it.src.tag || it.src.id)) || '';
        flat.push({ group:key, color: String(color).toLowerCase(), label: label, tag: tag });
      });
    });
    // Store globally; keep one per target container id to allow multiple panels
    const keyName = (targetId && String(targetId).trim()) || 'alarms';
    window._LAST_ACTIVE_ALARMS = window._LAST_ACTIVE_ALARMS || {};
    window._LAST_ACTIVE_ALARMS[keyName] = flat;
  }catch(e){ /* ignore */ }

  const alarmsEl = byId(targetId || 'alarms');
  if(alarmsEl) alarmsEl.innerHTML = html || `<div class="status stable">No active alarms.</div>`;
}

// Toggle helper used by each group's Toggle button. Keeps state per-group on the DOM.
function toggleAlarmGroup(key, containerId){
  const container = byId(containerId || 'alarms');
  if(!container) return;
  // Find card by stable data attribute inside the provided container
  const card = container.querySelector(`.card[data-group-key="${key}"]`);
  if(!card) return;
  const body = card.querySelector('div:nth-of-type(2)');
  if(!body) return;
  // Determine current collapsed state. Treat empty as collapsed (initial state).
  const isCollapsed = (body.style.display === 'none' || body.style.display === '');
  if(isCollapsed){
    // Expanding this group's body: collapse all other groups first (mutual-exclusivity)
    const otherCards = container.querySelectorAll('.card[data-group-key]');
    otherCards.forEach(c=>{
      if(c === card) return;
      const b = c.querySelector('div:nth-of-type(2)');
      if(b) b.style.display = 'none';
    });
    body.style.display = 'block';
  }else{
    // Collapse this group
    body.style.display = 'none';
  }
}

/* stage color */
function stageColor(stage){
  try{
    const M = (window.SCAI_COLORS || { A:'#10b981', B:'#1f6fff', C:'#f59e0b', D:'#ef4444', E:'#6b7280' });
    const k = (stage||'').toString().trim().toUpperCase();
    return M[k] || M.E;
  }catch(e){
    return '#6b7280';
  }
}

/* RAP vs PCWP with trajectory + legend */
function renderHemo(all){
  // Prefer module-based renderer when available
  try{
    if(window.renderers && typeof window.renderers.renderHemo === 'function'){
  try{ window.renderers.renderHemo(all, { element: 'plotHemo', legendElement: 'hemoLegend', small: true }); return; }catch(err){ console.warn('renderers.renderHemo failed, falling back to inline renderer', err); }
    }
  }catch(e){ /* ignore */ }
  
  // Check if Plotly is loaded, if not, load it asynchronously
  if (!window.Plotly) {
    window.loadPlotly().then(() => {
      renderHemo(all); // Retry once Plotly is loaded
    }).catch(error => {
      console.error('Failed to load Plotly for renderHemo:', error);
    });
    return;
  }
  
  const vis = all.filter(r=>r.on);
  if(!vis.length){ Plotly.purge('plotHemo'); byId('hemoLegend').innerHTML=''; return; }
  const BASE=40, dyn=Math.max(...vis.map(r=>Math.max(r.RAP??0,r.PCWP??0))), max=Math.max(BASE, Math.ceil(dyn/5)*5);

  const shapes=[
    {type:'rect',x0:0,x1:12,y0:0,y1:18,fillcolor:'#eaf7f0',opacity:.8,line:{width:0},layer:'below'},
    {type:'rect',x0:0,x1:12,y0:18,y1:max,fillcolor:'#eaf2fe',opacity:.8,line:{width:0},layer:'below'},
    {type:'rect',x0:12,x1:max,y0:0,y1:18,fillcolor:'#fff8ea',opacity:.8,line:{width:0},layer:'below'},
    {type:'rect',x0:12,x1:max,y0:18,y1:max,fillcolor:'#ffebee',opacity:.8,line:{width:0},layer:'below'},
    {type:'line',x0:12,x1:12,y0:0,y1:max,line:{width:2,dash:'dash',color:'#9fb6df'},layer:'below'},
    {type:'line',x0:0,x1:max,y0:18,y1:18,line:{width:2,dash:'dash',color:'#9fb6df'},layer:'below'}
  ];

  const colors = vis.map(r=>stageColor(r.SCAI||'A'));
  try{ vis.forEach((r,i)=>{ if(!r._hemoColor) r._hemoColor = colors[i]; }); }catch(e){}
  const text = vis.map(r=>`${r.time}h • SCAI ${r.SCAI} • ${r.SCAI_reason||''}`);

  const traces = [{
    x:vis.map(r=>r.RAP), y:vis.map(r=>r.PCWP), text, mode:'markers', showlegend:false,
    marker:{size:12, color:colors, line:{width:2, color:'#1b2b49'}}
  }];

  const annotations = [];
  for(let i=1;i<vis.length;i++){
    const a=vis[i-1], b=vis[i];
    const dR=(b.RAP-a.RAP), dP=(b.PCWP-a.PCWP);
    const mag=Math.sqrt(dR*dR + dP*dP);
    const col=( (b.CI??0) - (a.CI??0) )>=0 ? '#16a34a' : '#dc2626';
    annotations.push({
      x:b.RAP, y:b.PCWP, ax:a.RAP, ay:a.PCWP, xref:'x', yref:'y', axref:'x', ayref:'y',
      text:'', showarrow:true, arrowhead:3, arrowsize:1, arrowwidth:Math.min(3,1+mag/5), arrowcolor:col
    });
  }

  const darkH = document.body.classList.contains('dark');
  // adjust shapes opacity slightly for dark mode
  const shapesAdj = (darkH? shapes.map(s=> Object.assign({}, s, { opacity: Math.max(0.12, (s.opacity||1) * 0.9) })) : shapes);
  Plotly.newPlot('plotHemo', traces, {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    xaxis:{title:'RAP (mmHg)',range:[0,max], color: darkH ? 'var(--dark-text)' : '#0b1b33', gridcolor: darkH ? 'rgba(255,255,255,0.05)' : '#e7eefc'}, 
    yaxis:{title:'PCWP (mmHg)',range:[0,max], color: darkH ? 'var(--dark-text)' : '#0b1b33', gridcolor: darkH ? 'rgba(255,255,255,0.05)' : '#e7eefc'},
    shapes: shapesAdj, showlegend:false, margin:{t:30}, annotations,
    font: { family: 'Inter, Arial, sans-serif', size: 14, color: darkH ? 'var(--dark-text)' : '#0b1b33' }
  },{displaylogo:false,responsive:true});

  const __SC = (window.SCAI_COLORS || { A:'#10b981', B:'#1f6fff', C:'#f59e0b', D:'#ef4444', E:'#6b7280' });
  byId('hemoLegend').innerHTML = `
    <div class="legendItem"><span class="swatch" style="background:#eaf7f0;border-color:#a7d7b9"></span>Low RAP (≤12) & Low PCWP (≤18)</div>
    <div class="legendItem"><span class="swatch" style="background:#eaf2fe;border-color:#bcd3ff"></span>Low RAP & High PCWP</div>
    <div class="legendItem"><span class="swatch" style="background:#fff8ea;border-color:#ffdf9e"></span>High RAP & Low PCWP</div>
    <div class="legendItem"><span class="swatch" style="background:#ffebee;border-color:#ffc3c8"></span>High RAP & High PCWP</div>
    <div class="legendItem"><span class="swatch" style="background:${__SC.A}"></span>SCAI A</div>
    <div class="legendItem"><span class="swatch" style="background:${__SC.B}"></span>SCAI B</div>
    <div class="legendItem"><span class="swatch" style="background:${__SC.C}"></span>SCAI C</div>
    <div class="legendItem"><span class="swatch" style="background:${__SC.D}"></span>SCAI D</div>
    <div class="legendItem"><span class="swatch" style="background:${__SC.E}"></span>SCAI E</div>
  `;
  // Start / refresh hemo blink highlight for active timepoint (ensure prior timers/traces are cleared)
  try{
    clearHemoBlinkTimers();
    // getActiveTPIndex() returns the original timepoint index (in the full `all` array).
    // Map that original index to the visible `vis` array before using it as an index.
    try{
      const activeIdx = (typeof getActiveTPIndex === 'function') ? getActiveTPIndex() : -1;
      if(activeIdx >= 0 && Array.isArray(all) && activeIdx < all.length){
        const activePointAll = all[activeIdx];
        const vis = Array.isArray(all) ? all.filter(r=>r.on) : [];
        // prefer object identity; fall back to matching by time label if needed
        let visIndex = -1;
        try{ visIndex = vis.findIndex(v => v === activePointAll); }catch(e){}
        if(visIndex < 0 && activePointAll && activePointAll.time !== undefined){
          try{ visIndex = vis.findIndex(v => String(v.time) === String(activePointAll.time)); }catch(e){}
        }
  const hx = (activePointAll && activePointAll.RAP !== undefined && activePointAll.RAP !== null) ? Number(activePointAll.RAP) : NaN;
  const hy = (activePointAll && activePointAll.PCWP !== undefined && activePointAll.PCWP !== null) ? Number(activePointAll.PCWP) : NaN;
        if(visIndex >= 0 && Number.isFinite(hx) && Number.isFinite(hy)){
          // prefer any cached hemo color, otherwise derive from stage
          const hcol = (activePointAll && activePointAll._hemoColor) ? activePointAll._hemoColor : stageColor(activePointAll.SCAI || 'A');
          try{ startBlinkForHemo('plotHemo', hx, hy, hcol, 'hemo_main'); }catch(e){}
          try{ const blinkSettings = window.BLINK_SETTINGS || {}; if(blinkSettings.clinicMirror){ if(document.getElementById('plotHemoClinic')) startBlinkForHemo('plotHemoClinic', hx, hy, hcol, 'hemo_clinic'); } }catch(e){}
        }
      }
    }catch(e){ console.warn('hemo blink mapping failed', e); }
  }catch(e){ console.warn('hemo blink init failed', e); }
}

// Render clinician-facing Alarms Reference from window.ALARM_RULES
function renderAlarmsReference(){
  const container = byId('alarmsReferenceContainer');
  if(!container) return;
  // Insert a quick search input above the table (user-friendly fast filter)
  const searchBoxHtml = `
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <input id="alarmsRefSearch" placeholder="Quick search (group, text, tag)..." style="flex:1;padding:8px;border:1px solid #dfe8ff;border-radius:6px" />
      <button class="btn" id="alarmsRefClear">Clear</button>
    </div>`;
  const all = Array.isArray(window.ALARM_RULES)? window.ALARM_RULES.slice() : [];
  if(Array.isArray(window.ALARM_RULES_EXTRA)) all.push(...window.ALARM_RULES_EXTRA);
  // Build table header (include Active column showing whether the rule currently fires)
  let html = searchBoxHtml + `<table id="alarmsRefTable"><tr><th>Group</th><th>Narrative</th><th>Severity</th><th>Active</th><th>Tags</th><th>Explain</th></tr>`;
  // Attempt to compute current active state for rules using the UI's context (best-effort)
  let activeSnap = null; let ctx = null;
  try{
    const allSeries = (typeof collectAll === 'function') ? collectAll() : [];
    let act = (allSeries && allSeries.length) ? (allSeries.find(r=>r.active) || allSeries[allSeries.length-1]) : null;
    
    // Apply the same normalization as renderAlarms() to ensure field mapping works
    if(act){
      act = {...act}; // Make a copy to avoid modifying original
      
      // Normalize field names for compatibility (ensure both SvO2 and svo2 are available)
      if(act.SvO2 !== undefined && act.svo2 === undefined) act.svo2 = act.SvO2;
      if(act.svo2 !== undefined && act.SvO2 === undefined) act.SvO2 = act.svo2;
      
      // Add medication field mappings
      if(act.Dobutamine !== undefined && act.Dobut === undefined) act.Dobut = act.Dobutamine;
      if(act.Dopamine !== undefined && act.Dopa === undefined) act.Dopa = act.Dopamine;  
      if(act.Norepinephrine !== undefined && act.Norepi === undefined) act.Norepi = act.Norepinephrine;
      if(act.Lactate !== undefined && act.Lact === undefined) act.Lact = act.Lactate;
      
      // Add device fields from devs object to main act object
      if(act.devs && typeof act.devs === 'object'){
        DEV_KEYS.forEach(k => {
          if(act.devs[k] !== undefined) act[k] = act.devs[k];
        });
      }
      
      // Add dose fields from doses object to main act object
      if(act.doses && typeof act.doses === 'object'){
        Object.keys(DOSE_KEYS).forEach(k => {
          if(act.doses[k] !== undefined) act[k] = act.doses[k];
        });
      }
      
      // Direct DOM reading for current values (same as renderAlarms)
      // Mejor lógica para obtener el índice del timepoint activo
      let activeIndex = '0';
      const activeRadio = document.querySelector('input[name="activeTP"]:checked');
      if(activeRadio) {
        activeIndex = activeRadio.id.split('_').pop();
      } else {
        // Fallback: buscar el primer timepoint visible y activo
        const cards = Array.from(document.querySelectorAll('.tpCard'));
        for(let i=0; i<cards.length; i++) {
          const on = document.getElementById(`t_on_${i}`);
          if(on && on.checked) { activeIndex = String(i); break; }
        }
      }
      // Si sigue sin existir, usar el último timepoint visible
      if(!document.getElementById(`t_svo2_${activeIndex}`)) {
        const cards = Array.from(document.querySelectorAll('.tpCard'));
        for(let i=cards.length-1; i>=0; i--) {
          const on = document.getElementById(`t_on_${i}`);
          if(on && on.checked) { activeIndex = String(i); break; }
        }
      }
      
      // Use helper to read device/vital inputs by matching timepoint (more reliable)
      try{
        const domVals = readDeviceInputsFromDOM(act) || {};
        if(domVals.svo2 !== null && domVals.svo2 !== undefined) { act.svo2 = domVals.svo2; act.SvO2 = domVals.svo2; }
        if(domVals.lactate !== null && domVals.lactate !== undefined) { act.Lactate = domVals.lactate; act.Lact = domVals.lactate; }
        if(domVals.pH !== null && domVals.pH !== undefined) act.pH = domVals.pH;
        if(domVals.map !== null && domVals.map !== undefined) act.MAP = domVals.map;
        if(domVals.impFlowRaw !== undefined && domVals.impFlowRaw !== ''){ const v=parseFloat(domVals.impFlowRaw); if(Number.isFinite(v)) act.Impella_flow_Lmin = v; }
        if(domVals.devs) { Object.keys(domVals.devs).forEach(k=>{ act[k] = domVals.devs[k]; }); }
      }catch(e){ console.warn('readDeviceInputsFromDOM failed', e); }
        // CI (Cardiac Index)
        const ciInput = document.getElementById(`t_ci_${activeIndex}`);
        if(ciInput && ciInput.value !== '') {
          const ciValue = parseFloat(ciInput.value);
          if(!isNaN(ciValue)) act.CI = ciValue;
        }

        // Lactate
        const lactateInput = document.getElementById(`t_lac_${activeIndex}`);
        if(lactateInput && lactateInput.value !== '') {
          const lactateValue = parseFloat(lactateInput.value);
          if(!isNaN(lactateValue)) {
            act.Lactate = lactateValue;
            act.Lact = lactateValue;
          }
        }

        // pH
        const phInput = document.getElementById(`t_ph_${activeIndex}`);
        if(phInput && phInput.value !== '') {
          const phValue = parseFloat(phInput.value);
          if(!isNaN(phValue)) act.pH = phValue;
        }

        // MAP
        const mapInput = document.getElementById(`t_map_${activeIndex}`);
        if(mapInput && mapInput.value !== '') {
          const mapValue = parseFloat(mapInput.value);
          if(!isNaN(mapValue)) act.MAP = mapValue;
        }

        // Debug prints disabled by default; keep conditional hooks for future troubleshooting
    }
    
    // Provide On_<Device> flags used by some rule expressions (e.g. On_Impella)
    if(act) {
      ['IABP','Impella','ECMO','VAD'].forEach(k => {
        try{ act['On_' + k] = !!(act[k] || (act.devs && act.devs[k])); }catch(e){ act['On_' + k] = !!act[k]; }
      });
    }
    // Ensure numeric Impella flow is set from any DOM/raw field we collected
    try{
      const domVals = (typeof readDeviceInputsFromDOM === 'function') ? readDeviceInputsFromDOM(act) : null;
      if(domVals){
        if(domVals.impFlowRaw !== undefined && domVals.impFlowRaw !== null && String(domVals.impFlowRaw).trim() !== ''){
          const v = parseFloat(domVals.impFlowRaw);
          if(Number.isFinite(v)) act.Impella_flow_Lmin = v;
        }
        // Ensure SvO2 is numeric
        if(domVals.svo2 !== undefined && domVals.svo2 !== null){ const s = parseFloat(domVals.svo2); if(Number.isFinite(s)) { act.svo2 = s; act.SvO2 = s; } }
        // Also ensure map/pH/lactate numeric fallbacks
        if(domVals.map !== undefined && domVals.map !== null){ const m = parseFloat(domVals.map); if(Number.isFinite(m)) act.MAP = m; }
        if(domVals.pH !== undefined && domVals.pH !== null){ const phv = parseFloat(domVals.pH); if(Number.isFinite(phv)) act.pH = phv; }
        if(domVals.lactate !== undefined && domVals.lactate !== null){ const lv = parseFloat(domVals.lactate); if(Number.isFinite(lv)) { act.Lact = lv; act.Lactate = lv; } }
      }
    }catch(e){}
    activeSnap = act;
    // Debug logs removed: diagnostic hooks remain (window.DEBUG_ALARMS_REF) but no automatic console output
    
    // Build a small ctx similar to renderAlarms
    const vis = allSeries || [];
    const win6 = (typeof computeRollingMetricsFor === 'function') ? computeRollingMetricsFor(vis,6) : null;
    const win12 = (typeof computeRollingMetricsFor === 'function') ? computeRollingMetricsFor(vis,12) : null;
    const win24 = (typeof computeRollingMetricsFor === 'function') ? computeRollingMetricsFor(vis,24) : null;
    function CountTrue(arr){ return Array.isArray(arr)? arr.filter(Boolean).length : 0; }
    // Local wrapper delegates to canonical window.Delta implementation
    function Delta(k, lookback){
      try{
        var lb = (typeof lookback === 'number') ? lookback : 1;
        var res = (typeof window.Delta === 'function') ? window.Delta(String(k), lb) : NaN;
        if(Number.isFinite(res)) return res;
        // Fallback: compute directly from local vis if available (last - prev)
        try{
          if(typeof vis !== 'undefined' && Array.isArray(vis) && vis.length){
            var key = (typeof canonicalOfVar === 'function') ? canonicalOfVar(String(k)) : String(k);
            var prevIdx = vis.length > 1 ? vis.length - 2 : 0;
            var prior = vis[prevIdx] || {};
            var last = vis[vis.length - 1] || {};
            var a = prior[key];
            var b = last[key];
            if(!(Number.isFinite(a) && Number.isFinite(b))){
              var origA = prior[String(k)];
              var origB = last[String(k)];
              if(Number.isFinite(origA) && Number.isFinite(origB)) return origB - origA;
              var lower = String(k).toLowerCase();
              var loA = prior[lower];
              var loB = last[lower];
              if(Number.isFinite(loA) && Number.isFinite(loB)) return loB - loA;
            }
            if(Number.isFinite(b) && Number.isFinite(a)) return b - a;
          }
        }catch(e){}
        return null;
      }catch(e){ return null; }
    }
    const failedWeans = (function(){ try{ return vis.filter(function(x){ return x && (x.failedWean || x.failed_wean || x.failed_weans); }).length || 0; }catch(e){ return 0; } })();
    const prev = vis.length>1? vis[vis.length-2] : null;
    function isRising(key){ const a = (vis[0]||{})[key]; const b = (vis[vis.length-1]||{})[key]; return Number.isFinite(a) && Number.isFinite(b) ? (b>a) : false; }
    function isDecreasing(key){ const a = (vis[0]||{})[key]; const b = (vis[vis.length-1]||{})[key]; return Number.isFinite(a) && Number.isFinite(b) ? (b<a) : false; }
    function Inotrope_combination(){ try{ var act = vis[vis.length-1]||{}; return (act.inotropesOn||0) >= 2; }catch(e){return false;} }
    function Lactate_rising(win){ return win && Number.isFinite(win.lactClearPct) ? (win.lactClearPct < 0) : false; }
    function Lactate_decreasing(win){ return win && Number.isFinite(win.lactClearPct) ? (win.lactClearPct > 0) : false; }
    
    ctx = { vis:vis, first: vis[0], last: vis[vis.length-1], win6:win6, win12:win12, win24:win24, computeRollingMetricsFor:computeRollingMetricsFor, Math:Math, CountTrue:CountTrue, Delta:Delta, failedWeans:failedWeans, prev:prev, isRising:isRising, isDecreasing:isDecreasing, Inotrope_combination:Inotrope_combination, Lactate_rising:Lactate_rising, Lactate_decreasing:Lactate_decreasing };
  }catch(err){ 
    console.warn('Error building alarm evaluation context:', err);
    /* headless environment or error — leave activeSnap null */ 
  }

  if(all.length){
    // Build a flattened list so we can show everything without duplicates
    const flattened = [];
    // Custom alarm rules will be loaded from ALARM_RULES when generated by Alarms Builder
    try{
      (window.ALARM_RULES || []).forEach(g=>{ (g.items||[]).forEach(it=> flattened.push({ groupTitle: g.subtitle||g.title||g.group||'', item: it, source: 'ALARM_RULES' })); });
      (window.ALARM_RULES_EXTRA || []).forEach(g=>{ (g.items||[]).forEach(it=> flattened.push({ groupTitle: g.subtitle||g.title||g.group||'', item: it, source: 'ALARM_RULES_EXTRA' })); });
    }catch(e){}

    // Include any expert-generated suggestions (EXPERT_ALARMS) as reference rows too
    try{
      if(Array.isArray(window.EXPERT_ALARMS)){
        window.EXPERT_ALARMS.forEach(ea=> flattened.push({ groupTitle: ea.group||'Expert', item: ea, source: 'EXPERT_ALARMS' }));
      }
    }catch(e){}

    // Include expert engine action mappings (tags/devices) so clinicians can see triggers -> actions
    try{
      const mappings = window.expertShockEngine && window.expertShockEngine.actionMappings ? window.expertShockEngine.actionMappings : null;
      if(mappings){
        const byTag = mappings.byTag || {};
        Object.keys(byTag).forEach(t=> flattened.push({ groupTitle: 'Expert mapping', item: { tag: t, actions: byTag[t] }, source: 'EXPERT_MAPPING' }));
        const byDevice = mappings.byDevice || {};
        Object.keys(byDevice).forEach(d=> flattened.push({ groupTitle: 'Expert mapping', item: { device: d, actions: byDevice[d] }, source: 'EXPERT_MAPPING' }));
      }
    }catch(e){}

    if(flattened.length===0){ html += `<tr><td colspan="6"><div class="small">No alarm rules loaded.</div></td></tr>`; }

    // Deduplicate entries by logical key (prefer tag/id/msg/expression) keeping first occurrence
    const seen = new Map();
    const unique = [];
    flattened.forEach(rec => {
      const it = rec.item || {};
      const expr = (it.expression || it.expr || it.rule || it.trigger || it.expression || '').toString();
      const key = (it.tag || it.id || it.msg || expr || JSON.stringify(it)).toString();
      if(!seen.has(key)){
        seen.set(key, true);
        unique.push(rec);
      }
    });

    // Render each unique row — this guarantees all rules are shown once
    unique.forEach((rec, idx)=>{
      const gTitle = escapeHtml(rec.groupTitle||'');
      const it = rec.item || {};
      // Keep raw expression separately so we can append a compact form to labels when helpful
      const exprRaw = (it.expression || it.expr || it.rule || it.trigger || '');
      const expr = escapeHtml(exprRaw);
      const sev = escapeHtml(it.color || it.level || '');
      const tag = escapeHtml((it.tag || it.tags || it.id || '').toString());
      // Narrative: prefer human label/tag/desc; if a label exists and there's an expression,
      // append ': <expr>' so the table shows 'Title: expression' (avoids losing the rule clause)
      let narrativeRaw = it.label || it.tag || it.desc || it.name || it.id || it.msg || '';
      try{
        const exprText = exprRaw ? exprRaw.toString().trim().replace(/\s+/g,' ') : '';
        if(exprText){
          if(narrativeRaw){
            // Append expression unless it's already part of the label
            if(narrativeRaw.toString().indexOf(exprText) === -1){
              narrativeRaw = narrativeRaw + ': ' + exprText;
            }
          } else {
            narrativeRaw = exprText;
          }
        }
      }catch(e){ /* ignore formatting errors */ }
      const narrative = escapeHtml(narrativeRaw || '');
      const rowId = `ref_expr_${Math.random().toString(36).slice(2,9)}`;
      const explainBtn = `<button class="btn" onclick="(function(){const el=document.getElementById('${rowId}'); if(el) el.style.display = el.style.display==='none'?'table-row':'none';})()">Explain</button>`;
      // Evaluate whether this rule is currently active (best-effort) — only possible for compiled alarm rules
      let activeFlag = false;
      try{
        if(activeSnap && ctx){
          // Try to get or compile the function
          let fn = it._fn;
          if(!fn && (it.expr || it.expression || it.rule)){
            fn = compileAlarmExpr(it.expr || it.expression || it.rule || '');
            it._fn = fn; // Cache it
          }
          
          if(typeof fn === 'function'){
            // Prefer cached evaluation result when available (keeps Reference table
            // consistent with the live Alarms panel and console output).
            // Fast path: if this clone references an original, prefer the original's
            // cached flag when present (deterministic propagation from evaluator).
            if(it && it._originalRef && typeof it._originalRef._lastActive !== 'undefined'){
              activeFlag = !!it._originalRef._lastActive;
            } else if(it && typeof it._lastActive !== 'undefined'){
              activeFlag = !!it._lastActive;
            } else {
              // Try to locate the corresponding rule object in loaded bundles in case
              // the reference table is rendering a cloned/flattened rule object.
              try{
                const findKey = (candidate) => {
                  if(!candidate) return '';
                  return (candidate.id || candidate.tag || candidate.msg || (candidate.expr||candidate.expression||candidate.rule||candidate.trigger) || '').toString();
                };
                const targetKey = findKey(it);
                const searchIn = (arr) => {
                  if(!Array.isArray(arr)) return null;
                  for(const g of arr){ if(!g || !Array.isArray(g.items)) continue; for(const o of g.items){ if(findKey(o) === targetKey) return o; } }
                  return null;
                };
                let found = null;
                found = searchIn(window.ALARM_RULES) || searchIn(window.ALARM_RULES_EXTRA) || searchIn(window._ALARM_RULES_ORIGINAL);
                if(found && typeof found._lastActive !== 'undefined'){
                  activeFlag = !!found._lastActive;
                } else {
                  // Last resort: evaluate against the current active snapshot/context
                  activeFlag = !!fn(activeSnap, ctx);
                }
              }catch(e){
                // If anything fails, fallback to direct evaluation
                try{ activeFlag = !!fn(activeSnap, ctx); }catch(_){ activeFlag = false; }
              }
            }
          }
        }
      }catch(e){ 
        console.warn('Error evaluating rule:', it.tag || it.id, e);
        activeFlag = false; 
      }
      const activeCell = activeFlag? `<td style="color:#16a34a;font-weight:700">Yes</td>` : `<td style="color:#888">No</td>`;
      html += `<tr><td>${gTitle}</td><td style="text-align:left">${narrative}</td><td>${sev}</td>${activeCell}<td>${tag}</td><td>${explainBtn}</td></tr>`;

      // Build explain content — reuse previous logic but adapt for expert / mapping items
      let explainContent = expr || '';
      try{
        if(rec.source==='EXPERT_ALARMS'){
          // Expert suggestion: include msg, trigger, evidence, confidence and actions
          explainContent = (it.msg||it.label||it.id||'Expert recommendation') + '\n\nTrigger: ' + (it.trigger||expr||'') + '\n\nConfidence: ' + (it.confidence||'') + '%\n\nActions:\n' + ((it.actions&&it.actions.length)? it.actions.join('\n') : '-') + '\n\nEvidence:\n' + (it.evidence? JSON.stringify(it.evidence,null,2) : '');
        } else if(rec.source==='EXPERT_MAPPING'){
          explainContent = (it.tag||it.device||'Mapping') + '\n\nActions:\n' + ((it.actions&&it.actions.length)? it.actions.join('\n') : '-');
        } else {
          // alarm rule: include clause-level explain when possible
          const fn = it._fn || compileAlarmExpr(it.expr||it.expression||it.rule||'');
          const safeCtx = ctx || { vis:[], first:null, last:null, win6:null, win12:null, win24:null, CountTrue:()=>0, Delta:()=>null, failedWeans:0, prev:null, isRising:()=>false, isDecreasing:()=>false };
          if(fn && typeof fn.explain === 'function'){
            const targetR = activeSnap || {};
            const ex = fn.explain(targetR, safeCtx) || {};
            explainContent = (expr? expr + '\n\n' : '') + 'Activation criteria (clause-level):\n';
            if(Array.isArray(ex.details) && ex.details.length){
              ex.details.forEach(d=>{ const truth = d.result ? 'TRUE' : 'FALSE'; explainContent += `- ${d.clause.trim()} => ${truth}\n`; });
              explainContent += '\nNote: The rule will fire when all top-level clauses evaluate to TRUE.';
            } else if(ex.expression){ explainContent += ex.expression + '\n\n(No clause breakdown available)'; }
          }
        }
      }catch(e){ explainContent += '\n\n(Explain unavailable: '+ (e && e.message ? e.message : 'error') +')'; }

      html += `<tr id="${rowId}" style="display:none;background:#f8fbff"><td colspan="6" style="text-align:left;padding:8px;font-family:ui-monospace,monospace;white-space:pre-wrap">${escapeHtml(explainContent)}</td></tr>`;
    });
  } else {
    html += `<tr><td colspan="6"><div class="small">No alarm rules loaded.</div></td></tr>`;
  }

  // Append expert-generated suggestions (if any) as a dedicated Expert Recommendations table
  try{
  const expert = Array.isArray(window.EXPERT_ALARMS)? window.EXPERT_ALARMS : [];
    if(expert.length){
      // Header row for expert recommendations
      html += `<tr><th colspan="5" style="text-align:left;background:#eef6ff">Expert recommendations</th></tr>`;
      // Build a small header for the expert table
      html += `<tr style="background:#f7fbff"><th>Recommendation</th><th>Trigger</th><th>Confidence</th><th>Actions</th><th>Tags</th></tr>`;
      expert.forEach((ea, idx)=>{
        const rec = escapeHtml((ea.msg||ea.id||'Expert').toString());
        const trigger = escapeHtml(ea.trigger || (ea.evidence? JSON.stringify(ea.evidence): ''));
        const conf = (typeof ea.confidence === 'number')? `${Math.round(ea.confidence)}%` : (ea.confidence? `${escapeHtml(ea.confidence.toString())}` : '');
        const actions = (Array.isArray(ea.actions) && ea.actions.length) ? escapeHtml(ea.actions.join(' · ')) : '';
        const tags = escapeHtml((ea.tag||'').toString());
        html += `<tr><td style="text-align:left">${rec}</td><td style="text-align:left;font-family:ui-monospace,monospace">${trigger}</td><td>${conf}</td><td style="text-align:left">${actions}</td><td>${tags}</td></tr>`;
      });
    }
  }catch(e){ /* ignore expert render errors */ }

  // Render explicit action mappings and indicate whether each tag/device is currently active
  try{
    const mappings = window.expertShockEngine && window.expertShockEngine.actionMappings ? window.expertShockEngine.actionMappings : null;
    if(mappings){
      const byTag = mappings.byTag || {};
      const byDevice = mappings.byDevice || {};
      const tags = Object.keys(byTag || {});
      const devs = Object.keys(byDevice || {});
      if(tags.length || devs.length){
        html += `<tr><th colspan="6" style="text-align:left;background:#eef6ff">Expert action mappings (tags & devices)</th></tr>`;
        html += `<tr style="background:#f7fbff"><th>Trigger</th><th>Type</th><th>Active</th><th colspan="3">Actions</th></tr>`;
        tags.forEach(t=>{
          const acts = Array.isArray(byTag[t])? byTag[t].map(a=>escapeHtml(a)).join('<br>') : '';
          const isActive = (Array.isArray(expert) && expert.some(ea=> (ea.tag||'').toString().toLowerCase() === t.toString().toLowerCase()));
          const activeCell = isActive? `<td style="color:#16a34a;font-weight:700">Yes</td>` : `<td style="color:#888">No</td>`;
          html += `<tr><td style="text-align:left">${escapeHtml(t)}</td><td>Tag</td>${activeCell}<td colspan="3" style="text-align:left">${acts}</td></tr>`;
        });
        devs.forEach(d=>{
          const acts = Array.isArray(byDevice[d])? byDevice[d].map(a=>escapeHtml(a)).join('<br>') : '';
          // Device active if present on the active snapshot
          let isActive = false;
          try{ if(activeSnap && activeSnap.devs && activeSnap.devs[d]) isActive = true; }catch(e){}
          const activeCell = isActive? `<td style="color:#16a34a;font-weight:700">Yes</td>` : `<td style="color:#888">No</td>`;
          html += `<tr><td style="text-align:left">${escapeHtml(d)}</td><td>Device</td>${activeCell}<td colspan="3" style="text-align:left">${acts}</td></tr>`;
        });
      }
    }
  }catch(err){ /* ignore mapping render errors */ }

  // Append explicit action mappings from the embedded expert engine (tag -> actions, device -> actions)
  try{
    const mappings = window.expertShockEngine && window.expertShockEngine.actionMappings ? window.expertShockEngine.actionMappings : null;
    if(mappings){
      const byTag = mappings.byTag || {};
      const byDevice = mappings.byDevice || {};
      const tags = Object.keys(byTag || {});
      const devs = Object.keys(byDevice || {});
      if(tags.length || devs.length){
        html += `<tr><th colspan="5" style="text-align:left;background:#eef6ff">Expert action mappings (tags & devices)</th></tr>`;
        html += `<tr style="background:#f7fbff"><th>Trigger</th><th>Type</th><th colspan="3">Actions</th></tr>`;
        tags.forEach(t=>{
          const acts = Array.isArray(byTag[t])? byTag[t].map(a=>escapeHtml(a)).join('<br>') : '';
          html += `<tr><td style="text-align:left">${escapeHtml(t)}</td><td>Tag</td><td colspan="3" style="text-align:left">${acts}</td></tr>`;
        });
        devs.forEach(d=>{
          const acts = Array.isArray(byDevice[d])? byDevice[d].map(a=>escapeHtml(a)).join('<br>') : '';
          html += `<tr><td style="text-align:left">${escapeHtml(d)}</td><td>Device</td><td colspan="3" style="text-align:left">${acts}</td></tr>`;
        });
      }
    }
  }catch(err){ /* ignore mapping render errors */ }

  html += `</table>`;
  container.innerHTML = html;

  // Attach search behavior (debounced) to filter rows
  try{
    const input = byId('alarmsRefSearch'); const clearBtn = byId('alarmsRefClear');
    if(input){
      let to = null;
      const doFilter = ()=>{
        const q = (input.value||'').toString().trim().toLowerCase();
        const tbl = byId('alarmsRefTable'); if(!tbl) return;
        const rows = Array.from(tbl.querySelectorAll('tr')).slice(1); // skip header
        if(!q){ rows.forEach(r=> r.style.display=''); return; }
        rows.forEach(r=>{
          const txt = (r.textContent||'').toLowerCase();
          r.style.display = txt.indexOf(q) !== -1 ? '' : 'none';
        });
      };
      input.addEventListener('input', ()=>{ if(to) clearTimeout(to); to = setTimeout(doFilter, 180); });
      clearBtn?.addEventListener('click', ()=>{ if(input){ input.value=''; input.dispatchEvent(new Event('input')); } });
    }
  }catch(e){ console.warn('Failed to attach alarmsRef search', e); }
}

// small helper to escape HTML used in table/narrative fields
function escapeHtml(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }

// Manual refresh function for when alarm bundle is updated
function refreshAlarmsReference(){
  try{
    
    // Clear any cached compiled functions to force recompilation
    if(window.ALARM_RULES){
      window.ALARM_RULES.forEach(group=>{
        (group.items||[]).forEach(item=>{ 
          if(item._fn) delete item._fn; // Clear cached compiled function
        });
      });
    }
    if(window.ALARM_RULES_EXTRA){
      window.ALARM_RULES_EXTRA.forEach(group=>{
        (group.items||[]).forEach(item=>{ 
          if(item._fn) delete item._fn; // Clear cached compiled function
        });
      });
    }
    // Reinitialize everything
    if(typeof initAlarmEvaluators === 'function') initAlarmEvaluators();
    if(typeof renderAlarmsReference === 'function') renderAlarmsReference();
    // Refresh UI to show updated alarms
    try{ if(typeof generateAll === 'function') generateAll(); }catch(e){}
    
  }catch(e){ 
    console.error('Failed to refresh alarms reference', e); 
  }
}

// Global function to be called when alarm bundle is reloaded
window.refreshAlarmsAfterBundleUpdate = refreshAlarmsReference;

// Ensure alarm evaluators and the clinician reference are initialized when alarm rules are available
function ensureAlarmsReferenceInitialized(){
  try{
    if(window.ALARM_RULES){
      if(typeof initAlarmEvaluators === 'function') initAlarmEvaluators();
      if(typeof renderAlarmsReference === 'function') renderAlarmsReference();
      // Ensure UI reflects any new labels/explain added by the rules bundle
      try{ if(typeof generateAll === 'function') generateAll(); }catch(e){}
    } else {
      // If the rules script is not yet loaded, poll briefly until available
      let tries = 0;
      const t = setInterval(()=>{
        tries++;
        if(window.ALARM_RULES){
          clearInterval(t);
          if(typeof initAlarmEvaluators === 'function') initAlarmEvaluators();
          if(typeof renderAlarmsReference === 'function') renderAlarmsReference();
          // After evaluators are initialized, refresh the UI so updated labels/explain appear
          try{ if(typeof generateAll === 'function') generateAll(); }catch(e){}
        } else if(tries>20){
          clearInterval(t);
        }
      }, 250);
    }
  }catch(e){ console.error('Failed to init alarms reference', e); }
}

// Watch for changes to alarm rules and auto-refresh
let lastAlarmRulesHash = null;
function watchAlarmRulesChanges(){
  try{
    if(window.ALARM_RULES){
      // Create a simple hash of the alarm rules structure
      const currentHash = JSON.stringify({
        rules_count: (window.ALARM_RULES||[]).length,
        extra_count: (window.ALARM_RULES_EXTRA||[]).length,
        first_rule: (window.ALARM_RULES[0] && window.ALARM_RULES[0].items && window.ALARM_RULES[0].items[0]) ? window.ALARM_RULES[0].items[0].id : null
      });
      
      if(lastAlarmRulesHash !== null && lastAlarmRulesHash !== currentHash){
      
        refreshAlarmsReference();
      }
      lastAlarmRulesHash = currentHash;
    }
  }catch(e){ /* ignore watch errors */ }
}

// Run at end of load
window.addEventListener('load', ()=>{
  ensureAlarmsReferenceInitialized();
  
  // Set up periodic watch for alarm rules changes (every 2 seconds)
  setInterval(watchAlarmRulesChanges, 2000);
  
    // Populate the four per-slot trend dropdowns with available keys
  try{
    const varList = ['MAP','SBP','DBP','ESP','Ea','Ees','VAC','HR','CO','CI','SVI','CPO','CPI','SVR','PVR_WU','PVRI_WU','PCWP','EDV','ESV','LVIS','Lactate','PAPI','RVSWi','LVSWi','V0_EDPVR','SW','PE','PVA','Eff'];
    for(let i=0;i<4;i++){
      const s = byId(`selTrVar_${i}`);
      if(!s) continue; s.innerHTML='';
      s.appendChild(new Option('-- none --',''));
      varList.forEach(k=> s.appendChild(new Option(k,k)));
      s.addEventListener('change', ()=>{ updateTrendsOnly(); });
    }
    const cb = byId('chkTrDeltas');
    if(cb){ cb.addEventListener('change', ()=>{ updateTrendsOnly(); }); }
  }catch(e){ console.warn('Failed to populate trend vars', e); }
});

function limitSelection(sel, max){
  try{
    const opts = Array.from(sel.options);
    const chosen = opts.filter(o=>o.selected);
    if(chosen.length<=max) return true;
    // Deselect earliest chosen ones beyond the max (best-effort)
    let toClear = chosen.length - max;
    for(const o of opts){ if(o.selected && toClear>0){ o.selected = false; toClear--; } }
    return false;
  }catch(e){return false;}
}

function getSelectedTrendVars(){
  const out = [];
  for(let i=0;i<4;i++){
    const s = byId(`selTrVar_${i}`); if(!s) continue; const v = s.value; if(v) out.push(v);
  }
  return out.length? out : ['MAP','PCWP','CI','Lactate'];
}

function updateTrendsOnly(){
  try{ const all = collectAll(); window._lastSeries = all; renderTrends(all); }catch(e){ console.warn('updateTrendsOnly failed', e); }
}

// ------- Trends blinking helpers: highlight the active timepoint with a subtle blink -------
window._trendBlinkTimers = window._trendBlinkTimers || {};
function clearTrendBlinkTimers(){
  try{
    for(const k in window._trendBlinkTimers){ 
      try{ 
        const rec = window._trendBlinkTimers[k];
        if(rec){
          try{ if(rec.timer) clearInterval(rec.timer); }catch(e){}
          try{ if(rec.el && typeof Plotly !== 'undefined' && Plotly.deleteTraces && Number.isFinite(rec.idx)){
            try{ Plotly.deleteTraces(rec.el, rec.idx); }catch(e){}
          }}catch(e){}
        }
      }catch(e){}
    }
  }catch(e){}
  window._trendBlinkTimers = {};
}

function getActiveTPIndex(){
  try{
    const r = document.querySelector('input[name="activeTP"]:checked');
    if(!r) return -1;
    const m = String(r.id||'').match(/t_active_(\d+)/);
    return m ? Number(m[1]) : -1;
  }catch(e){ return -1; }
}

// Utility: attempt to find a trace index on a plotly graph div that matches a single-point marker at xVal,yVal
function _findTraceIndexForPoint(el, xVal, yVal){
  try{
    if(!el || !el.data || !Array.isArray(el.data)) return -1;
    for(let i=0;i<el.data.length;i++){
      const d = el.data[i];
      try{
        if(!d) continue;
        const xs = d.x, ys = d.y;
        if(!Array.isArray(xs) || !Array.isArray(ys)) continue;
        if(xs.length===0 || ys.length===0) continue;
        // compare numeric values (coerce strings to numbers)
        const a = Number(xs[0]); const b = Number(ys[0]);
        if(Number.isFinite(a) && Number.isFinite(b) && Number(a)===Number(xVal) && Number(b)===Number(yVal)) return i;
      }catch(e){ continue; }
    }
  }catch(e){}
  return -1;
}

// Unified blink helper: centralizes blink/pulse effect used across all plots and walker
// Make the default blink more discreet so it doesn't push Plotly layout/margins
window.BLINK_CONFIG = window.BLINK_CONFIG || { interval: 700, size: 12, pulseSize: 20, opacityOff: 0.16 };
function unifiedBlink(target, xVal, yVal, color, key, opts){
  try{
    opts = opts || {};
    const cfg = Object.assign({}, window.BLINK_CONFIG, opts);
    // resolve element
    const el = (typeof target === 'string') ? document.getElementById(target) : target;
    if(!el) return;

    // clear existing for this key
    try{ if(window._trendBlinkTimers && window._trendBlinkTimers[key]){ const rec = window._trendBlinkTimers[key]; if(rec && rec.timer) clearInterval(rec.timer); try{ if(rec.el && typeof Plotly !== 'undefined' && Plotly.deleteTraces && Number.isFinite(rec.idx)) Plotly.deleteTraces(rec.el, rec.idx); }catch(e){} } }catch(e){}

    // prefer Plotly trace overlay when possible (use a very subtle marker and avoid thick outlines)
    if(window.Plotly && typeof Plotly.addTraces === 'function'){
      const highlight = { x:[xVal], y:[yVal], mode:'markers', hoverinfo:'skip', showlegend:false,
        marker: { size: cfg.size, color: color, opacity:1, line: { width: 0, color: (document.body.classList.contains('dark')? '#0b1724' : '#ffffff') }, sizemode: 'diameter' }
      };
      Plotly.addTraces(el, highlight).then((res)=>{
        let idx = 0;
        try{ if(Array.isArray(res) && res.length && Number.isFinite(res[0])) idx = res[0]; else if(el && el.data && el.data.length) idx = el.data.length - 1; }catch(e){ idx = (el && el.data && el.data.length) ? (el.data.length - 1) : 0; }
        let on = true;
        const t = setInterval(()=>{
          on = !on;
          try{
            // attempt to keep index valid
            if(!el || !el.data || !Array.isArray(el.data) || idx >= el.data.length || idx < 0){
              const found = _findTraceIndexForPoint(el, xVal, yVal);
              if(found >= 0) idx = found; else { clearInterval(t); try{ delete window._trendBlinkTimers[key]; }catch(e){}; return; }
            }
            // toggle size + opacity to create a subtle pulse; keep deltas small to avoid layout changes
            const sizeNow = on ? cfg.size : Math.min(cfg.pulseSize, Math.round(cfg.size * 1.6));
            const op = on ? 1 : cfg.opacityOff;
            try{ Plotly.restyle(el, {'marker.size': sizeNow, 'marker.opacity': op}, [idx]); }catch(e){}
          }catch(e){ }
        }, cfg.interval);
        try{ window._trendBlinkTimers = window._trendBlinkTimers || {}; window._trendBlinkTimers[key] = { timer: t, el: el, idx: idx, x: xVal, y: yVal }; }catch(e){}
      }).catch(()=>{});
      return;
    }

    // Fallback: if no Plotly, try to pulse an element inside the plot container (non-Plotly graphs)
    try{
      const pulse = document.createElement('div');
      pulse.className = 'unified-blink-pulse';
      pulse.style.position = 'absolute';
      pulse.style.width = cfg.pulseSize + 'px';
      pulse.style.height = cfg.pulseSize + 'px';
      pulse.style.borderRadius = '50%';
      pulse.style.background = color || '#ff7f0e';
      pulse.style.opacity = '0.9';
      pulse.style.pointerEvents = 'none';
      // Positioning: place in center of the plot container as fallback
      const rect = el.getBoundingClientRect();
      pulse.style.left = (rect.width/2 - cfg.pulseSize/2) + 'px';
      pulse.style.top = (rect.height/2 - cfg.pulseSize/2) + 'px';
      el.style.position = el.style.position || 'relative';
      el.appendChild(pulse);
      let on = true;
      const t = setInterval(()=>{
        on = !on; pulse.style.transform = on ? 'scale(1)' : 'scale(1.4)'; pulse.style.opacity = on ? '1' : String(cfg.opacityOff);
      }, cfg.interval);
      try{ window._trendBlinkTimers = window._trendBlinkTimers || {}; window._trendBlinkTimers[key] = { timer: t, el: el, node: pulse }; }catch(e){}
    }catch(e){}
  }catch(e){ console.warn('unifiedBlink failed', e); }
}

function startBlinkForCell(cell, xVal, yVal, color, key){
  // delegate to unifiedBlink for consistent behaviour across app
  try{ unifiedBlink(cell || document.getElementById(cell), xVal, yVal, color, key, { size:12, pulseSize: 20, interval: 700, opacityOff: 0.16 }); }catch(e){ console.debug('startBlinkForCell delegation failed', e); }
}

// ------- Hemo plot blinking helpers: reuse Trends blinking helpers when possible -------
// Trends implementation is battle-tested (startBlinkForCell / clearTrendBlinkTimers).
// Prefer to reuse that logic to avoid duplicated/fragile code.
window._hemoBlinkTimers = window._hemoBlinkTimers || {};
function clearHemoBlinkTimers(){
  try{
    // If trends helper exists, reuse its cleanup (it clears interval timers used for blinking)
    if(typeof clearTrendBlinkTimers === 'function'){
      try{ clearTrendBlinkTimers(); return; }catch(e){}
    }
    // Fallback: clear any hemo timers we might have stored
    for(const k in window._hemoBlinkTimers){ try{ clearInterval(window._hemoBlinkTimers[k]); }catch(e){} }
  }catch(e){}
  window._hemoBlinkTimers = {};
}

function startBlinkForHemo(plotId, xVal, yVal, color, key){
  // delegate to unifiedBlink for consistent behaviour across app
  try{ const el = (typeof plotId === 'string') ? document.getElementById(plotId) : plotId; unifiedBlink(el || plotId, xVal, yVal, color, key, { size:14, pulseSize: 22, interval: 700, opacityOff: 0.16 }); }catch(e){ console.warn('startBlinkForHemo delegation failed', e); }
}

/* Trends – add LVIS */
function renderTrends(all){
  // Prefer module-based renderer when available
  try{
    if(window.renderers && typeof window.renderers.renderTrends === 'function'){
      try{ window.renderers.renderTrends(all); return; }catch(err){ console.warn('renderers.renderTrends failed, falling back to inline renderer', err); }
    }
  }catch(e){ /* ignore */ }
  
  // Check if Plotly is loaded, if not, load it asynchronously
  if (!window.Plotly) {
    window.loadPlotly().then(() => {
      renderTrends(all); // Retry once Plotly is loaded
    }).catch(error => {
      console.error('Failed to load Plotly for renderTrends:', error);
    });
    return;
  }
  
  const vis = all.filter(r=>r.on);
  if(!vis.length){ Plotly.purge('plotTr'); return; }
  const xn = vis.map((r,idx)=>{const v=parseFloat(r.time); return Number.isFinite(v)? v : idx;});
  const normalize = byId('chkNormalize').checked;
  // Determine which variables to plot (user selection)
  const selVars = getSelectedTrendVars();
  const ref = { MAP:100, PCWP:18, CI:2.2, Lactate:2, LVIS:10 };
  const colors = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'];
  const base = vis[0] || {};
  const traces = [];

  const deltaMode = !!byId('chkTrDeltas')?.checked;

  if(deltaMode){
    // Percent change vs baseline (first timepoint) — plot only percentage traces on a single Y axis
    selVars.forEach((k, idx) => {
      const series = vis.map(r => {
        const v = Number(r[k]);
        const b = Number(base[k]);
        if(!Number.isFinite(v) || !Number.isFinite(b) || b === 0) return null;
        return ((v - b) / Math.abs(b)) * 100; // percent change
      });
      traces.push({ x: xn, y: series, name: `%Δ ${k}`, mode: 'lines+markers', showlegend: true, line: { color: colors[idx % colors.length] } });
    });

    // Clear container to avoid leftover grid from panels mode
    try{ const el = byId('plotTr'); if(el) el.innerHTML = ''; }catch(e){}
    Plotly.newPlot('plotTr', traces, {
      paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
      xaxis:{title:'Time (h)', zeroline:false, color: document.body.classList.contains('dark') ? 'var(--dark-text)' : '#0b1b33', gridcolor: document.body.classList.contains('dark') ? 'rgba(255,255,255,0.05)' : '#e7eefc'}, 
      yaxis:{title: '% change', tickformat: ',.1f', color: document.body.classList.contains('dark') ? 'var(--dark-text)' : '#0b1b33', gridcolor: document.body.classList.contains('dark') ? 'rgba(255,255,255,0.05)' : '#e7eefc'},
      margin:{t:20},
      font: { family: 'Inter, Arial, sans-serif', size: 14, color: document.body.classList.contains('dark') ? 'var(--dark-text)' : '#0b1b33' }
    },{displaylogo:false,responsive:true});

    return;
  }

  // Non-delta mode: panels-only layout (2x2 independent charts)
  const getY = (arr,key)=> normalize ? arr.map(r=> (Number.isFinite(r[key])? (r[key]/(ref[key]||1)) : null)) : arr.map(r=> (Number.isFinite(r[key])? r[key] : null));

  // Panels mode: render FOUR INDEPENDENT Plotly charts arranged in a 2x2 CSS grid.
  // Each panel gets its own DIV and its own Plotly.newPlot call so axes do not interfere.
  const varsForPanels = selVars.slice(0,4);
  const container = byId('plotTr');
  if(container){
    // clear existing content, timers and build grid container
    try{ clearTrendBlinkTimers(); }catch(e){}
    container.innerHTML = '';
    const grid = document.createElement('div');
    grid.className = 'trends-grid-2x2';
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = '1fr 1fr';
    grid.style.gridGap = '18px';
    grid.style.alignItems = 'start';
    grid.style.padding = '8px 0';
    container.appendChild(grid);

    for(let i=0;i<4;i++){
      const cell = document.createElement('div');
      cell.className = 'trends-cell';
      // give space so x tick labels and titles don't overlap
      cell.style.minHeight = '260px';
      cell.style.background = 'var(--panel)';
      cell.style.borderRadius = '6px';
      cell.style.padding = '6px';
      grid.appendChild(cell);

      const k = varsForPanels[i];
      if(!k){
        // leave an empty placeholder if variable not selected
        const placeholder = document.createElement('div');
        placeholder.style.height = '100%';
        placeholder.style.display = 'flex';
        placeholder.style.alignItems = 'center';
        placeholder.style.justifyContent = 'center';
        placeholder.style.color = 'var(--muted)';
        placeholder.textContent = 'No variable selected';
        cell.appendChild(placeholder);
        continue;
      }

  // compute series explicitly so we can reference the active TP value for blinking
  const seriesY = getY(vis, k);
  const trace = { x: xn, y: seriesY, name: k, mode: 'lines+markers', showlegend: false, line: { color: colors[i % colors.length] } };
      const panelLayout = {
        paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
        margin: { t: 30, r: 18, b: 44, l: 64 },
        xaxis: { title: 'Time (h)', zeroline: false, showgrid: false, tickfont: { size: 11 }, ticks: 'outside', ticklen:6, tickpad:6, color: document.body.classList.contains('dark') ? 'var(--dark-text)' : '#0b1b33' },
        yaxis: { title: (normalize ? 'Normalized' : k), automargin: true, showgrid: true, gridcolor: document.body.classList.contains('dark') ? 'rgba(255,255,255,0.03)' : '#f0f6fb', tickfont: { size: 11 }, title_standoff: 12, color: colors[i % colors.length], nticks: 5 },
        annotations: [{ text: k, xref: 'paper', yref: 'paper', x: 0.02, y: 0.98, xanchor: 'left', yanchor: 'top', showarrow: false, font: { size: 13, color: colors[i % colors.length], family: 'Inter, Arial, sans-serif' } }],
        font: { family: 'Inter, Arial, sans-serif', size: 12, color: document.body.classList.contains('dark') ? 'var(--dark-text)' : '#0b1b33' }
      };

      try{
        const p = Plotly.newPlot(cell, [trace], panelLayout, { displaylogo:false, responsive:true });
        // Trends blinking removed: do not start per-panel blink animations here.
        // (Previously we mapped the global active index into the local `vis` array
        // and invoked startBlinkForCell; that behavior produced visual noise and
        // is intentionally disabled to keep trends static.)
      }catch(err){ console.warn('renderTrends: per-panel plot failed', err); }
    }
  }
}

/* Stage timeline (line) */
function renderStageTimeline(all){
  const wrap = byId('plotStage');
  if(!wrap) return;
  
  // Use the full sequence of timepoints (preserve order) so the walker reflects
  // all transitions in time even when some intermediate TPs are hidden (on=false).
  const vis = Array.isArray(all) ? all.slice() : [];
  if(!vis.length){ wrap.innerHTML = ''; return; }
  
  // Build SCAI Walker - horizontal badges with arrows (more compact)
  const stageColors = {
    'A': '#10b981',
    'B': '#1f6fff', 
    'C': '#f59e0b',
    'D': '#ef4444',
    'E': '#6b7280'
  };
  
  // Get unique stages in order of appearance
  const stagePoints = [];
  vis.forEach((r, idx) => {
    const stage = r.SCAI || 'C';
    const time = parseFloat(r.time);
    const timeLabel = Number.isFinite(time) ? time : idx;

    // Determine the original index of this timepoint within the full `all` array
    // so walker badges can reference the correct input ids (t_active_<origIdx>, t_on_<origIdx>).
    const origIdx = Array.isArray(all) ? all.indexOf(r) : -1;

    // Push every timepoint in sequence so the walker reflects each TP (even when
    // multiple consecutive points have the same SCAI stage). This ensures the
    // walker displays all transitions (A->B->C and intermediate steps) and lets
    // users click any underlying timepoint.
    stagePoints.push({
      stage: stage,
      time: timeLabel,
      reason: r.SCAI_reason || '',
      color: stageColors[stage] || '#6b7280',
      origIdx: origIdx,
      // mark whether this original timepoint is currently 'on' (visible) so we can
      // render it muted when it's hidden in the dashboard
      visible: (origIdx >= 0 && Array.isArray(all) ? !!(all[origIdx] && all[origIdx].on) : true)
    });
  });
  
    if(stagePoints.length === 0){
    wrap.innerHTML = '<div style="padding:8px;text-align:center;color:#94a3b8;font-size:13px">No SCAI data available</div>';
    return;
  }
  
  // Build HTML for walker badges - remove redundant caption and make time labels larger
  let html = '<div style="padding:8px 8px">';
  html += '<div style="display:flex;align-items:center;justify-content:flex-start;gap:10px;flex-wrap:wrap">';
  
  stagePoints.forEach((point, idx) => {
    // Badge circle - slightly smaller
    // If the original TP is hidden (on=false) render the badge muted so users
    // can still see the temporal transition but understand the TP is not visible
    // in other PV panels.
    const badgeOpacity = (point.visible === false) ? 0.45 : 1.0;
    const ringShadow = (point.visible === false) ? 'inset 0 0 0 2px rgba(0,0,0,0.06)' : `0 3px 8px ${point.color}40`;
    html += `
      <div class="scai-walker-badge" data-orig-idx="${point.origIdx}" style="display:flex;flex-direction:column;align-items:center;gap:4px;opacity:${badgeOpacity}">
        <div style="position:relative;width:64px;height:64px;border-radius:50%;background:${point.color};display:flex;align-items:center;justify-content:center;box-shadow:${ringShadow}">
          <span style="font-size:28px;font-weight:400;color:#fff;font-family:Inter, Arial, sans-serif">${point.stage}</span>
        </div>
        <div class="stage-time" style="font-size:14px;font-weight:600">${point.time}h</div>
      </div>
    `;
    
    // Arrow between badges (except for last one) - compact, no extra vertical margin
    if(idx < stagePoints.length - 1){
      html += `
        <div style="display:flex;align-items:center;margin:0 -2px">
          <svg width="28" height="18" viewBox="0 0 28 18" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M0 9 L22 9 M16 3 L22 9 L16 15" stroke="#cbd5e1" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
      `;
    }
  });
  
  html += '</div>';
  html += '</div>';
  
  wrap.innerHTML = html;
  // Attach click handlers to walker badges so clicking a stage selects the corresponding timepoint
  try{
    const badges = wrap.querySelectorAll('.scai-walker-badge');
    badges.forEach(b=>{
      try{
        b.style.cursor = 'pointer';
        const oi = b.getAttribute('data-orig-idx');
        const origIdx = oi ? Number(oi) : -1;
        b.addEventListener('click', ()=>{
          try{
            // Prefer the centralized setter which handles global synchronization across
            // dashboard/clinic/walker. If it's not available or global sync is disabled,
            // fall back to the previous behavior (manually toggle radios and regenerate).
            if(origIdx >= 0 && typeof setActiveIndex === 'function' && window.GLOBAL_SYNC_TIMEPOINTS !== false){
              try{
                setActiveIndex(origIdx);
                // Ensure it's visible as well
                const onChk = document.getElementById(`t_on_${origIdx}`);
                if(onChk && !onChk.checked){ onChk.checked = true; try{ onChk.dispatchEvent(new Event('change', {bubbles: true})); }catch(e){} }
                return;
              }catch(err){ console.warn('setActiveIndex failed, falling back', err); }
            }

            // Fallback: Uncheck all active radios and emit change so any listeners update
            const allRadios = Array.from(document.querySelectorAll('input[name="activeTP"]'));
            allRadios.forEach(r => { if(r.checked){ r.checked = false; try{ r.dispatchEvent(new Event('change', {bubbles: true})); }catch(e){} } });

            // Set the requested radio (if available) and emit change
            if(origIdx >= 0){
              const rd = document.getElementById(`t_active_${origIdx}`);
              if(rd){ rd.checked = true; try{ rd.dispatchEvent(new Event('change', {bubbles: true})); }catch(e){} }
            }

            // Ensure the timepoint is visible (on) and emit change
            try{
              const onChk = document.getElementById(`t_on_${origIdx}`);
              if(onChk && !onChk.checked){ onChk.checked = true; try{ onChk.dispatchEvent(new Event('change', {bubbles: true})); }catch(e){} }
            }catch(e){}

            // Trigger a full regenerate (keeps compatibility with either inline or modular renderers)
            if(typeof window.generateAll === 'function') window.generateAll();
            else if(typeof window.renderHemo === 'function' && typeof window.collectAll === 'function') window.renderHemo(window.collectAll());
          }catch(e){ console.warn('walker badge click failed', e); }
        });
      }catch(e){}
    });
  }catch(e){}
}

/* Gauges with "needle" (threshold) */
function gaugeWithNeedle(target, title, value, range, steps, fmt){
  // Ensure container exists
  const el = document.getElementById(target);
  if(!el) return;
  // Create or reuse an inner plot container so we can place a label below it
  let plotHolder = el.querySelector('.gauge-plot');
  if(!plotHolder){ plotHolder = document.createElement('div'); plotHolder.className = 'gauge-plot'; el.appendChild(plotHolder); }
  // Purge any prior plot in the holder to avoid stacking multiple SVGs
  try{ if(window.Plotly && typeof Plotly.purge === 'function'){ Plotly.purge(plotHolder); } }catch(e){}

  // Compute a sane height from the container to avoid overlap; fallback to 160
  // Reduce the visual semicircle diameter further by requesting a smaller plot height
  // than the container to leave breathing room for labels/number formatting.
  const containerH = (el.clientHeight && el.clientHeight > 60) ? el.clientHeight : 160;
  // Scale down by ~30% so the semicircle (gauge arc) is smaller and labels fit
  const h = Math.max(130, Math.round(containerH * 0.70));

  // make arc less wide so gauges are 'shorter' and numbers/ticks don't clip at edges
  const arcWidthFraction = 0.72; // 0..1 fraction of full width used by arc (smaller => narrower arc)
  const arcPad = (1 - arcWidthFraction) / 2;
  const domainX = [arcPad, 1 - arcPad];

  // pick tick font size based on holder width to avoid clipping small containers
  const tickFontSize = Math.max(8, Math.min(12, Math.round((plotHolder.clientWidth||200) / 40)));

  const data = [{
    type: 'indicator',
    mode: 'gauge+number',
    value: Number.isFinite(value) ? value : 0,
  number: { valueformat: fmt, font: { family: 'Inter, Arial, sans-serif', size: 14 } },
  // remove Plotly title and render a DOM label under the gauge so it appears below the arc
  title: { text: '', font: { family: 'Inter, Arial, sans-serif', size: 12 } },
    // Reduce the gauge domain (arc size) to make room for the number/title and avoid clipping
    gauge: {
      shape: 'angular',
  domain: { x: domainX, y: [0.12, 0.88] }, // narrower horizontal domain so arc is less long
      axis: { range, tickfont:{size: tickFontSize} },
      steps,
      bgcolor: '#fff',
      bar: { color: 'rgba(0,0,0,0)' },
      threshold: {
        value: Number.isFinite(value) ? value : 0,
        line: { color: '#0b1b33', width: 5 },
        thickness: 0.9
      }
    }
  }];

  // compute height from plotHolder to reserve space for label (28px) to avoid overlap at different zooms
  const holderH = (plotHolder.clientHeight && plotHolder.clientHeight > 80) ? plotHolder.clientHeight : containerH * 0.7;
  const reservedForLabel = 28;
  const layout = {
    margin: { t: 6, b: 6, l: 18, r: 18 },
    height: Math.max(120, Math.round(holderH - reservedForLabel)),
    paper_bgcolor: document.body.classList.contains('dark') ? 'rgba(7,20,40,0)' : 'rgba(0,0,0,0)',
    font: { family: 'Inter, Arial, sans-serif', color: document.body.classList.contains('dark') ? 'var(--dark-text)' : '#0b1b33', size: 12 }
  };

  const config = { displaylogo:false, responsive:true, displayModeBar:false };

  try{
    if(window.Plotly && typeof Plotly.newPlot === 'function'){
      Plotly.newPlot(plotHolder, data, layout, config);
      // Create or update a DOM label under the gauge container to show the title below the arc
      try{
        let lbl = el.querySelector('.gauge-label');
        if(!lbl){ lbl = document.createElement('div'); lbl.className = 'gauge-label'; el.appendChild(lbl); }
        lbl.textContent = title;
      }catch(e){ /* ignore label attach errors */ }
    }
  }catch(err){
    // graceful degrade: ignore plot errors
    console.warn('Gauge render failed for', target, err);
  }
}

function renderGauges(all){
  const active = all.find(r => r.active) || all[all.length - 1] || all[0];
  if(!active) return;
  const gauges = [
    {id:'gauge_HR',   title:'HR (bpm)',          value: active.HR,   range:[0,150], dp:0,
      steps:[{range:[0,50],color:'#dc2626'},{range:[50,60],color:'#f59e0b'},{range:[60,100],color:'#16a34a'},{range:[100,130],color:'#f59e0b'},{range:[130,150],color:'#dc2626'}]},
    {id:'gauge_MAP',  title:'MAP (mmHg)',        value: active.MAP,  range:[0,140], dp:0,
      steps:[{range:[0,65],color:'#dc2626'},{range:[65,70],color:'#f59e0b'},{range:[70,105],color:'#16a34a'},{range:[105,140],color:'#f59e0b'}]},
    {id:'gauge_CI',   title:'CI (L/min/m²)',     value: active.CI,   range:[0,5], dp:2,
      steps:[{range:[0,2.2],color:'#dc2626'},{range:[2.2,2.5],color:'#f59e0b'},{range:[2.5,4],color:'#16a34a'},{range:[4,5],color:'#f59e0b'}]},
    {id:'gauge_RAP',  title:'RAP (mmHg)',        value: active.RAP,  range:[0,20], dp:0,
      steps:[{range:[0,2],color:'#eee'},{range:[2,6],color:'#16a34a'},{range:[6,12],color:'#f59e0b'},{range:[12,20],color:'#dc2626'}]},
    {id:'gauge_PCWP', title:'PCWP (mmHg)',       value: active.PCWP, range:[0,30], dp:0,
      steps:[{range:[0,5],color:'#eee'},{range:[5,12],color:'#16a34a'},{range:[12,18],color:'#f59e0b'},{range:[18,30],color:'#dc2626'}]},
    {id:'gauge_Lactate', title:'Lactate (mmol/L)',  value: active.Lactate, range:[0,10], dp:1,
      steps:[{range:[0,2],color:'#16a34a'},{range:[2,5],color:'#f59e0b'},{range:[5,10],color:'#dc2626'}]}
  ];
  gauges.forEach(g => gaugeWithNeedle(g.id, g.title, g.value, g.range, g.steps, g.dp===0?'.0f':`.${g.dp}f`));

  // Second row gauges (ensure they use same color mapping)
  const gauges2 = [
    {id:'gauge_CPO', title:'CPO (W)', value: active.CPO, range:[0,5], dp:2, steps:[{range:[0,0.5],color:'#dc2626'},{range:[0.5,1],color:'#f59e0b'},{range:[1,3],color:'#16a34a'},{range:[3,5],color:'#f59e0b'}]},
    {id:'gauge_SVR', title:'SVR (dyn·s·cm⁻⁵)', value: active.SVR, range:[0,3000], dp:0, steps:[{range:[0,700],color:'#16a34a'},{range:[700,1200],color:'#f59e0b'},{range:[1200,3000],color:'#dc2626'}]},
    {id:'gauge_PVR', title:'PVR (WU)', value: active.PVR_WU, range:[0,6], dp:2, steps:[{range:[0,1.5],color:'#16a34a'},{range:[1.5,3],color:'#f59e0b'},{range:[3,6],color:'#dc2626'}]},
    {id:'gauge_Eff', title:'Eff (%)', value: active.Eff, range:[0,100], dp:1, steps:[{range:[0,20],color:'#dc2626'},{range:[20,40],color:'#f59e0b'},{range:[40,70],color:'#16a34a'},{range:[70,100],color:'#f59e0b'}]},
    {id:'gauge_VAC', title:'VAC', value: active.VAC, range:[0,4], dp:2, steps:[{range:[0,0.6],color:'#dc2626'},{range:[0.6,1],color:'#f59e0b'},{range:[1,2],color:'#16a34a'},{range:[2,4],color:'#f59e0b'}]},
    {id:'gauge_PAPI', title:'PAPI', value: active.PAPI, range:[0,10], dp:2, steps:[{range:[0,1],color:'#dc2626'},{range:[1,2],color:'#f59e0b'},{range:[2,6],color:'#16a34a'},{range:[6,10],color:'#f59e0b'}]}
  ];
  gauges2.forEach(g => gaugeWithNeedle(g.id, g.title, g.value, g.range, g.steps, g.dp===0?'.0f':`.${g.dp}f`));
}

/* ===== Vertical tables ===== */
function buildVerticalTable(vis, rows, getter){
  if(!vis.length) return '';
  const head = `<tr><th>Variable</th>${vis.map(r=>`<th>${r.time}</th>`).join('')}<th>Units</th></tr>`;
  const body = rows.map((row)=>{
    const vals = vis.map(r=>{
      const x = getter(r,row.key);
      if(!Number.isFinite(x)) return '';
      if(row.key === 'alpha') return x.toExponential(2);
      return (row.dp!=null)? x.toFixed(row.dp): x;
    });
    return `<tr><td>${row.name}</td>${vals.map(v=>`<td class="mono">${v}</td>`).join('')}<td>${row.units||''}</td></tr>`;
  }).join('');
  return `<thead>${head}</thead><tbody>${body}</tbody>`;
}

function renderTablesVertical(all){
  const vis = all.filter(r=>r.on);
  const g = (r,k)=> r[k];
  const rowsCO = [
    {name:'HR', key:'HR', dp:0, units:'bpm'},
    {name:'CO', key:'CO', dp:2, units:'L/min'},
    {name:'CI', key:'CI', dp:2, units:'L/min/m²'},
    {name:'SVI', key:'SVI', dp:1, units:'mL/m²'},
    {name:'CPO', key:'CPO', dp:2, units:'W'},
    {name:'CPI', key:'CPI', dp:2, units:'W/m²'},
  {name:'CPI_adj_RAP', key:'CPIa', dp:2, units:'W/m²'},
    {name:'LVIS', key:'LVIS', dp:2, units:'(unitless)'}
  ];
  byId('tblCOv').innerHTML = buildVerticalTable(vis, rowsCO, g);

  const rowsSys = [
    {name:'SBP', key:'SBP', dp:0, units:'mmHg'},
    {name:'DBP', key:'DBP', dp:0, units:'mmHg'},
    {name:'MAP', key:'MAP', dp:1, units:'mmHg'},
    {name:'ESP', key:'ESP', dp:1, units:'mmHg'},
    {name:'Ea', key:'Ea', dp:2, units:'mmHg/mL'},
    {name:'Ees', key:'Ees', dp:2, units:'mmHg/mL'},
    {name:'VAC', key:'VAC', dp:2, units:'—'},
    {name:'SVR', key:'SVR', dp:0, units:'dyn·s·cm⁻⁵'},
    {name:'SVRI', key:'SVRI', dp:0, units:'dyn·s·cm⁻⁵·m²'}
  ];
  byId('tblSysv').innerHTML = buildVerticalTable(vis, rowsSys, g);

  const rowsLV = [
    {name:'PCWP', key:'PCWP', dp:1, units:'mmHg'},
    {name:'EDV', key:'EDV', dp:1, units:'mL'},
    {name:'ESV', key:'ESV', dp:1, units:'mL'},
    {name:'LVSWi', key:'LVSWi', dp:2, units:'g·m/m²'},
    {name:'OPP', key:'OPP', dp:1, units:'mmHg'},
    {name:'CPP', key:'CPP', dp:1, units:'mmHg'},
  ];
  byId('tblLVv').innerHTML = buildVerticalTable(vis, rowsLV, g);

  const rowsRV = [
    {name:'RAP', key:'RAP', dp:1, units:'mmHg'},
    {name:'mPAP', key:'mPAP', dp:1, units:'mmHg'},
    {name:'PAPI', key:'PAPI', dp:2, units:'—'},
    {name:'PVR', key:'PVR_WU', dp:2, units:'WU'},
    {name:'PVRI', key:'PVRI_WU', dp:2, units:'WU·m²'},
    {name:'RVSWi', key:'RVSWi', dp:2, units:'g·m/m²'},
  ];
  byId('tblRVv').innerHTML = buildVerticalTable(vis, rowsRV, g);

  const rowsPV = [
    {name:'ESP', key:'ESP', dp:1, units:'mmHg'},
    {name:'Ea', key:'Ea', dp:2, units:'mmHg/mL'},
    {name:'Ees', key:'Ees', dp:2, units:'mmHg/mL'},
    {name:'VAC', key:'VAC', dp:2, units:'—'},
    {name:'SW', key:'SW', dp:0, units:'mmHg·mL'},
    {name:'PE', key:'PE', dp:0, units:'mmHg·mL'},
    {name:'PVA', key:'PVA', dp:0, units:'mmHg·mL'},
    {name:'Eff', key:'Eff', dp:1, units:'%'},
    {name:'V0', key:'V0_EDPVR', dp:1, units:'mL'},
    {name:'β', key:'beta', dp:2, units:'—'},
    {name:'α', key:'alpha', dp:null, units:'—'},
  ];
  byId('tblPVv').innerHTML = buildVerticalTable(vis, rowsPV, g);
}

/* ===== Support table ===== */
function renderSupportTable(all){
  const vis = all.filter(r=>r.on);
  if(!vis.length){ byId('tblSupport').innerHTML=''; return; }
  const head = `<tr><th>Var</th>${vis.map(r=>`<th>${r.time}</th>`).join('')}<th>Units</th></tr>`;
  const get = (r,k)=> r.doses[k]||0;
  const rows = [
    {name:'Inotropes active (count)', vals: vis.map(r=>r.inotropesOn), units:'n'},
    {name:'Vasopressors active (count)', vals: vis.map(r=>r.pressorsOn), units:'n'},
    {name:'Devices active (count)', vals: vis.map(r=>r.devicesOn), units:'n'},
    {name:'LVIS (index)', vals: vis.map(r=>Number.isFinite(r.LVIS)?r.LVIS.toFixed(2):''), units:'—'},
    {name:'Dobutamine', vals: vis.map(r=>get(r,'Dobut')), units:'µg/kg/min'},
    {name:'Dopamine', vals: vis.map(r=>get(r,'Dopa')), units:'µg/kg/min'},
    {name:'Milrinone', vals: vis.map(r=>get(r,'Milrinone')), units:'µg/kg/min'},
    {name:'Levosimendan', vals: vis.map(r=>get(r,'Levosimendan')), units:'µg/kg/min'},
    {name:'Epinephrine', vals: vis.map(r=>get(r,'Epi')), units:'µg/kg/min'},
    {name:'Norepinephrine', vals: vis.map(r=>get(r,'Norepi')), units:'µg/kg/min'},
    {name:'Vasopressin', vals: vis.map(r=>get(r,'Vasopressin')), units:'U/min'},
    {name:'Devices (IABP/Impella/ECMO/VAD)', vals: vis.map(r=>{
      const on = Object.entries(r.devs).filter(([k,v])=>v).map(([k])=>k).join('·');
      return on||'—';
    }), units:'—'}
  ];
  const body = rows.map(row=>`<tr>
      <td>${row.name}</td>
      ${row.vals.map(v=>`<td class="mono">${(typeof v==='number' && Number.isFinite(v))? v : v}</td>`).join('')}
      <td>${row.units}</td>
    </tr>`).join('');
  byId('tblSupport').innerHTML = `<thead>${head}</thead><tbody>${body}</tbody>`;
}

/* ======= Summaries (omit changes, LVIS no textual por ahora) ======= */
function clinicalBuckets(r){
  const lowCI = Number.isFinite(r.CI) && r.CI<2.2;
  const highPWP = Number.isFinite(r.PCWP) && r.PCWP>18;
  const highRAP = Number.isFinite(r.RAP) && r.RAP>12;
  const biCong = highPWP && highRAP;
  const highLac = Number.isFinite(r.Lact) && r.Lact>2;
  const acid = Number.isFinite(r.pH) && r.pH<7.30;
  return {lowCI, highPWP, highRAP, biCong, highLac, acid};
}
function _readLact(v){
  // Support different lactate property names that may exist on timepoint objects
  if(v==null) return null;
  return (v.Lactato ?? v.Lact ?? v.Lactate ?? v.lactate ?? null);
}

function lastDelta(a,b){
  const aL = _readLact(a);
  const bL = _readLact(b);
  return {
    dMAP:pct(a?.MAP,b?.MAP),
    dPCWP:pct(a?.PCWP,b?.PCWP),
    dCI:pct(a?.CI,b?.CI),
    dLac: (aL==null || bL==null) ? null : pct(aL,bL)
  };
}
const fmt=(x,d=1)=> Number.isFinite(x)? x.toFixed(d):'—';
function arrowPct(v){ return v==null?'' : (v>=0?`↑${Math.abs(v).toFixed(0)}%`:`↓${Math.abs(v).toFixed(0)}%`); }
function supportCount(r){ return r.devicesOn + Object.values(r.doses).filter(v=>v>0).length; }

// Helper: attempt to locate the timepoint index for a given pt and read device inputs directly from the DOM
function readDeviceInputsFromDOM(pt){
  try{
    const cards = document.querySelectorAll('.tpCard');
    for(let i=0;i<cards.length;i++){
      const tval = byId(`t_time_${i}`)?.value;
      if(tval == null) continue;
      // match by time: try numeric comparison first, then trimmed string equality
      let matched = false;
      const aNum = parseFloat(tval);
      const bNum = (pt && pt.time!==undefined && pt.time!==null) ? parseFloat(String(pt.time)) : NaN;
      if(Number.isFinite(aNum) && Number.isFinite(bNum) && Math.abs(aNum - bNum) < 1e-6) matched = true;
      if(!matched){ if(String(tval).trim() === String(pt.time).trim()) matched = true; }
      // match by devices count as second-level filter if needed
      if(!matched){ /* continue to next card */ }
      if(matched){
        // Read common vitals/inputs too (SvO2, lactate, pH, MAP)
        const sbp = parseFloat(byId(`t_sbp_${i}`)?.value);
        const dbp = parseFloat(byId(`t_dbp_${i}`)?.value);
        const map = (Number.isFinite(sbp) && Number.isFinite(dbp)) ? (dbp + (sbp - dbp) / 3) : null;
        const lac = parseFloat(byId(`t_lac_${i}`)?.value);
        const ph = parseFloat(byId(`t_ph_${i}`)?.value);
        const svo2Raw = byId(`t_svo2_${i}`)?.value;
        const svo2 = (svo2Raw!==undefined && svo2Raw!==null && String(svo2Raw).trim()!=='') ? parseFloat(svo2Raw) : null;
        return {
          impLevel: byId(`t_impella_level_${i}`)? byId(`t_impella_level_${i}`).value : '',
          impFlowRaw: byId(`t_impella_flow_${i}`)? byId(`t_impella_flow_${i}`).value : '',
          ecmoFlowRaw: byId(`t_ecmo_flow_${i}`)? byId(`t_ecmo_flow_${i}`).value : '',
          ecmoRpmRaw: byId(`t_ecmo_rpm_${i}`)? byId(`t_ecmo_rpm_${i}`).value : '',
          iabpRatio: byId(`t_iabp_ratio_${i}`)? byId(`t_iabp_ratio_${i}`).value : '',
          devs: {
            Impella: !!byId(`t_dev_Impella_${i}`)?.checked,
            ECMO: !!byId(`t_dev_ECMO_${i}`)?.checked,
            IABP: !!byId(`t_dev_IABP_${i}`)?.checked,
            VAD: !!byId(`t_dev_VAD_${i}`)?.checked
          },
          sbp: Number.isFinite(sbp)? sbp : null,
          dbp: Number.isFinite(dbp)? dbp : null,
          map: Number.isFinite(map)? map : null,
          lactate: Number.isFinite(lac)? lac : null,
          pH: Number.isFinite(ph)? ph : null,
          svo2: Number.isFinite(svo2)? svo2 : null
        };
      }
    }
    // Fallbacks: 1) find card with radio active checked, 2) find first card with on checked, 3) find first card with visible SvO2 value
    let fallbackIdx = -1;
    for(let i=0;i<cards.length;i++){ const rd = cards[i].querySelector('input[type="radio"][name="activeTP"]'); if(rd && rd.checked){ fallbackIdx = i; break; } }
    if(fallbackIdx<0){ for(let i=0;i<cards.length;i++){ const on = byId(`t_on_${i}`); if(on && on.checked){ fallbackIdx = i; break; } } }
    if(fallbackIdx<0){ for(let i=0;i<cards.length;i++){ const s = byId(`t_svo2_${i}`); if(s && s.value && String(s.value).trim()!==''){ fallbackIdx = i; break; } } }
    if(fallbackIdx>=0){
      const i = fallbackIdx;
      const sbp = parseFloat(byId(`t_sbp_${i}`)?.value);
      const dbp = parseFloat(byId(`t_dbp_${i}`)?.value);
      const map = (Number.isFinite(sbp) && Number.isFinite(dbp)) ? (dbp + (sbp - dbp) / 3) : null;
      const lac = parseFloat(byId(`t_lac_${i}`)?.value);
      const ph = parseFloat(byId(`t_ph_${i}`)?.value);
      const svo2Raw = byId(`t_svo2_${i}`)?.value;
      const svo2 = (svo2Raw!==undefined && svo2Raw!==null && String(svo2Raw).trim()!=='') ? parseFloat(svo2Raw) : null;
      return {
        impLevel: byId(`t_impella_level_${i}`)? byId(`t_impella_level_${i}`).value : '',
        impFlowRaw: byId(`t_impella_flow_${i}`)? byId(`t_impella_flow_${i}`).value : '',
        ecmoFlowRaw: byId(`t_ecmo_flow_${i}`)? byId(`t_ecmo_flow_${i}`).value : '',
        ecmoRpmRaw: byId(`t_ecmo_rpm_${i}`)? byId(`t_ecmo_rpm_${i}`).value : '',
        iabpRatio: byId(`t_iabp_ratio_${i}`)? byId(`t_iabp_ratio_${i}`).value : '',
        devs: {
          Impella: !!byId(`t_dev_Impella_${i}`)?.checked,
          ECMO: !!byId(`t_dev_ECMO_${i}`)?.checked,
          IABP: !!byId(`t_dev_IABP_${i}`)?.checked,
          VAD: !!byId(`t_dev_VAD_${i}`)?.checked
        },
        sbp: Number.isFinite(sbp)? sbp : null,
        dbp: Number.isFinite(dbp)? dbp : null,
        map: Number.isFinite(map)? map : null,
        lactate: Number.isFinite(lac)? lac : null,
        pH: Number.isFinite(ph)? ph : null,
        svo2: Number.isFinite(svo2)? svo2 : null
      };
    }
  }catch(e){ /* ignore */ }
  return null;
}

function buildLineES(pt, prev){
  const T = `${pt.time}h`;
  const a = clinicalBuckets(pt);
  const d = prev? lastDelta(prev,pt): {};
  const trend = prev? ` Tendencia: ΔPAM ${arrowPct(d.dMAP)}; ΔPCWP ${arrowPct(d.dPCWP)}; ΔIC ${arrowPct(d.dCI)}; ΔLact ${arrowPct(d.dLac ?? pt?.delta_lactate)}.` : '';
  const sup = `dispositivos ${pt.devicesOn} / fármacos ${Object.values(pt.doses).filter(v=>v>0).length} (total ${supportCount(pt)})`;
  // PV / perfusion / support extra fields
  const bsa = (pt.BSA ?? pt.bsa ?? null);
  const svo2 = (pt.svo2 ?? pt.SvO2 ?? pt.SVO2 ?? null);
  const lvis = (pt.LVIS ?? pt.VIS ?? pt.VIScurrent ?? null);
  const impLevel = (pt.Impella_level ?? pt.ImpellaLevel ?? null);
  const impFlow = (pt.Impella_flow_Lmin ?? pt.Impella_flow ?? pt.ImpellaFlow ?? null);
  const ecmoFlow = (pt.ECMO_flow_Lmin ?? pt.ECMO_flow ?? null);
  const ecmoRpm = (pt.ECMO_rpm ?? null);
  const iabpRatio = (pt.IABP_ratio ?? pt.IABPratio ?? null);
  const pvLine = `<strong>PV-loops:</strong> EDV ${fmt(pt.EDV,0)} ml; ESV ${fmt(pt.ESV,0)} ml; ESP ${fmt(pt.ESP,0)} mmHg; Ea ${fmt(pt.Ea,2)}; Ees ${fmt(pt.Ees,2)}; VAC ${fmt(pt.VAC,2)}; SW ${fmt(pt.SW,1)}; PE ${fmt(pt.PE,1)}; PVA ${fmt(pt.PVA,1)}; Efficiency ${fmt(pt.Eff,2)}; V0 ${fmt(pt.V0_EDPVR ?? pt.V0,1)} ml.`;
  const bsaLine = `<strong>BSA:</strong> ${Number.isFinite(bsa)? fmt(bsa,2)+' m²' : '—' }`;
  const perfLine = `<strong>Perfusión:</strong> SvO₂ ${Number.isFinite(svo2)? fmt(svo2,0)+'%' : '—' }`;
  const visText = Number.isFinite(lvis)? `VIS ${fmt(lvis,0)}` : '';
  const deviceParts = [];
  // Coerce numeric/string variants and accept presence flags as fallback
  const impFlowNum = (impFlow!==null && impFlow!==undefined && impFlow!=='') ? parseFloat(impFlow) : NaN;
  const impFlowValid = Number.isFinite(impFlowNum);
  const impLevelValid = (impLevel!==null && impLevel!==undefined && String(impLevel).trim()!=='');
  // DOM fallback (read once)
  const _domFallback = readDeviceInputsFromDOM(pt);
  const impActive = (pt.devs && pt.devs['Impella']) || (_domFallback && _domFallback.devs && _domFallback.devs.Impella);
  if(!impFlowValid && _domFallback && _domFallback.impFlowRaw) impFlow = _domFallback.impFlowRaw;
  if(!impLevelValid && _domFallback && _domFallback.impLevel) impLevel = _domFallback.impLevel;
  // DOM fallback
  if(!impFlowValid || !impLevelValid){
    const dom = readDeviceInputsFromDOM(pt);
    if(dom){ if(!impLevelValid && dom.impLevel) impLevel = dom.impLevel; if(!impFlowValid && dom.impFlowRaw) impFlow = dom.impFlowRaw; }
  }
  // DOM fallback
  if(!impFlowValid || !impLevelValid){
    const dom = readDeviceInputsFromDOM(pt);
    if(dom){ if(!impLevelValid && dom.impLevel) impLevel = dom.impLevel; if(!impFlowValid && dom.impFlowRaw) impFlow = dom.impFlowRaw; }
  }
  if(impActive){
    let s = 'Impella';
    if(impLevel && String(impLevel).trim()!=='') s += ` p-${impLevel}`;
    const impFlowNumNow = (impFlow!==null && impFlow!==undefined && impFlow!=='') ? parseFloat(impFlow) : NaN;
    if(Number.isFinite(impFlowNumNow)) s += `, flow ${fmt(impFlowNumNow,1)} L/min`;
    deviceParts.push(s);
  }
  const ecmoFlowNum = (ecmoFlow!==null && ecmoFlow!==undefined && ecmoFlow!=='') ? parseFloat(ecmoFlow) : NaN;
  const ecmoFlowValid = Number.isFinite(ecmoFlowNum);
  const ecmoRpmValid = (ecmoRpm!==null && ecmoRpm!==undefined && String(ecmoRpm).trim()!=='');
  const ecmoActive = (pt.devs && pt.devs['ECMO']) || (_domFallback && _domFallback.devs && _domFallback.devs.ECMO);
  if(!ecmoFlowValid && _domFallback && _domFallback.ecmoFlowRaw) ecmoFlow = _domFallback.ecmoFlowRaw;
  if(!ecmoRpmValid && _domFallback && _domFallback.ecmoRpmRaw) ecmoRpm = _domFallback.ecmoRpmRaw;
  if(!ecmoFlowValid || !ecmoRpmValid){
    const dom = readDeviceInputsFromDOM(pt);
    if(dom){ if(!ecmoFlowValid && dom.ecmoFlowRaw) ecmoFlow = dom.ecmoFlowRaw; if(!ecmoRpmValid && dom.ecmoRpmRaw) ecmoRpm = dom.ecmoRpmRaw; }
  }
  if(!ecmoFlowValid || !ecmoRpmValid){
    const dom = readDeviceInputsFromDOM(pt);
    if(dom){ if(!ecmoFlowValid && dom.ecmoFlowRaw) ecmoFlow = dom.ecmoFlowRaw; if(!ecmoRpmValid && dom.ecmoRpmRaw) ecmoRpm = dom.ecmoRpmRaw; }
  }
  if(ecmoActive){
    let s = 'ECMO';
    const ecmoFlowNumNow = (ecmoFlow!==null && ecmoFlow!==undefined && ecmoFlow!=='') ? parseFloat(ecmoFlow) : NaN;
    if(Number.isFinite(ecmoFlowNumNow)) s += `, flow ${fmt(ecmoFlowNumNow,1)} L/min`;
    if(ecmoRpm && String(ecmoRpm).trim()!=='') s += `, rpm ${ecmoRpm}`;
    deviceParts.push(s);
  }
  const iabpValid = (iabpRatio!==null && iabpRatio!==undefined && String(iabpRatio).trim()!=='');
  const iabpActive = (pt.devs && pt.devs['IABP']) || (_domFallback && _domFallback.devs && _domFallback.devs.IABP);
  if(!iabpValid && _domFallback && _domFallback.iabpRatio) iabpRatio = _domFallback.iabpRatio;
  if(iabpActive){ deviceParts.push(`IABP ${iabpRatio||''}`); }
  // VAD support
  const vadActive = (pt.devs && pt.devs['VAD']) || (_domFallback && _domFallback.devs && _domFallback.devs.VAD);
  if(vadActive){ deviceParts.push('VAD'); }
  // If devices are flagged but no detail was produced, log quietly for debugging
  if(pt.devs && Object.values(pt.devs).some(Boolean) && deviceParts.length===0){ console.debug('summaries: devices present but no detail for timepoint', pt.time, pt.devs, {impLevel, impFlow, ecmoFlow, ecmoRpm, iabpRatio}); }
  const deviceLine = deviceParts.length? deviceParts.join('; ') : '';
  const supportQuant = `${sup}${visText? `; ${visText}` : ''}${deviceLine? `; ${deviceLine}` : ''}`;
  return `${byId('patientName').value} — ${T}
CSWG-SCAI ${pt.SCAI} (motivo: ${pt.SCAI_reason||'—'}${pt.SCAI_downgrade_flag?'; downgrade aplicado':''}).
Terapia previa: ${pt.prior_therapy?'Sí':'No'}; MCS por CS: ${pt.mcs_for_CS?'Sí':'No'}.
<strong>Signos vitales:</strong> HR ${fmt(pt.HR,0)} lpm; SBP/DBP ${fmt(pt.SBP,0)}/${fmt(pt.DBP,0)} mmHg; PAM ${fmt(pt.MAP,1)} mmHg.
<strong>Hemodinámica:</strong> CI ${fmt(pt.CI,2)} L/min/m²; CO ${fmt(pt.CO,2)} L/min; SV/SVI ${fmt((pt.EDV-pt.ESV),0)}/${fmt(pt.SVI,0)}; PVC ${fmt(pt.RAP,1)} mmHg; s/d/mPAP ${fmt(pt.sPAP,0)}/${fmt(pt.dPAP,0)}/${fmt(pt.mPAP,0)} mmHg; PCWP ${fmt(pt.PCWP,1)} mmHg.
<strong>Resistencias:</strong> SVR ${fmt(pt.SVR,0)} dyn·s·cm⁻⁵; SVRI ${fmt(pt.SVRI,0)} dyn·s·cm⁻⁵·m²; PVR ${fmt(pt.PVR_WU,2)} WU; PVRI ${fmt(pt.PVRI_WU,2)} WU·m².
<strong>Potencia:</strong> CPO ${fmt(pt.CPO,2)} W; CPI ${fmt(pt.CPI,2)} W/m²; CPI aj RAP ${fmt(pt.CPIa,2)} W/m².
<strong>Trabajo:</strong> LVSWi ${fmt(pt.LVSWi,1)} g·m/m²; RVSWi ${fmt(pt.RVSWi,1)} g·m/m².
<strong>Otros:</strong> PAPI ${fmt(pt.PAPI,2)}; OPP ${fmt(pt.OPP,0)} mmHg; CPP ${fmt(pt.CPP,0)} mmHg.
<strong>Laboratorio:</strong> lactato ${fmt(pt.Lactate,1)} mmol/L; pH ${fmt(pt.pH,2)}; ALT ${fmt(pt.ALT,0)} U/L.
  ${pvLine}
  ${bsaLine}; ${perfLine}.
  <strong>Soporte:</strong> ${sup}${visText? `; ${visText}` : ''}${deviceLine? `; ${deviceLine}` : ''}.
<strong>Impresión:</strong> ${(a.lowCI?'bajo gasto; ':'')}${(a.biCong?'congestión biventricular; ':(a.highPWP?'congestión izquierda; ':(a.highRAP?'congestión derecha; ':'')))}${(a.highLac||a.acid)?'hipoperfusión bioquímica; ':''}`.trim()+'.'+trend;
}
function buildLineEN(pt, prev){
  const T = `${pt.time}h`;
  const a = clinicalBuckets(pt);
  const d = prev? lastDelta(prev,pt): {};
  const trend = prev? ` Trend: ΔMAP ${arrowPct(d.dMAP)}; ΔPCWP ${arrowPct(d.dPCWP)}; ΔCI ${arrowPct(d.dCI)}; ΔLactate ${arrowPct(d.dLac ?? pt?.delta_lactate)}.` : '';
  const sup = `devices ${pt.devicesOn} / drugs ${Object.values(pt.doses).filter(v=>v>0).length} (total ${supportCount(pt)})`;
  // PV / perfusion / support extra fields
  const bsa = (pt.BSA ?? pt.bsa ?? null);
  const svo2 = (pt.svo2 ?? pt.SvO2 ?? pt.SVO2 ?? null);
  const lvis = (pt.LVIS ?? pt.VIS ?? pt.VIScurrent ?? null);
  const impLevel = (pt.Impella_level ?? pt.ImpellaLevel ?? null);
  const impFlow = (pt.Impella_flow_Lmin ?? pt.Impella_flow ?? pt.ImpellaFlow ?? null);
  const ecmoFlow = (pt.ECMO_flow_Lmin ?? pt.ECMO_flow ?? null);
  const ecmoRpm = (pt.ECMO_rpm ?? null);
  const iabpRatio = (pt.IABP_ratio ?? pt.IABPratio ?? null);
  const pvLine = `<strong>PV-loops:</strong> EDV ${fmt(pt.EDV,0)} ml; ESV ${fmt(pt.ESV,0)} ml; ESP ${fmt(pt.ESP,0)} mmHg; Ea ${fmt(pt.Ea,2)}; Ees ${fmt(pt.Ees,2)}; VAC ${fmt(pt.VAC,2)}; SW ${fmt(pt.SW,1)}; PE ${fmt(pt.PE,1)}; PVA ${fmt(pt.PVA,1)}; Efficiency ${fmt(pt.Eff,2)}; V0 ${fmt(pt.V0_EDPVR ?? pt.V0,1)} ml.`;
  const bsaLine = `<strong>BSA:</strong> ${Number.isFinite(bsa)? fmt(bsa,2)+' m²' : '—' }`;
  const perfLine = `<strong>Perfusion:</strong> SvO₂ ${Number.isFinite(svo2)? fmt(svo2,0)+'%' : '—' }`;
  const visText = Number.isFinite(lvis)? `VIS ${fmt(lvis,0)}` : '';
  const deviceParts = [];
  // DOM fallback (read once)
  const _domFallback = readDeviceInputsFromDOM(pt);
  const impFlowNum = (impFlow!==null && impFlow!==undefined && impFlow!=='') ? parseFloat(impFlow) : NaN;
  const impFlowValid = Number.isFinite(impFlowNum);
  const impLevelValid = (impLevel!==null && impLevel!==undefined && String(impLevel).trim()!=='');
  const impActive = (pt.devs && pt.devs['Impella']) || (_domFallback && _domFallback.devs && _domFallback.devs.Impella);
  if(!impFlowValid && _domFallback && _domFallback.impFlowRaw) impFlow = _domFallback.impFlowRaw;
  if(!impLevelValid && _domFallback && _domFallback.impLevel) impLevel = _domFallback.impLevel;
  if(impActive){
    let s = 'Impella';
    if(impLevel && String(impLevel).trim()!=='') s += ` p-${impLevel}`;
    const impFlowNumNow = (impFlow!==null && impFlow!==undefined && impFlow!=='') ? parseFloat(impFlow) : NaN;
    if(Number.isFinite(impFlowNumNow)) s += `, flow ${fmt(impFlowNumNow,1)} L/min`;
    deviceParts.push(s);
  }
  const ecmoFlowNum = (ecmoFlow!==null && ecmoFlow!==undefined && ecmoFlow!=='') ? parseFloat(ecmoFlow) : NaN;
  const ecmoFlowValid = Number.isFinite(ecmoFlowNum);
  const ecmoRpmValid = (ecmoRpm!==null && ecmoRpm!==undefined && String(ecmoRpm).trim()!=='');
  const ecmoActive = (pt.devs && pt.devs['ECMO']) || (_domFallback && _domFallback.devs && _domFallback.devs.ECMO);
  if(!ecmoFlowValid && _domFallback && _domFallback.ecmoFlowRaw) ecmoFlow = _domFallback.ecmoFlowRaw;
  if(!ecmoRpmValid && _domFallback && _domFallback.ecmoRpmRaw) ecmoRpm = _domFallback.ecmoRpmRaw;
  if(ecmoActive){
    let s = 'ECMO';
    const ecmoFlowNumNow = (ecmoFlow!==null && ecmoFlow!==undefined && ecmoFlow!=='') ? parseFloat(ecmoFlow) : NaN;
    if(Number.isFinite(ecmoFlowNumNow)) s += `, flow ${fmt(ecmoFlowNumNow,1)} L/min`;
    if(ecmoRpm && String(ecmoRpm).trim()!=='') s += `, rpm ${ecmoRpm}`;
    deviceParts.push(s);
  }
  const iabpValid = (iabpRatio!==null && iabpRatio!==undefined && String(iabpRatio).trim()!=='');
  const iabpActive = (pt.devs && pt.devs['IABP']) || (_domFallback && _domFallback.devs && _domFallback.devs.IABP);
  if(!iabpValid && _domFallback && _domFallback.iabpRatio) iabpRatio = _domFallback.iabpRatio;
  if(iabpActive){ deviceParts.push(`IABP ${iabpRatio||''}`); }
  // VAD support
  const vadActive = (pt.devs && pt.devs['VAD']) || (_domFallback && _domFallback.devs && _domFallback.devs.VAD);
  if(vadActive){ deviceParts.push('VAD'); }
  if(pt.devs && Object.values(pt.devs).some(Boolean) && deviceParts.length===0){ console.debug('summaries: devices present but no detail for timepoint', pt.time, pt.devs, {impLevel, impFlow, ecmoFlow, ecmoRpm, iabpRatio}); }
  const deviceLine = deviceParts.length? deviceParts.join('; ') : '';
  const supportQuant = `${sup}${visText? `; ${visText}` : ''}${deviceLine? `; ${deviceLine}` : ''}`;
  return `${byId('patientName').value} — ${T}
CSWG-SCAI ${pt.SCAI} (reason: ${pt.SCAI_reason||'—'}${pt.SCAI_downgrade_flag?'; downgrade applied':''}).
Prior therapy: ${pt.prior_therapy?'Yes':'No'}; MCS for CS: ${pt.mcs_for_CS?'Yes':'No'}.
<strong>Vitals:</strong> HR ${fmt(pt.HR,0)} bpm; SBP/DBP ${fmt(pt.SBP,0)}/${fmt(pt.DBP,0)} mmHg; MAP ${fmt(pt.MAP,1)} mmHg.
<strong>Hemodynamics:</strong> CI ${fmt(pt.CI,2)} L/min/m²; CO ${fmt(pt.CO,2)} L/min; SV/SVI ${fmt((pt.EDV-pt.ESV),0)}/${fmt(pt.SVI,0)}; RAP ${fmt(pt.RAP,1)} mmHg; s/d/mPAP ${fmt(pt.sPAP,0)}/${fmt(pt.dPAP,0)}/${fmt(pt.mPAP,0)} mmHg; PCWP ${fmt(pt.PCWP,1)} mmHg.
<strong>Resistances:</strong> SVR ${fmt(pt.SVR,0)} dyn·s·cm⁻⁵; SVRI ${fmt(pt.SVRI,0)} dyn·s·cm⁻⁵·m²; PVR ${fmt(pt.PVR_WU,2)} WU; PVRI ${fmt(pt.PVRI_WU,2)} WU·m².
<strong>Power:</strong> CPO ${fmt(pt.CPO,2)} W; CPI ${fmt(pt.CPI,2)} W/m²; CPI_adj_RAP ${fmt(pt.CPIa,2)} W/m².
<strong>Work:</strong> LVSWi ${fmt(pt.LVSWi,1)} g·m/m²; RVSWi ${fmt(pt.RVSWi,1)} g·m/m².
<strong>Other:</strong> PAPI ${fmt(pt.PAPI,2)}; OPP ${fmt(pt.OPP,0)} mmHg; CPP ${fmt(pt.CPP,0)} mmHg.
<strong>Laboratory:</strong> lactate ${fmt(pt.Lactate,1)} mmol/L; pH ${fmt(pt.pH,2)}; ALT ${fmt(pt.ALT,0)} U/L.
  ${pvLine}
  ${bsaLine}; ${perfLine}.
  <strong>Support:</strong> ${sup}${visText? `; ${visText}` : ''}${deviceLine? `; ${deviceLine}` : ''}.
<strong>Assessment:</strong> ${(a.lowCI?'low output; ':'')}${(a.biCong?'biventricular congestion; ':(a.highPWP?'left-sided congestion; ':(a.highRAP?'right-sided congestion; ':'')))}${(a.highLac||a.acid)?'biochemical hypoperfusion; ':''}`.trim()+'.'+trend;
}
function buildLineIT(pt, prev){
  const T = `${pt.time}h`;
  const a = clinicalBuckets(pt);
  const d = prev? lastDelta(prev,pt): {};
  const trend = prev? ` Trend: ΔPAM ${arrowPct(d.dMAP)}; ΔPCPW ${arrowPct(d.dPCWP)}; ΔIC ${arrowPct(d.dCI)}; ΔLatt ${arrowPct(d.dLac ?? pt?.delta_lactate)}.` : '';
  const sup = `dispositivi ${pt.devicesOn} / farmaci ${Object.values(pt.doses).filter(v=>v>0).length} (totale ${supportCount(pt)})`;
  // PV / perfusion / support extra fields
  const bsa = (pt.BSA ?? pt.bsa ?? null);
  const svo2 = (pt.svo2 ?? pt.SvO2 ?? pt.SVO2 ?? null);
  const lvis = (pt.LVIS ?? pt.VIS ?? pt.VIScurrent ?? null);
  const impLevel = (pt.Impella_level ?? pt.ImpellaLevel ?? null);
  const impFlow = (pt.Impella_flow_Lmin ?? pt.Impella_flow ?? pt.ImpellaFlow ?? null);
  const ecmoFlow = (pt.ECMO_flow_Lmin ?? pt.ECMO_flow ?? null);
  const ecmoRpm = (pt.ECMO_rpm ?? null);
  const iabpRatio = (pt.IABP_ratio ?? pt.IABPratio ?? null);
  const pvLine = `<strong>PV-loops:</strong> EDV ${fmt(pt.EDV,0)} ml; ESV ${fmt(pt.ESV,0)} ml; ESP ${fmt(pt.ESP,0)} mmHg; Ea ${fmt(pt.Ea,2)}; Ees ${fmt(pt.Ees,2)}; VAC ${fmt(pt.VAC,2)}; SW ${fmt(pt.SW,1)}; PE ${fmt(pt.PE,1)}; PVA ${fmt(pt.PVA,1)}; Efficiency ${fmt(pt.Eff,2)}; V0 ${fmt(pt.V0_EDPVR ?? pt.V0,1)} ml.`;
  const bsaLine = `<strong>BSA:</strong> ${Number.isFinite(bsa)? fmt(bsa,2)+' m²' : '—' }`;
  const perfLine = `<strong>Perfusione:</strong> SvO₂ ${Number.isFinite(svo2)? fmt(svo2,0)+'%' : '—' }`;
  const visText = Number.isFinite(lvis)? `VIS ${fmt(lvis,0)}` : '';
  const deviceParts = [];
  // DOM fallback (read once)
  const _domFallback = readDeviceInputsFromDOM(pt);
  const impFlowNum = (impFlow!==null && impFlow!==undefined && impFlow!=='') ? parseFloat(impFlow) : NaN;
  const impFlowValid = Number.isFinite(impFlowNum);
  const impLevelValid = (impLevel!==null && impLevel!==undefined && String(impLevel).trim()!=='');
  const impActive = (pt.devs && pt.devs['Impella']) || (_domFallback && _domFallback.devs && _domFallback.devs.Impella);
  if(!impFlowValid && _domFallback && _domFallback.impFlowRaw) impFlow = _domFallback.impFlowRaw;
  if(!impLevelValid && _domFallback && _domFallback.impLevel) impLevel = _domFallback.impLevel;
  if(impActive){
    let s = 'Impella';
    if(impLevel && String(impLevel).trim()!=='') s += ` p-${impLevel}`;
    const impFlowNumNow = (impFlow!==null && impFlow!==undefined && impFlow!=='') ? parseFloat(impFlow) : NaN;
    if(Number.isFinite(impFlowNumNow)) s += `, flow ${fmt(impFlowNumNow,1)} L/min`;
    deviceParts.push(s);
  }
  const ecmoFlowNum = (ecmoFlow!==null && ecmoFlow!==undefined && ecmoFlow!=='') ? parseFloat(ecmoFlow) : NaN;
  const ecmoFlowValid = Number.isFinite(ecmoFlowNum);
  const ecmoRpmValid = (ecmoRpm!==null && ecmoRpm!==undefined && String(ecmoRpm).trim()!=='');
  const ecmoActive = (pt.devs && pt.devs['ECMO']) || (_domFallback && _domFallback.devs && _domFallback.devs.ECMO);
  if(!ecmoFlowValid && _domFallback && _domFallback.ecmoFlowRaw) ecmoFlow = _domFallback.ecmoFlowRaw;
  if(!ecmoRpmValid && _domFallback && _domFallback.ecmoRpmRaw) ecmoRpm = _domFallback.ecmoRpmRaw;
  if(ecmoActive){
    let s = 'ECMO';
    const ecmoFlowNumNow = (ecmoFlow!==null && ecmoFlow!==undefined && ecmoFlow!=='') ? parseFloat(ecmoFlow) : NaN;
    if(Number.isFinite(ecmoFlowNumNow)) s += `, flow ${fmt(ecmoFlowNumNow,1)} L/min`;
    if(ecmoRpm && String(ecmoRpm).trim()!=='') s += `, rpm ${ecmoRpm}`;
    deviceParts.push(s);
  }
  const iabpValid = (iabpRatio!==null && iabpRatio!==undefined && String(iabpRatio).trim()!=='');
  const iabpActive = (pt.devs && pt.devs['IABP']) || (_domFallback && _domFallback.devs && _domFallback.devs.IABP);
  if(!iabpValid && _domFallback && _domFallback.iabpRatio) iabpRatio = _domFallback.iabpRatio;
  if(iabpActive){ deviceParts.push(`IABP ${iabpRatio||''}`); }
  // VAD support
  const vadActive = (pt.devs && pt.devs['VAD']) || (_domFallback && _domFallback.devs && _domFallback.devs.VAD);
  if(vadActive){ deviceParts.push('VAD'); }
  if(pt.devs && Object.values(pt.devs).some(Boolean) && deviceParts.length===0){ console.debug('summaries: devices present but no detail for timepoint', pt.time, pt.devs, {impLevel, impFlow, ecmoFlow, ecmoRpm, iabpRatio}); }
  const deviceLine = deviceParts.length? deviceParts.join('; ') : '';
  const supportQuant = `${sup}${visText? `; ${visText}` : ''}${deviceLine? `; ${deviceLine}` : ''}`;
  return `${byId('patientName').value} — ${T}
CSWG-SCAI ${pt.SCAI} (motivo: ${pt.SCAI_reason||'—'}${pt.SCAI_downgrade_flag?'; downgrade applicato':''}).
Terapia pregressa: ${pt.prior_therapy?'Sì':'No'}; MCS per SC: ${pt.mcs_for_CS?'Sì':'No'}.
<strong>Parametri vitali:</strong> HR ${fmt(pt.HR,0)} bpm; SBP/DBP ${fmt(pt.SBP,0)}/${fmt(pt.DBP,0)} mmHg; PAM ${fmt(pt.MAP,1)} mmHg.
<strong>Emodinamica:</strong> IC ${fmt(pt.CI,2)} L/min/m²; CO ${fmt(pt.CO,2)} L/min; SV/SVI ${fmt((pt.EDV-pt.ESV),0)}/${fmt(pt.SVI,0)}; PVC ${fmt(pt.RAP,1)} mmHg; s/d/mPAP ${fmt(pt.sPAP,0)}/${fmt(pt.dPAP,0)}/${fmt(pt.mPAP,0)} mmHg; PCWP ${fmt(pt.PCWP,1)} mmHg.
<strong>Resistenze:</strong> SVR ${fmt(pt.SVR,0)} dyn·s·cm⁻⁵; SVRI ${fmt(pt.SVRI,0)} dyn·s·cm⁻⁵·m²; PVR ${fmt(pt.PVR_WU,2)} WU; PVRI ${fmt(pt.PVRI_WU,2)} WU·m².
<strong>Potenza:</strong> CPO ${fmt(pt.CPO,2)} W; CPI ${fmt(pt.CPI,2)} W/m²; CPI corretto RAP ${fmt(pt.CPIa,2)} W/m².
<strong>Lavoro:</strong> LVSWi ${fmt(pt.LVSWi,1)} g·m/m²; RVSWi ${fmt(pt.RVSWi,1)} g·m/m².
<strong>Altro:</strong> PAPI ${fmt(pt.PAPI,2)}; OPP ${fmt(pt.OPP,0)} mmHg; CPP ${fmt(pt.CPP,0)} mmHg.
<strong>Laboratorio:</strong> lattato ${fmt(pt.Lactate,1)} mmol/L; pH ${fmt(pt.pH,2)}; ALT ${fmt(pt.ALT,0)} U/L.
  ${pvLine}
  ${bsaLine}; ${perfLine}.
  <strong>Supporto:</strong> ${sup}${visText? `; ${visText}` : ''}${deviceLine? `; ${deviceLine}` : ''}.
<strong>Valutazione:</strong> ${(a.lowCI?'bassa portata; ':'')}${(a.biCong?'congestione biventricular; ':(a.highPWP?'congestione sinistra; ':(a.highRAP?'congestione destra; ':'')))}${(a.highLac||a.acid)?'ipoperfusione biochimica; ':''}`.trim()+'.'+trend;
}

function generateSummaries(){
  const all = collectAll();
  const vis = all.filter(r=>r.on);
  if(!vis.length){ 
    byId('sumES').innerHTML = byId('sumEN').innerHTML = byId('sumIT').innerHTML = ''; 
    byId('summaryDisplay').innerHTML = '<div style="color:#94a3b8;text-align:center;padding:40px">No timepoints available</div>';
    return; 
  }
  const linesES=[], linesEN=[], linesIT=[];
  for(let i=0;i<vis.length;i++){
    const prev = i>0? vis[i-1] : null;
    linesES.push(buildLineES(vis[i], prev));
    linesEN.push(buildLineEN(vis[i], prev));
    linesIT.push(buildLineIT(vis[i], prev));
  }
  // Store full summaries globally for filtering
  window._fullSummaries = { es: linesES, en: linesEN, it: linesIT, timepoints: vis };
  
  // Store in hidden elements (for compatibility)
  byId('sumES').innerHTML = linesES.join('<br><br>');
  byId('sumEN').innerHTML = linesEN.join('<br><br>');
  byId('sumIT').innerHTML = linesIT.join('<br><br>');
  
  // Update time filter dropdown
  try{ updateSummaryTimeFilter(); }catch(e){}
  
  // Display in main summary box
  try{ applySummaryFilters(); }catch(e){}
}

// Update summary time filter dropdown based on visible timepoints
function updateSummaryTimeFilter(){
  const sel = byId('summaryTimeFilter');
  if(!sel) return;
  const all = collectAll();
  const vis = all.filter(r=>r.on);
  sel.innerHTML = '<option value="all">All timepoints</option>';
  vis.forEach((tp, idx)=>{
    const opt = document.createElement('option');
    opt.value = idx;
    const label = tp.label || tp.time || `T${idx}`;
    opt.textContent = label;
    sel.appendChild(opt);
  });
}

// Apply summary filters - Single Display Version
function applySummaryFilters(){
  if(!window._fullSummaries){
    generateSummaries();
    return;
  }
  
  // Get current language from active pill
  const activePill = document.querySelector('.lang-pill.active');
  const lang = activePill ? activePill.dataset.lang : 'es';
  const timeFilter = byId('summaryTimeFilter')?.value || 'all';
  
  const summaries = window._fullSummaries;
  const timepoints = summaries.timepoints || [];
  
  // Update language label (show flag SVGs from the active pill + name)
  const langLabels = { es: 'Español', en: 'English', it: 'Italiano' };
  const labelEl = byId('summaryLangLabel');
  if(labelEl) {
    // If the active pill contains embedded SVGs inside .flag-icon, copy them to the header so they match exactly.
    // Fallback: if there's no .flag-icon wrapper, try to copy a single svg.flag element.
    let flagHtml = '';
    try{
      if(activePill && activePill.querySelector){
        const fi = activePill.querySelector('.flag-icon');
        const svg = activePill.querySelector('svg.flag');
        if(fi) flagHtml = fi.outerHTML;
        else if(svg) flagHtml = svg.outerHTML;
      }
    }catch(e){ flagHtml = ''; }
    labelEl.innerHTML = `${flagHtml} ${langLabels[lang] || 'Summary'}`;
    labelEl.title = langLabels[lang] || 'Summary';
  }
  
  // Get content for selected language
  const displayEl = byId('summaryDisplay');
  if(!displayEl) return;
  
  let content = '';
  
  if(timeFilter === 'all'){
    // Show all timepoints
    content = summaries[lang].join('<br><br>');
  } else {
    // Show single timepoint
    const idx = parseInt(timeFilter);
    if(idx >= 0 && idx < summaries[lang].length){
      content = summaries[lang][idx];
    }
  }
  
  displayEl.innerHTML = content;
  
  // Update stats
  const statsEl = byId('summaryStats');
  if(statsEl){
    const text = displayEl.textContent || '';
    const lines = text ? text.split(/\r?\n/).length : 0;
    const chars = text.length;
    statsEl.textContent = `${lines} lines · ${chars} chars`;
  }
}

// Wire summary filter controls - Single Display Version
function wireSummaryFilterControls(){
  // Wire language pills
  const pills = document.querySelectorAll('.lang-pill');
  pills.forEach(pill => {
    pill.addEventListener('click', (e) => {
      // Remove active class from all pills and let CSS handle non-active styles
      pills.forEach(p => {
        p.classList.remove('active');
        p.style.background = '';
        p.style.color = '';
      });
      // Add active class to clicked pill and set active visuals
      pill.classList.add('active');
      pill.style.background = '#2563eb';
      pill.style.color = '#fff';
      // Apply filters
      applySummaryFilters();
    });
    
    // Hover effects
    // Rely on CSS :hover for hover visuals; ensure inline style isn't left behind
    pill.addEventListener('mouseenter', () => { if(!pill.classList.contains('active')) pill.style.background = ''; });
    pill.addEventListener('mouseleave', () => { if(!pill.classList.contains('active')) pill.style.background = ''; });
  });
  
  // Wire time filter
  const timeFilter = byId('summaryTimeFilter');
  if(timeFilter){
    timeFilter.addEventListener('change', applySummaryFilters);
  }
  
  // Wire copy button
  const btnCopy = byId('btnCopySummary');
  if(btnCopy){
    btnCopy.addEventListener('click', async () => {
      const displayEl = byId('summaryDisplay');
      if(!displayEl) return;
      const text = displayEl.textContent || '';
      try{
        await navigator.clipboard.writeText(text);
        const originalText = btnCopy.innerHTML;
        btnCopy.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg> Copied!';
        btnCopy.style.background = '#10b981';
        setTimeout(() => {
          btnCopy.innerHTML = originalText;
          btnCopy.style.background = '#2563eb';
        }, 1500);
      }catch(e){
        console.warn('Copy failed', e);
      }
    });
  }
  
  // Wire save button
  const btnSave = byId('btnSaveSummary');
  if(btnSave){
    btnSave.addEventListener('click', () => {
      const displayEl = byId('summaryDisplay');
      const activePill = document.querySelector('.lang-pill.active');
      const lang = activePill ? activePill.dataset.lang : 'es';
      if(!displayEl) return;
      const text = displayEl.textContent || '';
      const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      const patientName = byId('patientName')?.value || 'patient';
      a.download = `${sanitizeFileName(patientName)}-summary-${lang}.txt`;
      a.click();
      URL.revokeObjectURL(a.href);
    });
  }
}

// Initialize summary filters on page load
window.addEventListener('DOMContentLoaded', ()=>{
  try{ wireSummaryFilterControls(); }catch(e){ console.warn('Failed to wire summary filter controls', e); }
});

/* ======= Orchestrator ======= */
function renderAllTables(all){
  renderTablesVertical(all);
  renderSupportTable(all);
}
function generateAll(){
  const all = collectAll();
  renderPV(all);
  renderKPIs(all);
  renderHemo(all);
  renderStageTimeline(all);
  renderTrends(all);
  renderAllTables(all);
  // Always render gauges (gauges are now in Dashboard)
  renderGauges(all);
  // Lightweight diagnostic: summarize clone->original propagation for alarms
  try{
    (function alarmSyncDiagnostic(){
      try{
        if(!window.ALARM_RULES) return;
        const clones = (window.ALARM_RULES||[]).flatMap(g => (g.items||[]));
        const clonesWithRef = clones.filter(c => c && c._originalRef);
        const firedClones = clonesWithRef.filter(c => !!c._lastActive);
        const mismatches = firedClones.filter(c => !(c._originalRef && c._originalRef._lastActive));
        if(window.ALARM_DEBUG){
          console.info('ALARM-DIAG: clones total=%d withRef=%d fired=%d mismatches=%d', clones.length, clonesWithRef.length, firedClones.length, mismatches.length);
          if(mismatches.length){
            console.table(mismatches.slice(0,50).map(c=>({ id:c.id, label:c.label, tag:c.tag, cloneLastActive:!!c._lastActive, originalLastActive: !!(c._originalRef && c._originalRef._lastActive) })));
          }
        }
      }catch(e){ /* diagnostic must never throw */ }
    })();
  }catch(e){ }
}

/* ======= CSV I/O ======= */
// Helpers to safely Base64-encode/decode Unicode strings for embedding JSON into CSV
function b64EncodeUnicode(str){
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1){ return String.fromCharCode('0x'+p1); }));
}
function b64DecodeUnicode(str){
  return decodeURIComponent(Array.prototype.map.call(atob(str), function(c){ return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); }).join(''));
}

function exportCSV(){
  const allRaw = collectAll();
  const all = allRaw.filter(r=>r.on);
  if(!all.length) return;
  // Helper to safely CSV-quote values (escape double-quotes and newlines)
  const csvEscape = (v)=>{
    if(v===undefined || v===null) return '""';
    const s = (typeof v === 'string') ? v : JSON.stringify(v);
    return '"' + s.replace(/"/g,'""').replace(/\r?\n/g,'\\n') + '"';
  };
  const hdr = [
    "time","HR","CO","CI","SVI","CPO","CPI","CPI_adj_RAP",
    "SBP","DBP","MAP","ESP","Ea","Ees","VAC",
    "SVR_dyn","SVRI_dyn_m2",
    "PCWP","EDV","ESV","LVSWi","OPP","CPP",
    "RAP","sPAP","dPAP","mPAP","PAPI",
    "PVR_WU","PVRI_WU_m2","RVSWi",
    "ESP_SW","PE","PVA","Eff","V0_EDPVR","beta","alpha",
    "Lactate","ALT","pH","OHCA",
  "Creatinine","SvO2",
  "IABP_ratio","Impella_level","Impella_flow_Lmin","ECMO_rpm","ECMO_flow_Lmin",
    "prior_therapy","mcs_for_CS","supports_total","devices_on","inotropes_on","pressors_on","LVIS",
    "SCAI","SCAI_reason","SCAI_downgrade_flag","SCAI_downgrade_reason",
    ...DEV_KEYS.map(k=>`DEV_${k}`),
    ...Object.keys(DOSE_KEYS).map(k=>`DOSE_${k}`),
  'PATIENT_NAME','Age','Sex','csType','Height_m','Weight_kg'
    ];
  const to0=x=>Number.isFinite(x)?Math.round(x):''; const to1=x=>Number.isFinite(x)?x.toFixed(1):''; const to2=x=>Number.isFinite(x)?x.toFixed(2):'';
  const patientNameVal = (byId('patientName')?.value) || '';
  const ptAgeVal = (byId('ptAge')?.value) || '';
  const ptSexVal = (byId('ptSex')?.value) || '';
  const csTypeVal = (function(){ const n=document.querySelector('input[name="csType"]:checked'); return n? n.value: ''; })();
  const ptHVal = (byId('ptH')?.value) || '';
  const ptWVal = (byId('ptW')?.value) || '';
  const lines = [hdr.join(',')].concat(all.map((r, idx)=>[
    r.time, r.HR, to2(r.CO), to2(r.CI), to1(r.SVI), to2(r.CPO), to2(r.CPI), to2(r.CPIa),
    r.SBP, r.DBP, to1(r.MAP), to1(r.ESP), to2(r.Ea), to2(r.Ees), to2(r.VAC),
    to0(r.SVR), to0(r.SVRI),
    to1(r.PCWP), to1(r.EDV), to1(r.ESV), to2(r.LVSWi), to1(r.OPP), to1(r.CPP),
    to1(r.RAP), to1(r.sPAP), to1(r.dPAP), to1(r.mPAP), to2(r.PAPI),
    to2(r.PVR_WU), to2(r.PVRI_WU), to2(r.RVSWi),
    to0(r.SW), to0(r.PE), to0(r.PVA), to1(r.Eff), to1(r.V0_EDPVR), to2(r.beta), (Number.isFinite(r.alpha)?r.alpha.toExponential(2):''),
  to1(r.Lactate ?? r.Lact), to0(r.ALT), (Number.isFinite(r.pH)?r.pH.toFixed(2):''), r.OHCA?1:0, (Number.isFinite(r.creatinine)? r.creatinine : ''), (Number.isFinite(r.SvO2)? r.SvO2 : (Number.isFinite(r.svo2)? r.svo2 : '')),
  (r.IABP_ratio !== undefined && r.IABP_ratio !== null ? String(r.IABP_ratio) : ''), (r.Impella_level !== undefined && r.Impella_level !== null ? String(r.Impella_level) : ''), to1(r.Impella_flow_Lmin), to0(r.ECMO_rpm), to1(r.ECMO_flow_Lmin),
    r.prior_therapy?1:0, r.mcs_for_CS?1:0, (r.devicesOn + r.drugsOn), r.devicesOn, r.inotropesOn, r.pressorsOn, to2(r.LVIS),
    r.SCAI??'', r.SCAI_reason??'', r.SCAI_downgrade_flag??0, r.SCAI_downgrade_reason??'',
    ...DEV_KEYS.map(k=> r.devs[k]?1:0),
    ...Object.keys(DOSE_KEYS).map(k=> (r.doses[k]??0)),
    // metadata column: patient name (human-friendly) + patient meta
    patientNameVal, ptAgeVal, ptSexVal, csTypeVal, ptHVal, ptWVal
  ].join(',')));
  const blob=new Blob([lines.join('\n')],{type:'text/csv;charset=utf-8;'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
  const outName = sanitizeFileName(patientNameVal) || 'pv_patient_results';
  a.download = `${outName}.csv`;
  a.click(); URL.revokeObjectURL(a.href);
}

function importCSVFile(file){
  const reader = new FileReader();
  reader.onload = ()=>{
    const lines = reader.result.split(/\r?\n/).filter(Boolean);
    if(lines.length<2) return;
    // If the file looks tab-separated or semicolon-separated, normalize to commas so parser works
    if(lines[0]){
      if(lines[0].indexOf(',')===-1 && lines[0].indexOf('\t')!==-1){
        lines = lines.map(l=> l.replace(/\t/g, ','));
      } else if(lines[0].indexOf(',')===-1 && lines[0].indexOf(';')!==-1){
        lines = lines.map(l=> l.replace(/;/g, ','));
      }
    }

    // Robust CSV line parser (handles quoted fields with doubled quotes)
    const parseCSVLine = (line) => {
      const out = [];
      let cur = '';
      let inQuotes = false;
      for(let i=0;i<line.length;i++){
        const ch = line[i];
        if(inQuotes){
          if(ch === '"'){
            if(line[i+1] === '"'){ cur += '"'; i++; } else { inQuotes = false; }
          } else { cur += ch; }
        } else {
          if(ch === ','){ out.push(cur); cur=''; }
          else if(ch === '"'){ inQuotes = true; }
          else { cur += ch; }
        }
      }
      out.push(cur);
      return out;
    };
  // Parse encabezado (case-insensitive lookup)
  const hdr = parseCSVLine(lines[0]).map(s=>s.trim());
  const hdrLower = hdr.map(s=> (s||'').toLowerCase());
  const idx = (k)=> hdr.indexOf(k);
  const idxOf = (k)=> hdrLower.indexOf((k||'').toLowerCase());
    const safeGet = (arr, i)=> (i>=0 && i<arr.length)? arr[i] : '';

    // If the export contains a full serialized state (BASE64 encoded JSON in FULL_STATE column), restore it
    const fullIdx = idxOf('FULL_STATE');
    const computedIdx = idxOf('FULL_COMPUTED');
    const computedJsonIdx = idxOf('FULL_COMPUTED_JSON');
    const patientNameIdx = idxOf('PATIENT_NAME');
    const ageIdx = idxOf('Age');
    const sexIdx = idxOf('Sex');
    const csTypeIdx = idxOf('csType');
    const heightIdx = idxOf('Height_m');
    const weightIdx = idxOf('Weight_kg');
    const firstData = parseCSVLine(lines[1]);

    // If patient metadata present in CSV (case-insensitive), restore it for legacy imports
    try{
      if(patientNameIdx >= 0){ const p = safeGet(firstData, patientNameIdx); if(p) byId('patientName').value = p; }
      if(ageIdx >= 0){ const v = safeGet(firstData, ageIdx); if(v) byId('ptAge').value = v; }
      if(sexIdx >= 0){ const v = safeGet(firstData, sexIdx); if(v) { const sel = byId('ptSex'); if(sel) sel.value = v; } }
      if(csTypeIdx >= 0){ const v = safeGet(firstData, csTypeIdx); if(v){ const el = document.querySelector(`input[name="csType"][value="${v}"]`); if(el) el.checked = true; } }
      if(heightIdx >= 0){ const v = safeGet(firstData, heightIdx); if(v) byId('ptH').value = v; }
      if(weightIdx >= 0){ const v = safeGet(firstData, weightIdx); if(v) byId('ptW').value = v; }
    }catch(e){ console.warn('importCSVFile: failed restoring patient metadata', e); }

    // If FULL_STATE (base64) present: decode and restore entire saved object
    if(fullIdx >= 0){
      const encoded = safeGet(firstData, fullIdx);
      if(encoded){
        try{
          const parsed = JSON.parse(b64DecodeUnicode(encoded));
          // Restore full state and regenerate UI
          byId('tpInputs').innerHTML='';
          applyState(parsed);
          applyReadOnly();
          generateAll();
          // If computed snapshot present (base64), save to localStorage for audit/inspection
          if(computedIdx >= 0){ const encComp = safeGet(firstData, computedIdx); if(encComp){ try{ localStorage.setItem('pv_last_computed', b64DecodeUnicode(encComp)); }catch(e){} } }
          return;
        }catch(e){ console.warn('importCSVFile: failed decoding FULL_STATE, falling back to legacy CSV import', e); }
      }
    }

    // If FULL_COMPUTED_JSON present (plain JSON column), try to parse and restore
    if(computedJsonIdx >= 0){
      const jsonText = safeGet(firstData, computedJsonIdx);
      if(jsonText){
        try{
          const parsed = JSON.parse(jsonText);
          // If parsed looks like a saved payload (contains timepoints or patientName), apply it
          if(parsed && (parsed.timepoints || parsed.data || parsed.name || parsed.patientName)){
            byId('tpInputs').innerHTML='';
            const payload = parsed.data || parsed;
            applyState(payload);
            applyReadOnly();
            generateAll();
            // store computed snapshot if the parsed object itself is a computed array
            if(Array.isArray(parsed)){
              try{ localStorage.setItem('pv_last_computed', JSON.stringify(parsed)); }catch(e){}
            }
            return;
          }
          // Otherwise if parsed is an array (computed snapshot), store it for inspection
          if(Array.isArray(parsed)){
            try{ localStorage.setItem('pv_last_computed', JSON.stringify(parsed)); }catch(e){}
          }
        }catch(e){ console.warn('importCSVFile: failed parsing FULL_COMPUTED_JSON, continuing with legacy import', e); }
      }
    }

    // Limpia inputs (legacy CSV import path)
    byId('tpInputs').innerHTML='';

  // Use the robust parser for each CSV line (handles quoted fields)
  const safeSplit = parseCSVLine;

    for(let i=1;i<lines.length;i++){
      const c = safeSplit(lines[i]);
      // Use case-insensitive index lookup when reading columns
      const get = (k)=> safeGet(c, idxOf(k));
      const bool = (k)=> {
        const v=get(k); return (v==='1'||v==='true'||v==='TRUE');
      };
      const num  = (k,fb=0)=> {
        const v=parseFloat(get(k)); return Number.isFinite(v)?v:fb;
      };

      // Dosis y dispositivos
      const doses = Object.fromEntries(Object.keys(DOSE_KEYS).map(k=>[`$${k}`, num(`DOSE_${k}`,0)]));
      // Quitar prefijo $ al expandir (truco para evitar colisión con claves JS reservadas)
      const cleanDoses = {}; Object.keys(DOSE_KEYS).forEach(k => cleanDoses[k] = num(`DOSE_${k}`,0));
      const devs  = Object.fromEntries(DEV_KEYS.map(k=>[k, bool(`DEV_${k}`)]));

      // Construye la tarjeta
      addTP({
        time: get('time')??`T${i-1}`,
        on: true,
        active: (i===1),
        HR: num('HR',85),
        SBP:num('SBP',120),
        DBP:num('DBP',70),
        sPAP:num('sPAP',45),
        dPAP:num('dPAP',25),
        PCWP:num('PCWP',18),
        RAP:num('RAP',12),
        CO:num('CO',4.0),
        // Si no hay LVEF en CSV, usa 50% por defecto
        LVEF:num('LVEF',50),
  EDV:num('EDV',150),
  ESV:num('ESV',70),
        Lact:num('Lactate',2.0),
        ALT:num('ALT',32),
        pH:num('pH',7.4),
  Cr: num('Creatinine', ''),
  SvO2: num('SvO2', ''),
  // Device-specific fields
  IABP_ratio: (function(){ const v = get('IABP_ratio'); return v? v : ''; })(),
  Impella_level: (function(){ const v = get('Impella_level'); return v? v : ''; })(),
  Impella_flow_Lmin: num('Impella_flow_Lmin', 0),
  ECMO_rpm: num('ECMO_rpm', 0),
  ECMO_flow_Lmin: num('ECMO_flow_Lmin', 0),
        OHCA: bool('OHCA'),
        prior_therapy: bool('prior_therapy'),
        mcs_for_CS: bool('mcs_for_CS'),
        ...devs,
        ...cleanDoses
      });
    }
    applyReadOnly();
    generateAll();
  };
  reader.readAsText(file);
}

/* ======== Wiring UI ======== */
// Legacy buttons (if they exist)
const btnExport = byId('btnExport');
if(btnExport) btnExport.addEventListener('click', exportCSV);
const btnImport = byId('btnImport');
if(btnImport) btnImport.addEventListener('click', ()=> byId('csvInput').click());

// New menu buttons
byId('btnExportMenu').addEventListener('click', exportCSV);
byId('btnImportMenu').addEventListener('click', ()=> byId('csvInput').click());

byId('csvInput').addEventListener('change', (e)=>{
  const f = e.target.files?.[0];
  if(f) importCSVFile(f);
});

byId('patientFileInput').addEventListener('change', (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const parsed = JSON.parse(reader.result);
      // Accept either { name, data } or direct state
      const payload = parsed.data || parsed;
      applyState(payload);
      byId('patientMsg').textContent = 'Patient loaded from file';
    }catch(err){ alert('Error reading JSON: '+err); }
  };
  reader.readAsText(f);
});

byId('btnGenerate').addEventListener('click', generateAll);

byId('btnToggleInputs').addEventListener('click', ()=>{
  const box = byId('tpInputs');
  const hidden = (box.style.display==='none');
  box.style.display = hidden ? '' : 'none';
  byId('btnToggleInputs').textContent = hidden ? '▼ Hide timepoints' : '▲ Show timepoints';
});

/* ======== Bootstrap inicial ======== */
window.addEventListener('DOMContentLoaded', ()=>{
  // Si no hay TPs, crea dos ejemplos (0h y 6h)
  if(document.querySelectorAll('.tpCard').length===0){
    addTP({ time:'0', on:true, active:true });
  addTP({ time:'6', on:true, active:false, MAP:75, SBP:105, DBP:60, PCWP:22, RAP:14, CO:3.4, LVEF:35, Lactate:3.1, Lact:3.1,
            Norepi:0.06, Dobut:5, IABP:true, prior_therapy:true });
  }
  applyReadOnly();
  generateAll();
  // Initialize BMI/BSA chips
  try{ if(typeof updateAnthroChips === 'function') updateAnthroChips(); }catch(e){}
  // Init patient list
  setTimeout(refreshPatientList, 300);
  // Indicate if Electron API is available
  if(!window.pv?.patients){
    byId('patientMsg').textContent = 'API not available — browser mode: JSON download';
  }
  // ResizeObserver to keep Plotly plots sized to their container when the gauge grid resizes
  if (typeof ResizeObserver !== 'undefined'){
    const observePlotsIn = (container)=>{
      const ro = new ResizeObserver((entries)=>{
        entries.forEach(()=>{
          try{
            container.querySelectorAll('.js-plotly-plot').forEach(node=>{ try{ safePlotlyResize(node); }catch(e){} });
          }catch(e){}
        });
      });
      ro.observe(container);
      return ro;
    };
    const grid = document.querySelector('.gaugeGrid');
    if(grid){
      observePlotsIn(grid);
      const grid2 = document.querySelector('#gaugeContainer2'); if(grid2) observePlotsIn(grid2);
    }
  }
});

// After the initial DOM bootstrap, initialize gauge time controls (safe if function exists)
window.addEventListener('load', ()=>{
  try{ if(typeof initGaugeTimeControls === 'function') initGaugeTimeControls(); }catch(e){ console.debug('initGaugeTimeControls error', e); }
});

// Logo fallback: if .tif can't render, try .png then .svg; if none exist, hide the image element
// Logo fallback removed: only using ICO per user request

/* ================= Patient persistence (save/load folder) ================= */
function gatherState(){
  const state = {
    patientName: byId('patientName').value,
    ptAge: byId('ptAge') ? byId('ptAge').value : '',
    ptSex: byId('ptSex') ? byId('ptSex').value : '',
    ptH: byId('ptH').value, ptW: byId('ptW').value, method: byId('method').value,
    csType: (function(){ const n=document.querySelector('input[name="csType"]:checked'); return n? n.value: ''; })(),
    normalize: byId('chkNormalize').checked,
  trends: { selected: getSelectedTrendVars(), deltas: byId('chkTrDeltas')?.checked },
  timepoints: []
  };
  document.querySelectorAll('.tpCard').forEach((card, i)=>{
    const get = id => byId(id)?.type==='checkbox'? byId(id).checked : byId(id)?.value;
    const tp = {
      time: get(`t_time_${i}`), on: get(`t_on_${i}`), active: get(`t_active_${i}`),
      HR: parseFloat(get(`t_hr_${i}`))||0, CO: parseFloat(get(`t_co_${i}`))||0, LVEF: parseFloat(get(`t_lvef_${i}`))||0,
      EDV: parseFloat(get(`t_edv_${i}`))||0, ESV: parseFloat(get(`t_esv_${i}`))||0,
      SBP: parseFloat(get(`t_sbp_${i}`))||0, DBP: parseFloat(get(`t_dbp_${i}`))||0,
      sPAP: parseFloat(get(`t_spap_${i}`))||0, dPAP: parseFloat(get(`t_dpap_${i}`))||0,
      PCWP: parseFloat(get(`t_pwp_${i}`))||0, RAP: parseFloat(get(`t_rap_${i}`))||0,
      Lact: parseFloat(get(`t_lac_${i}`))||0,
      ALT: parseFloat(get(`t_alt_${i}`))||0, pH: parseFloat(get(`t_ph_${i}`))||0,
      OHCA: !!byId(`t_ohca_${i}`)?.checked,
      prior_therapy: !!byId(`t_prev_${i}`)?.checked,
      mcs_for_CS: !!byId(`t_mcs_cs_${i}`)?.checked,
      devs: {}, doses: {},
      creatinine: (function(){ const v=byId(`t_cr_${i}`)?.value; const n=parseFloat(v); return Number.isFinite(n)? n : (v? v : null); })(),
      svo2: (function(){ const v=byId(`t_svo2_${i}`)?.value; const n=parseFloat(v); return Number.isFinite(n)? n : (v? v : null); })(),
      // device-specific settings (if present in UI)
      IABP_ratio: (byId(`t_iabp_ratio_${i}`)? byId(`t_iabp_ratio_${i}`).value : ''),
      Impella_level: (byId(`t_impella_level_${i}`)? byId(`t_impella_level_${i}`).value : ''),
      Impella_flow_Lmin: (function(){ const v=byId(`t_impella_flow_${i}`)?.value; const n=parseFloat(v); return Number.isFinite(n)? n : (v? v : null); })(),
      ECMO_rpm: (function(){ const v=byId(`t_ecmo_rpm_${i}`)?.value; const n=parseFloat(v); return Number.isFinite(n)? n : (v? v : null); })(),
      ECMO_flow_Lmin: (function(){ const v=byId(`t_ecmo_flow_${i}`)?.value; const n=parseFloat(v); return Number.isFinite(n)? n : (v? v : null); })()
    };
    DEV_KEYS.forEach(k=> tp.devs[k] = !!byId(`t_dev_${k}_${i}`)?.checked);
    Object.keys(DOSE_KEYS).forEach(k=> tp.doses[k] = parseFloat(byId(`t_dose_${k}_${i}`)?.value)||0 );
    state.timepoints.push(tp);
  });
  return state;
}

function applyState(state){
  if(!state) return;
  console.debug('applyState: start', {hasState: !!state, tpCount: (state.timepoints||[]).length});
  byId('patientName').value = state.patientName || byId('patientName').value;
  if(byId('ptAge')) byId('ptAge').value = (state.ptAge ?? byId('ptAge').value);
  if(byId('ptSex')) byId('ptSex').value = (state.ptSex ?? byId('ptSex').value);
  byId('ptH').value = state.ptH ?? byId('ptH').value;
  byId('ptW').value = state.ptW ?? byId('ptW').value;
  byId('method').value = state.method || byId('method').value;
  byId('chkNormalize').checked = !!state.normalize;
  // restore csType radio if present
  try{
    if(state.csType){
      const node = document.querySelector(`input[name="csType"][value="${state.csType}"]`);
      if(node) node.checked = true;
      else document.querySelectorAll('input[name="csType"]').forEach(n=> n.checked=false);
    }
  }catch(e){}
  // update BMI/BSA chips after restoring anthropometrics
  try{ if(typeof updateAnthroChips === 'function') updateAnthroChips(); }catch(e){}
  // restore trend selections
  try{
    if(state.trends){
      const selArr = Array.isArray(state.trends.selected) ? state.trends.selected : [];
      for(let i=0;i<4;i++){
        const s = byId(`selTrVar_${i}`); if(!s) continue; s.value = selArr[i] || '';
      }
      if(byId('chkTrDeltas')) byId('chkTrDeltas').checked = !!state.trends.deltas;
    }
  }catch(e){}
  // clear and build timepoints
  byId('tpInputs').innerHTML = '';
  (state.timepoints||[]).forEach((tp, idx)=>{
    // Flatten nested structure saved by gatherState so addTP receives the keys it expects
    const vals = Object.assign({}, tp);
    // devs were saved as an object { IABP: true, Impella: false, ... }
    if(tp.devs && typeof tp.devs === 'object'){
      DEV_KEYS.forEach(k=> vals[k] = !!tp.devs[k]);
    }
    // doses were saved under tp.doses
    if(tp.doses && typeof tp.doses === 'object'){
      Object.keys(DOSE_KEYS).forEach(k=> vals[k] = (tp.doses[k] ?? 0));
    }
    // map saved names to the short keys used by addTP for initial values
    if(tp.creatinine !== undefined) vals['Cr'] = tp.creatinine;
    if(tp.svo2 !== undefined) vals['SvO2'] = tp.svo2;
    // Backward-compatibility: normalize legacy short drug keys -> canonical names and keep aliases
    // Some older cases saved doses/keys as Dobut/Dopa/Norepi/Epi — map them to full names
    try{
      // TOLERANT MAPPING: match top-level keys and tp.doses keys by case-insensitive prefix
      const canonNames = Object.keys(DOSE_KEYS || { Norepinephrine:1, Epinephrine:1, Dobutamine:1, Dopamine:1, Milrinone:1, Vasopressin:1, Levosimendan:1 });
      const applied = [];

      // Explicit short-name aliases (safe mapping for legacy files)
      const ALIAS_MAP = Object.freeze({
        'norepi':'Norepinephrine','norepinephrine':'Norepinephrine','norep':'Norepinephrine',
        'epi':'Epinephrine','epinephrine':'Epinephrine',
        'dobut':'Dobutamine','dobutamine':'Dobutamine',
        'dopa':'Dopamine','dopamine':'Dopamine',
        'milrinone':'Milrinone','milri':'Milrinone',
        'vasopressin':'Vasopressin','vasop':'Vasopressin',
        'levosimendan':'Levosimendan','levo':'Levosimendan','levos':'Levosimendan'
      });

      // helper: find canonical by testing canonical names and safe short aliases.
      // Avoid fuzzy/contains matching for very short tokens to prevent accidental matches
      // (e.g., 'on' or 'hr' accidentally matching 'Milrinone'). Require token length >= 3
      const findCanon = (raw) => {
        if(!raw || typeof raw !== 'string') return null;
        const t = raw.trim().toLowerCase();
        if(!t) return null;
        // explicit alias exact match first
        if(ALIAS_MAP[t]) return ALIAS_MAP[t];
        if(t.length < 3) return null;
        // direct full match for canonical names
        for(const c of canonNames) if(c.toLowerCase() === t) return c;
        // prefix match (e.g., 'nore' -> 'Norepinephrine')
        for(const c of canonNames) if(c.toLowerCase().startsWith(t)) return c;
        // small additional heuristic: if token equals first 3 characters of canon
        for(const c of canonNames) if(t === c.toLowerCase().slice(0,3)) return c;
        return null;
      };

      // Map top-level keys (e.g., 'Dobut' or 'dobut ')
      Object.keys(vals).forEach(k=>{
        const canon = findCanon(k);
        if(canon && vals[k] !== undefined){
          // If the canonical value is undefined, copy it. If canonical is 0 but
          // the source is a non-zero number (legacy file), prefer the non-zero value
          // so legacy short keys like 'Norepi' with dose>0 are preserved.
          try{
            const src = vals[k];
            const sNum = parseFloat(src);
            const tNum = parseFloat(vals[canon]);
            if(vals[canon] === undefined || (Number.isFinite(sNum) && sNum !== 0 && (!Number.isFinite(tNum) || tNum === 0))){
              vals[canon] = src; applied.push(`top.${k}->${canon}`);
            }
          }catch(e){
            if(vals[canon] === undefined){ vals[canon] = vals[k]; applied.push(`top.${k}->${canon}`); }
          }
        }
      });

      // Map entries inside tp.doses if present
      if(tp.doses && typeof tp.doses === 'object'){
        Object.keys(tp.doses).forEach(k=>{
          const canon = findCanon(k);
          if(canon && tp.doses[k] !== undefined){
            // Prefer non-zero legacy dose values over a prefilled zero canonical key.
            try{
              const src = tp.doses[k];
              const sNum = parseFloat(src);
              const tNum = parseFloat(vals[canon]);
              if(vals[canon] === undefined || (Number.isFinite(sNum) && sNum !== 0 && (!Number.isFinite(tNum) || tNum === 0))){
                vals[canon] = src; applied.push(`tp.doses.${k}->${canon}`);
              }
            }catch(e){
              if(vals[canon] === undefined){ vals[canon] = tp.doses[k]; applied.push(`tp.doses.${k}->${canon}`); }
            }
          }
        });
      }

      // Ensure short aliases remain for UI/backcompat
      Object.keys(vals).forEach(k=>{
        const canon = findCanon(k);
        if(canon && vals[canon] !== undefined){
          const short = canon.slice(0,5);
          if(vals[short] === undefined) { vals[short] = vals[canon]; applied.push(`${canon}->alias.${short}`); }
        }
      });

      if(applied.length) console.debug(`applyState: tp[${idx}] tolerant legacy mappings:`, applied, vals);
    }catch(e){ console.debug('applyState: tolerant mapping error', e); }
    // device-specific settings (preserve if present)
    if(tp.IABP_ratio !== undefined) vals['IABP_ratio'] = tp.IABP_ratio;
    if(tp.Impella_level !== undefined) vals['Impella_level'] = tp.Impella_level;
    if(tp.Impella_flow_Lmin !== undefined) vals['Impella_flow_Lmin'] = tp.Impella_flow_Lmin;
    if(tp.ECMO_rpm !== undefined) vals['ECMO_rpm'] = tp.ECMO_rpm;
    if(tp.ECMO_flow_Lmin !== undefined) vals['ECMO_flow_Lmin'] = tp.ECMO_flow_Lmin;

    addTP(vals);
    // Post-add debug: list dose input values created for this timepoint to help diagnose legacy load issues
    try{
      const doseDebug = {};
      Object.keys(DOSE_KEYS).forEach(k=>{ doseDebug[k] = byId(`t_dose_${k}_${idx}`)?.value; });
      if(Object.values(doseDebug).some(v=>v!==undefined)) console.debug(`applyState: tp[${idx}] post-addTP doses:`, doseDebug);
    }catch(e){ console.debug('applyState: post-addTP debug failed', e); }
  });
  applyReadOnly(); generateAll();
}

// (MCS demo removed)

async function refreshPatientList(){
  const sel = byId('patientList'); sel.innerHTML='';
  // Priority 1: Browser mode - if a directory handle was selected via showDirectoryPicker
  if(browserDirHandle){
    try{
      const list = [];
      for await (const [name, handle] of browserDirHandle.entries()){
        if(handle && handle.kind === 'file' && name.toLowerCase().endsWith('.json')){
          const file = await handle.getFile(); 
          list.push({ filename: name, mtime: file.lastModified });
        }
      }
      list.sort((a,b)=>b.mtime-a.mtime);
      sel.appendChild(new Option('-- saved --',''));
      list.forEach(it=> sel.appendChild(new Option(`${it.filename}  —  ${new Date(it.mtime).toLocaleString()}`, it.filename)));
      byId('patientMsg').textContent = list.length? `${list.length} patients (browser folder)` : 'No saved patients in folder';
      try{ byId('patientFolder').textContent = `Folder: ${browserDirHandle.name || '(selected folder)'}`; }catch(e){ byId('patientFolder').textContent = 'Folder selected'; }
      // preserve previous selection (do not auto-load); leave placeholder otherwise
      const prevB = sel.dataset.last || '';
      if(prevB && Array.from(sel.options).some(o=>o.value===prevB)){
        sel.value = prevB;
      }else{
        sel.value = '';
      }
      sel.dataset.last = sel.value || '';
      return;
    }catch(err){ 
      console.error('Error reading folder:', err);
      byId('patientMsg').textContent = 'Error reading folder: '+err; 
    }
  }
  // Priority 2: If running under Electron with patients API or web-bridge localStorage
  if(window.pv?.patients){
    const res = await window.pv.patients.list();
    if(!res.ok) { byId('patientMsg').textContent = 'Error listing patients: '+res.error; return; }
    const list = res.list || [];
    sel.appendChild(new Option('-- saved --',''));
    list.forEach(it=> sel.appendChild(new Option(`${it.filename}  —  ${new Date(it.mtime).toLocaleString()}`, it.filename)));
    byId('patientMsg').textContent = list.length? `${list.length} patients` : 'No saved patients';
    byId('patientFolder').textContent = res.dir ? `Folder: ${res.dir}` : '';
    // preserve previous selection (do not auto-load); leave placeholder selected otherwise
    const prev = sel.dataset.last || '';
    if(prev && Array.from(sel.options).some(o=>o.value===prev)){
      sel.value = prev;
    }else{
      sel.value = '';
    }
    sel.dataset.last = sel.value || '';
    return;
  }
  // Otherwise nothing to show
  sel.appendChild(new Option('-- no saved --',''));
  byId('patientMsg').textContent = 'No saved patients (no folder selected)';
  byId('patientFolder').textContent = '';
}

// Auto-load when the user changes selection in the dropdown
byId('patientList')?.addEventListener('change', async function(){
  const sel = this; if(!sel.value) return; sel.dataset.last = sel.value; await loadPatient();
});

// Delegated listener as a robust fallback (if element is recreated)
document.addEventListener('change', async (e)=>{
  const t = e.target; if(!t || t.id !== 'patientList') return;
  const val = t.value; if(!val) return;
  t.dataset.last = val;
  try{ byId('patientMsg').textContent = 'Loading...'; await loadPatient(); }
  catch(err){ byId('patientMsg').textContent = 'Error loading: '+err; }
});

async function savePatient(){
  const name = byId('patientName').value || `Patient`;
  // Gather minimal state (only user-editable variables). Do NOT include runtime artifacts (__computed, __alarms, etc.).
  const baseState = gatherState();
  const computedSnapshot = (typeof collectAll === 'function') ? collectAll() : null; // keep locally if needed but don't save
  // Save only the variables returned by gatherState()
  const data = Object.assign({}, baseState);
  // Debug: expose some hints when running in browser for troubleshooting
  try{ console.debug('savePatient: prepared minimal data for', name, { hasPV: !!window.pv?.patients, hasBrowserDir: !!browserDirHandle, hasSaveFilePicker: !!window.showSaveFilePicker }); }catch(e){}
  
  // If Electron preload API is available, use it
  if(window.pv?.patients?.save){
    console.debug('savePatient: using Electron preload API');
    // If the user has a file selected in the list, prefer to overwrite that exact file (auto-overwrite)
    const sel = byId('patientList'); const selectedFilename = sel?.value;
    let overwriteFilename = null;
    if(selectedFilename){
      // Auto-overwrite without confirmation
      overwriteFilename = selectedFilename;
      try{ byId('patientMsg').textContent = 'Overwriting: '+overwriteFilename; }catch(e){}
    }
    // If none selected, check for existing file with same base name and auto-overwrite it
    if(!overwriteFilename){
      const basePrefix = sanitizeFileName(name || 'patient');
      const listed = await window.pv.patients.list();
      if(listed.ok && listed.list){
        const existing = listed.list.find(f=> f.filename.startsWith(basePrefix));
        if(existing){ overwriteFilename = existing.filename; try{ byId('patientMsg').textContent = 'Overwriting: '+overwriteFilename; }catch(e){} }
      }
    }
    let res = null;
    try{
      res = await window.pv.patients.save({ name, data, overwriteFilename });
    }catch(err){ console.error('savePatient: electron save threw', err); byId('patientMsg').textContent = 'Error (electron save threw): '+err; }
    if(res && res.ok){ console.debug('savePatient: electron saved', res.filename); byId('patientMsg').textContent = 'Saved: '+res.filename; refreshPatientList(); }
    else if(res){ console.warn('savePatient: electron save failed', res); byId('patientMsg').textContent = 'Error saving: '+res.error; }
    else { /* handled above */ }
    return;
  }

  // Fallback: download JSON from renderer
  try{
    // Browser directory handle save (if folder selected via showDirectoryPicker)
    if(browserDirHandle){
      console.debug('savePatient: writing to browserDirHandle');
      try{
        // If a file is selected in the patient list, prefer to overwrite that exact file in the folder
        const sel = byId('patientList');
        const selectedFilename = sel?.value;
        const filename = (selectedFilename && selectedFilename.trim()) ? selectedFilename : `${sanitizeFileName(name)}.json`;
        const fileHandle = await browserDirHandle.getFileHandle(filename, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(JSON.stringify({ name, data }, null, 2));
        await writable.close();
        console.debug('savePatient: browser folder write complete', filename);
        byId('patientMsg').textContent = `Saved (browser folder): ${filename}`;
        refreshPatientList();
        return;
      }catch(err){ byId('patientMsg').textContent = 'Error writing to folder: '+err; }
    }
    // If browser supports the File System Access API, use it to show a save dialog and allow overwrite
    if(window.showSaveFilePicker){
      console.debug('savePatient: showSaveFilePicker available');
      try{
        const handle = await window.showSaveFilePicker({
          suggestedName: `${sanitizeFileName(name)}.json`,
          types:[{description:'JSON Patient File', accept:{'application/json':['.json']}}],
          startIn: 'documents'
        });
        const writable = await handle.createWritable();
        await writable.write(JSON.stringify({ name, data }, null, 2));
        await writable.close();
        console.debug('savePatient: showSaveFilePicker write complete', handle.name);
        byId('patientMsg').textContent = `Saved: ${handle.name}`;
        return;
      }catch(err){
        if(err.name === 'AbortError'){
          byId('patientMsg').textContent = 'Save cancelled';
          return;
        }
        // Fall through to legacy download on error
        console.warn('showSaveFilePicker failed, using fallback:', err);
      }
    }
    // Try a local save server on the host (useful when the host runs server_save.py)
    try{
      const serverUrl = `http://${location.hostname}:5000/save-patient`;
      console.debug('savePatient: attempting server save', serverUrl);
      const token = localStorage.getItem('pv_server_token') || '';
      const resp = await fetch(serverUrl, {
        method: 'POST',
        headers: Object.assign({'Content-Type':'application/json'}, token ? {'X-SAVE-TOKEN': token} : {}),
        body: JSON.stringify({ name, data })
      }).catch(e=>{ throw e; });
      let parsed = null;
      try{ parsed = await resp.json(); }catch(e){}
      if(resp.ok && parsed && parsed.ok){
        byId('patientMsg').textContent = `Saved (server): ${parsed.filename}`;
        console.debug('savePatient: server saved', parsed);
        return;
      } else {
        console.warn('savePatient: server save failed', resp.status, parsed);
        if(parsed && parsed.error) byId('patientMsg').textContent = 'Server save failed: '+parsed.error;
      }
    }catch(err){ console.warn('savePatient: server save threw', err); }

    // Fallback to legacy download (works great on iPad - lets user choose location)
    const blob = new Blob([JSON.stringify({ name, data }, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `${sanitizeFileName(name)}.json`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    // Check if iOS/iPad for better message
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    byId('patientMsg').textContent = isIOS 
      ? 'Descargando... Elige ubicación en Archivos/iCloud 📱' 
      : 'Download started';
  }catch(err){ byId('patientMsg').textContent = 'Error saving: '+err; }
}

async function loadPatient(){
  const sel = byId('patientList'); const filename = sel?.value;
  
  // Priority 1: Browser folder handle + dropdown selection
  if(browserDirHandle && filename){
    try{
      const fh = await browserDirHandle.getFileHandle(filename);
      const file = await fh.getFile(); const text = await file.text(); const parsed = JSON.parse(text);
      applyState(parsed.data || parsed);
      byId('patientMsg').textContent = `Loaded (browser folder): ${filename}`;
      return;
    }catch(err){ 
      console.error('Error reading file from folder:', err);
      byId('patientMsg').textContent = 'Error reading file from folder: '+err; 
      return; 
    }
  }
  
  // Priority 2: Electron API + dropdown selection
  if(window.pv?.patients?.load){
  if(!filename){ byId('patientMsg').textContent = 'Select a file from the list to load'; return; }
    const res = await window.pv.patients.load(filename);
    if(!res.ok) { byId('patientMsg').textContent = 'Error loading: '+res.error; return; }
    applyState(res.parsed.data || res.parsed);
    byId('patientMsg').textContent = 'Loaded: '+(res.parsed.name||filename);
    return;
  }

  // Priority 3: If user selected an item in dropdown but no folder handle (browser), instruct to pick folder
  if(filename && !browserDirHandle){
    byId('patientMsg').textContent = 'File selected in the list, but no folder has been chosen (browser). Click Folder or use Load → Open to select the file manually.';
    return;
  }

  // Priority 4: Otherwise open picker if available, then fallback to file input
  try{
    if(window.showOpenFilePicker){
      const [handle] = await window.showOpenFilePicker({ types:[{description:'JSON', accept:{'application/json':['.json']}}], multiple:false });
      const file = await handle.getFile(); const text = await file.text(); const parsed = JSON.parse(text);
      applyState(parsed.data || parsed);
      byId('patientMsg').textContent = `Loaded (browser): ${handle.name}`;
      return;
    }
  }catch(err){ 
    if(err.name !== 'AbortError') byId('patientMsg').textContent = 'Error opening file: '+err; 
    return; 
  }
  // Fallback: use file input (works on all browsers including iOS/iPad)
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  if(isIOS) byId('patientMsg').textContent = 'Selecciona archivo JSON desde Archivos 📱';
  byId('patientFileInput').click();
}

async function deletePatient(){
  if(window.pv?.patients?.delete){
    const sel = byId('patientList'); const filename = sel.value; if(!filename) return;
  if(!confirm('Delete '+filename+' ?')) return;
    const res = await window.pv.patients.delete(filename);
    if(res.ok){ byId('patientMsg').textContent = 'Deleted'; refreshPatientList(); }
    else byId('patientMsg').textContent = 'Error deleting: '+res.error;
    return;
  }
  alert('API not available: cannot delete from the browser. You can remove the file manually.');
}

// Clean all patient data (UI + selected localStorage keys)
function cleanAllPatientData(){
  try{
    const proceed = confirm('Clean all patient data? This will remove all timepoints from the UI and clear some stored app data (alarms, last computed). Proceed?');
    if(!proceed) return;

    // Remove all timepoint cards
    document.querySelectorAll('.tpCard').forEach(el=> el.remove());

    // Clear tpInputs container (defensive)
    const tpWrap = byId('tpInputs'); if(tpWrap) tpWrap.innerHTML = '';

    // Reset patient-level fields
    try{ byId('patientName').value = 'Patient 1'; }catch(e){}
    try{ byId('ptAge').value = ''; }catch(e){}
    try{ byId('ptSex').value = ''; }catch(e){}
    try{ byId('ptH').value = 1.70; }catch(e){}
    try{ byId('ptW').value = 75; }catch(e){}
    updateAnthroChips();

    // Clear known application localStorage keys (non-destructive to user files)
    const keysToClear = ['pv_last_computed','pv-one-custom-alarms','pv-one-alarms-bundle-code'];
    keysToClear.forEach(k=>{ try{ localStorage.removeItem(k); }catch(e){} });

    // Optionally clear the last computed snapshot saved by our import/export code
    try{ localStorage.removeItem('pv_last_computed'); }catch(e){}

    // Refresh UI state
    applyReadOnly();
    generateAll();
    refreshPatientList();
    byId('patientMsg').textContent = 'Cleaned: UI cleared, selected storage keys removed';
  }catch(err){ console.error('cleanAllPatientData failed', err); alert('Clean failed: '+err); }
}

// Wire buttons
byId('btnSavePatient')?.addEventListener('click', savePatient);
byId('btnLoadPatient')?.addEventListener('click', loadPatient);
byId('btnDeletePatient')?.addEventListener('click', deletePatient);
byId('btnCleanAllPatient')?.addEventListener('click', cleanAllPatientData);

// (MCS demo button removed)
// Pick folder button (Electron)
byId('btnPickFolder')?.addEventListener('click', async ()=>{
  // Electron API available -> use it
  if(window.pv?.patients?.pickDir){
    const res = await window.pv.patients.pickDir();
    // If web-bridge.js says to use browser picker, do it
    if(!res.ok && res.useBrowserPicker && window.showDirectoryPicker){
      try{
  browserDirHandle = await window.showDirectoryPicker();
  try{ await storeDirHandle(browserDirHandle); }catch(e){}
  byId('patientMsg').textContent = 'Folder selected (browser)';
  byId('patientFolder').textContent = `Folder: ${browserDirHandle.name || 'Selected folder'}`;
  refreshPatientList();
        return;
      }catch(err){ 
        byId('patientMsg').textContent = 'Folder pick cancelled or failed: '+err; 
        return; 
      }
    }
    // Normal Electron response
    if(!res.ok){ 
      if(res.canceled) byId('patientMsg').textContent='Folder pick cancelled'; 
      else byId('patientMsg').textContent='Error picking folder: '+res.error; 
      return; 
    }
    byId('patientMsg').textContent = `Folder set: ${res.dir}`;
    refreshPatientList();
    return;
  }
  // Browser fallback: use showDirectoryPicker if available
  if(window.showDirectoryPicker){
    try{
      browserDirHandle = await window.showDirectoryPicker();
      try{ await storeDirHandle(browserDirHandle); }catch(e){}
      byId('patientMsg').textContent = 'Folder selected (browser)';
      byId('patientFolder').textContent = `Folder: ${browserDirHandle.name || 'Selected folder'}`;
      refreshPatientList();
      return;
    }catch(err){ byId('patientMsg').textContent = 'Directory pick cancelled or failed: '+err; return; }
  }
  byId('patientMsg').textContent = 'Folder API not available — use Chrome/Edge or Electron version';
});

function sanitizeFileName(name){ return (name||'patient').replace(/[^a-z0-9-_\. ]+/gi,'_'); }

// Compute and render BMI/BSA chips based on current height (m) and weight (kg)
function updateAnthroChips(){
  try{
    const h = parseFloat(byId('ptH')?.value);
    const w = parseFloat(byId('ptW')?.value);
    const bmi = (Number.isFinite(h) && h>0 && Number.isFinite(w)) ? (w/(h*h)) : null;
    const bsa = (Number.isFinite(h) && h>0 && Number.isFinite(w) && typeof mostellerBSA==='function') ? mostellerBSA(h,w) : null;
    const chipBMI = byId('chipBMI'); if(chipBMI) chipBMI.textContent = `BMI ${Number.isFinite(bmi)? bmi.toFixed(1): '—'}`;
    const chipBSA = byId('chipBSA'); if(chipBSA) chipBSA.textContent = `BSA ${Number.isFinite(bsa)? bsa.toFixed(2)+' m²': '—'}`;
  }catch(e){ /* noop */ }
}

// Live-update BMI/BSA chips as the user edits anthropometrics
;['ptH','ptW'].forEach(id=>{ try{ byId(id)?.addEventListener('input', ()=>{ try{ updateAnthroChips(); }catch(e){} }); }catch(e){} });

// Live-update KPI header meta when Age/Sex change
try{
  ['ptAge','ptSex'].forEach(id=>{
    byId(id)?.addEventListener('change', ()=>{ try{ const all = collectAll(); renderKPIs(all); }catch(e){} });
  });
}catch(e){}

// Copy / download helpers for summaries
async function copySummary(id){
  const el = byId(id); if(!el) return false;
  const text = el.textContent || '';
  try{
    if(navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(text);
    }else{
      // Fallback to execCommand
      el.select(); document.execCommand('copy');
    }
    byId('patientMsg').textContent = 'Summary copied to clipboard'; setTimeout(()=>byId('patientMsg').textContent='',2000);
    return true;
  }catch(err){ byId('patientMsg').textContent = 'Copy failed'; setTimeout(()=>byId('patientMsg').textContent='',2000); return false; }
}

function downloadSummary(id, lang){
  const el = byId(id); if(!el) return false; const blob = new Blob([el.textContent||''],{type:'text/plain;charset=utf-8'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `${sanitizeFileName(byId('patientName').value||'patient')}-summary-${lang}.txt`; a.click(); URL.revokeObjectURL(a.href);
  byId('patientMsg').textContent = 'Summary download started'; setTimeout(()=>byId('patientMsg').textContent='',2000);
  return true;
}

// New: copy a single summary (button event)
async function copySingle(ev){
  const btn = ev.currentTarget; const target = btn.dataset.target; if(!target) return;
  const ok = await copySummary(target);
  const prev = btn.textContent;
  if(ok){ btn.textContent = 'Copied'; setTimeout(()=> btn.textContent = prev, 1400); }
}

function downloadSingle(ev){
  const btn = ev.currentTarget; const target = btn.dataset.target; const lang = btn.dataset.lang || 'en'; if(!target) return;
  downloadSummary(target, lang);
}

// Copy all summaries into single clipboard text (with separators)
async function copyAllSummaries(){
  const ids = ['sumES','sumEN','sumIT'];
  const parts = ids.map(id=> byId(id)?.textContent || '');
  const combined = parts.map((p,i)=> (`--- ${['ES','EN','IT'][i]} ---\n${p}`)).join('\n\n');
  try{ await navigator.clipboard.writeText(combined); byId('patientMsg').textContent = 'All summaries copied'; setTimeout(()=>byId('patientMsg').textContent='',2000); }
  catch(e){ byId('patientMsg').textContent = 'Copy all failed'; setTimeout(()=>byId('patientMsg').textContent='',2000); }
}

// Download all summaries as a zip-like single file (plain text with sections)
function downloadAllSummaries(){
  const ids = [{id:'sumES',lang:'es'},{id:'sumEN',lang:'en'},{id:'sumIT',lang:'it'}];
  const content = ids.map(it=> `--- ${it.lang.toUpperCase()} ---\n${byId(it.id)?.textContent||''}`).join('\n\n');
  const blob = new Blob([content],{type:'text/plain;charset=utf-8'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `${sanitizeFileName(byId('patientName').value||'patient')}-summaries-all.txt`; a.click(); URL.revokeObjectURL(a.href);
  byId('patientMsg').textContent = 'Download started'; setTimeout(()=>byId('patientMsg').textContent='',2000);
}

// Helpers: wired to toolbar buttons after DOM ready
function updateSummaryMeta(id){ const el = byId(id); const meta = byId('meta_'+id); if(!el || !meta) return; const txt = el.textContent || ''; const lines = txt ? txt.split(/\r?\n/).length : 0; const chars = txt.length; meta.textContent = `${lines} lines · ${chars} chars`; }

function wireSummaryButtons(){
  const bAll = byId('btnCopyAll'); if(bAll) bAll.addEventListener('click', copyAllSummaries);
  const dAll = byId('btnDownloadAll'); if(dAll) dAll.addEventListener('click', downloadAllSummaries);
  ['sumES','sumEN','sumIT'].forEach(id=>{ const el=byId(id); if(!el) return; el.addEventListener('click', ()=> el.focus()); updateSummaryMeta(id); });
}

// Ensure buttons wired on DOMContentLoaded
window.addEventListener('DOMContentLoaded', ()=>{ wireSummaryButtons(); });

function onPatientSelected(sel){ if(!sel || !sel.value) return; sel.dataset.last = sel.value; loadPatient(); }

/* ===== PV Loop quick-times menu (select timepoints rapidly) ===== */
function refreshPVTimesMenu(){
  const menu = byId('pvTimesMenu'); if(!menu) return;
  menu.innerHTML = '';
  const cards = Array.from(document.querySelectorAll('.tpCard'));
  if(!cards.length){ menu.innerHTML = '<div class="small">No timepoints</div>'; return; }

  // Header row with compact actions
  const header = document.createElement('div'); header.style.display='flex'; header.style.justifyContent='space-between'; header.style.alignItems='center'; header.style.marginBottom='8px';
  const title = document.createElement('div'); title.style.fontWeight='700'; title.textContent = 'Timepoints';
  header.appendChild(title);
  menu.appendChild(header);

  // Scroll list
  const list = document.createElement('div'); list.style.maxHeight='260px'; list.style.overflow='auto'; list.style.paddingRight='6px';
  cards.forEach((card,i)=>{
    const timeVal = byId(`t_time_${i}`)?.value || `T${i}`;
    // Prefer numeric hour when possible: show '0', '6', '12', etc.
    let timeLabel = timeVal.toString();
    const parsed = parseFloat(timeVal);
    if(Number.isFinite(parsed)) timeLabel = String(parsed);
    const row = document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.justifyContent='space-between'; row.style.gap='8px'; row.style.padding='8px 0'; row.style.borderBottom='1px solid #f1f6ff';
    const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center'; left.style.gap='10px';
    const cb = document.createElement('input'); cb.type='checkbox'; cb.style.transform='scale(1.05)';
    const onChk = byId(`t_on_${i}`);
    cb.checked = !!(onChk && onChk.checked);
  cb.addEventListener('change', ()=>{ if(onChk) onChk.checked = cb.checked; updatePVOnly(); try{ updateFirstLastShade(); }catch(e){} });
    const txt = document.createElement('div'); txt.textContent = timeLabel; txt.style.minWidth='90px'; txt.style.fontWeight='600';
    left.appendChild(cb); left.appendChild(txt);

    // per-row Active button (sets this timepoint as active)
    const right = document.createElement('div'); right.style.display='flex'; right.style.alignItems='center';
    const btnRowActive = document.createElement('button'); btnRowActive.className='btn'; btnRowActive.textContent='Active'; btnRowActive.title = `Set timepoint ${timeLabel} active`;
    // apply shading if this timepoint is active
    const rd = byId(`t_active_${i}`);
    const applyShade = (on)=>{
      if(on){ btnRowActive.style.background = '#1f6fff'; btnRowActive.style.color = '#fff'; btnRowActive.style.borderColor = '#1f6fff'; }
      else { btnRowActive.style.background = ''; btnRowActive.style.color = ''; btnRowActive.style.borderColor = ''; }
    };
    if(rd && rd.checked) applyShade(true);
    if(rd) rd.addEventListener('change', ()=>{ applyShade(!!rd.checked); });
    btnRowActive.onclick = ()=>{
      try{
        if(rd) rd.checked = true;
        // Prefer the shared setter which updates global state, regenerates plots and refreshes clinic
        if(typeof setActiveIndex === 'function'){
          try{ setActiveIndex(i); }catch(e){}
        } else {
          applyShade(true);
          try{ generateAll(); }catch(e){}
        }
      }catch(e){}
      try{ refreshPVTimesMenu(); }catch(e){}
    };
    right.appendChild(btnRowActive);

    row.appendChild(left); row.appendChild(right);
    list.appendChild(row);
  });
  menu.appendChild(list);
  try{ updateFirstLastShade(); }catch(e){}

  // Footer compact sets
  const foot = document.createElement('div'); foot.style.display='flex'; foot.style.justifyContent='space-between'; foot.style.marginTop='10px';
  const leftF = document.createElement('div'); leftF.style.display='flex'; leftF.style.gap='6px';
  const fl = document.createElement('button'); fl.className='btn primary'; fl.textContent='First & Last'; fl.onclick = ()=>{ const n=cards.length; if(n===0) return; cards.forEach((c,i)=>{ const ch=byId(`t_on_${i}`); if(!ch) return; ch.checked = (i===0 || i===n-1); }); updatePVOnly(); generateAll(); updateFirstLastShade(); };
  leftF.appendChild(fl);
  // Right-side footer: Active all button only
  const rightF = document.createElement('div'); rightF.style.display='flex'; rightF.style.gap='6px';
  const bActiveAll = document.createElement('button'); bActiveAll.className='btn'; bActiveAll.textContent='Active all'; bActiveAll.title='Show all timepoints and set last active';
  bActiveAll.onclick = ()=>{
    const n = cards.length; if(n===0) return;
    cards.forEach((c,i)=>{ const ch = byId(`t_on_${i}`); if(ch) ch.checked = true; });
    const last = n-1;
    // Prefer shared setter so dashboard/clinic state stays in sync
    try{ if(typeof setActiveIndex === 'function'){ setActiveIndex(last); } else { const rd = byId(`t_active_${last}`); if(rd) rd.checked = true; updatePVOnly(); generateAll(); } }catch(e){ try{ const rd = byId(`t_active_${last}`); if(rd) rd.checked = true; updatePVOnly(); generateAll(); }catch(_){} }
    try{ refreshPVTimesMenu(); }catch(e){}
  };
  rightF.appendChild(bActiveAll);
  foot.appendChild(leftF); foot.appendChild(rightF);
  
  // helper: update shading of First & Last button when first and last are checked
  function updateFirstLastShade(){
    const n = cards.length; if(n===0) { fl.style.background=''; fl.style.color=''; fl.style.borderColor=''; return; }
    const firstChk = byId(`t_on_0`); const lastChk = byId(`t_on_${n-1}`);
    const both = firstChk && lastChk && firstChk.checked && lastChk.checked;
    if(both){ fl.style.background = '#1f6fff'; fl.style.color = '#fff'; fl.style.borderColor = '#1f6fff'; }
    else { fl.style.background = ''; fl.style.color = ''; fl.style.borderColor = ''; }
  }
  menu.appendChild(foot);
  try{ updateFirstLastShade(); }catch(e){}
}

// Ensure a popover stays within the viewport horizontally (align to right when it would overflow)
function adjustPopoverPosition(menu){
  if(!menu) return;
  try{
    // clear any previous explicit positioning so measurements are consistent
    menu.style.left = menu.style.left || menu.style.left;
    menu.style.right = '';
    // run after layout to get correct size
    setTimeout(()=>{
      try{
        const r = menu.getBoundingClientRect();
        const margin = 8;
        // If the menu overflows to the right, align it to the right edge of its positioned parent
        if(r.right > (window.innerWidth - margin)){
          menu.style.left = 'auto';
          menu.style.right = '0px';
        }
        // If the menu is too far left (near the viewport left edge), nudge it right
        else if(r.left < margin){
          // position with a small left offset from the positioned parent
          menu.style.left = Math.max(margin - (menu.parentElement?.getBoundingClientRect().left || 0), 6) + 'px';
          menu.style.right = '';
        } else {
          // otherwise keep default (left:0 assumed in markup)
          // no-op
        }
      }catch(e){}
    },0);
  }catch(e){}
}

// Toggle menu visibility and close on outside click
byId('btnPVQuick')?.addEventListener('click', (e)=>{
  const menu = byId('pvTimesMenu'); if(!menu) return; const showing = menu.style.display !== 'none';
  if(showing){ menu.style.display='none'; }
  else { refreshPVTimesMenu(); menu.style.display='block'; try{ adjustPopoverPosition(menu); }catch(e){} }
});


// Keep menu in sync when timepoints change
const pvMenuObserver = new MutationObserver(()=>{ const menu = byId('pvTimesMenu'); if(menu && menu.style.display!=='none') refreshPVTimesMenu(); });
const tpWrap = byId('tpInputs'); if(tpWrap) pvMenuObserver.observe(tpWrap, { childList:true, subtree:true, attributes:true });

// Tab switching: show only the selected section and keep timepoints visible only on Dashboard
(function(){
  // Detect iOS/iPadOS (incl. iPadOS reporting as Mac) to optionally disable heavy editors
  // Robust iOS / touch detection: prefer UA checks for iPad/iPhone but fall back to
  // capability sniffing (maxTouchPoints / ontouchstart) for devices that report
  // desktop-like platform strings (e.g. iPadOS reporting as MacIntel).
  const IS_IOS_TOUCH = (()=>{
    try{
      const ua = navigator.userAgent || navigator.vendor || '';
      const iPad = /iPad/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      const iPhone = /iPhone|iPod/.test(ua);
      // capability sniffing: covers Windows/Chrome on touch laptops and newer iPadOS UA edge-cases
      const touchCapable = (typeof window !== 'undefined') && (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
      const result = !!(iPad || iPhone || touchCapable);
      try{ console.info('Device detection:', { IS_IOS_TOUCH: result, ua: ua, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints }); }catch(e){}
      return result;
    }catch(e){ return false; }
  })();
  function setActiveTab(tab){
    // On iPad, prevent switching to Alarms Builder
    let t = tab;
    if(IS_IOS_TOUCH && t==='alarms-builder'){ t='alarms'; try{ console.info('Alarms Builder disabled on iPad'); }catch(e){} }
    // toggle active class on header tabs (avoid the 2nd arg of toggle for older Safari/iPad)
    document.querySelectorAll('header .tabs .tab').forEach(b=>{
      if(b.dataset.tab===t) b.classList.add('active'); else b.classList.remove('active');
    });
    // show/hide sections reliably
    document.querySelectorAll('.section').forEach(s=>{
      if(s.id===`sec-${t}`) s.classList.add('active'); else s.classList.remove('active');
    });
    // show timepoints card only on dashboard
    const tpCard = byId('cardTimepoints'); if(tpCard) tpCard.style.display = (t==='dash') ? '' : 'none';
    // hide PV times menu when switching away
    const pvMenu = byId('pvTimesMenu'); if(pvMenu && t!=='dash') pvMenu.style.display='none';
  }

  // Attach click handlers to header tabs
  document.querySelectorAll('header .tabs .tab').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const tab = btn.dataset.tab || 'dash'; setActiveTab(tab);
      // regenerate plots when returning to dashboard to ensure layout is correct
      if(tab==='dash'){ try{ generateAll(); }catch(e){} }
    });
  });

  // Dropdown 'More' button handling
  const btnMore = byId('btnMore'); const moreMenu = byId('moreMenu');
  if(btnMore && moreMenu){
    // Hide "Alarms Builder" on iPad devices
    try{ if(IS_IOS_TOUCH){ const b = moreMenu.querySelector('button[data-tab="alarms-builder"]'); if(b){ b.style.display='none'; b.setAttribute('aria-hidden','true'); } const sec = byId('sec-alarms-builder'); if(sec){ sec.style.display='none'; } } }catch(e){}
    btnMore.addEventListener('click', (e)=>{
      const showing = moreMenu.style.display !== 'block';
      moreMenu.style.display = showing ? 'block' : 'none';
      btnMore.setAttribute('aria-expanded', showing? 'true' : 'false');
      e.stopPropagation();
    });
    // close menu when clicking outside (only if click is not inside the menu or the More button)
    document.addEventListener('click', (ev)=>{
      try{
        const target = ev.target;
        if(moreMenu.style.display==='block' && !moreMenu.contains(target) && target !== btnMore){
          moreMenu.style.display='none'; btnMore.setAttribute('aria-expanded','false');
        }
      }catch(e){}
    });
    // menu item clicks
    moreMenu.querySelectorAll('button[data-tab]').forEach(it=> it.addEventListener('click', (e)=>{
      // prevent the global click handler from interfering
      e.stopPropagation();
      const tab = it.dataset.tab; setActiveTab(tab);
      moreMenu.style.display='none'; btnMore.setAttribute('aria-expanded','false');
      if(tab==='dash'){ try{ generateAll(); }catch(e){} }
    }));
  }

  // Initialize visibility on load (use existing active tab if present)
  window.addEventListener('DOMContentLoaded', ()=>{
    const active = document.querySelector('header .tabs .tab.active');
    const tab = (active && active.dataset && active.dataset.tab) ? active.dataset.tab : 'dash';
    setActiveTab(tab);
  });
})();

/* ===== ALARMS BUILDER ===== */
let customAlarmRules = [];
let conditionCounter = 0;

// Persistencia automática usando localStorage
function saveAlarmsToStorage() {
  try {
    localStorage.setItem('pv-one-custom-alarms', JSON.stringify(customAlarmRules));
    
  } catch (error) {
    console.error('❌ Error saving alarms to localStorage:', error);
  }
}

function loadAlarmsFromStorage() {
  try {
    // First, try to extract alarms from the physical alarms.bundle.js file
    let rulesFromBundle = [];
    if (window.ALARM_RULES && Array.isArray(window.ALARM_RULES)) {
      window.ALARM_RULES.forEach(group => {
        if (group.items && Array.isArray(group.items)) {
          group.items.forEach(item => {
            // Convert bundle format to customAlarmRules format
            rulesFromBundle.push({
              id: Date.now() + Math.random(), // Generate unique ID
              name: item.label || item.id,
              tag: item.tag || item.id,
              severity: item.color,
              category: getCategoryFromSubtitle(group.subtitle),
              expression: item.expr,
              clinical: item.clinical,
              suggest: item.suggest,
              created: 'From bundle file'
            });
          });
        }
      });
    }
    
    // Then, load additional alarms from localStorage
    let rulesFromStorage = [];
    const stored = localStorage.getItem('pv-one-custom-alarms');
    if (stored) {
      rulesFromStorage = JSON.parse(stored);
    }
    
    // Merge both sources, avoiding duplicates by tag
    customAlarmRules = [...rulesFromBundle];
    rulesFromStorage.forEach(storageRule => {
      const existsInBundle = rulesFromBundle.some(bundleRule => bundleRule.tag === storageRule.tag);
      if (!existsInBundle) {
        customAlarmRules.push(storageRule);
      }
    });
    
    
    return customAlarmRules.length > 0;
  } catch (error) {
    console.error('❌ Error loading alarms:', error);
  }
  return false;
}

// Initialize custom alarms from alarms.bundle.js file
function initCustomAlarms() {
  try {
    if (typeof window.ALARM_RULES !== 'undefined' && Array.isArray(window.ALARM_RULES)) {
      
      
      // Convert from bundle format to internal format
      const externalAlarms = [];
      window.ALARM_RULES.forEach(group => {
        if (group.items && Array.isArray(group.items)) {
          group.items.forEach(item => {
            externalAlarms.push({
              id: Date.now() + Math.random(), // Generate unique ID
              name: item.label || item.id,
              tag: item.tag || item.id,
              severity: item.color,
              category: getCategoryFromSubtitle(group.subtitle),
              expression: item.expr,
              clinical: item.clinical,
              suggest: item.suggest,
              created: 'From bundle file'
            });
          });
        }
      });
      
      // Merge with existing localStorage alarms (avoid duplicates)
      const existingAlarms = customAlarmRules || [];
      const mergedAlarms = [...existingAlarms];
      
      externalAlarms.forEach(extAlarm => {
        // Check if this alarm already exists (by tag)
        const existingIndex = mergedAlarms.findIndex(existing => existing.tag === extAlarm.tag);
        if (existingIndex === -1) {
          // Add new alarm
          mergedAlarms.push(extAlarm);
          
        } else {
          // Update existing alarm with file content
          mergedAlarms[existingIndex] = { ...mergedAlarms[existingIndex], ...extAlarm };
          
        }
      });
      
      // Update global alarms and refresh UI
      customAlarmRules = mergedAlarms;
      saveAlarmsToStorage();
      renderAlarmRulesList();
      
      // Re-initialize alarm evaluators
      if (typeof initAlarmEvaluators === 'function') {
        initAlarmEvaluators();
      }
      
      
    } else {
      
    }
  } catch (error) {
    console.error('❌ Error initializing custom alarms from file:', error);
  }
}

// Helper function to determine category from bundle subtitle
function getCategoryFromSubtitle(subtitle) {
  if (!subtitle) return 'other';
  const lower = subtitle.toLowerCase();
  if (lower.includes('perfusion')) return 'perfusion';
  if (lower.includes('congestion')) return 'congestion';
  if (lower.includes('metabolic')) return 'metabolic';
  if (lower.includes('weaning')) return 'weaning';
  if (lower.includes('mcs')) return 'mcs';
  if (lower.includes('trend')) return 'trends';
  return 'other';
}

function clearAlarmsFromStorage() {
  try {
    localStorage.removeItem('pv-one-custom-alarms');
    localStorage.removeItem('pv-one-alarms-bundle-code');
    
  } catch (error) {
    console.error('❌ Error clearing alarms from localStorage:', error);
  }
}

function showAutoUpdateNotification(type) {
  // Remover notificación existente
  const existing = document.getElementById('auto-update-notification');
  if (existing) existing.remove();
  
  const notification = document.createElement('div');
  notification.id = 'auto-update-notification';
  notification.style.cssText = `
    position: fixed; top: 20px; right: 20px; z-index: 10000;
    border-radius: 8px; padding: 16px; max-width: 400px; 
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    font-family: system-ui, -apple-system, sans-serif; font-size: 14px;
    animation: slideIn 0.3s ease-out;
  `;
  
  if (type === 'success') {
    notification.style.background = '#d4edda';
    notification.style.border = '1px solid #c3e6cb';
    notification.style.color = '#155724';
    notification.innerHTML = `
      <div style="font-weight: bold; margin-bottom: 8px;">🎯 Automatic update completed</div>
      <div style="margin-bottom: 8px;">✅ Your alarms.bundle.js was updated automatically</div>
      <div style="font-size: 12px; opacity: 0.8;">
        • No manual replacement needed<br>
        • Alarms are active immediately<br>
        • Everything is automatic 🚀
      </div>
      <button onclick="this.parentElement.remove()" style="
        margin-top: 8px; padding: 4px 8px; border: 1px solid #c3e6cb; 
        background: white; border-radius: 4px; cursor: pointer; font-size: 12px;
  ">Got it</button>
    `;
  } else if (type === 'download') {
    notification.style.background = '#d1ecf1';
    notification.style.border = '1px solid #bee5eb';
    notification.style.color = '#0c5460';
    notification.innerHTML = `
      <div style="font-weight: bold; margin-bottom: 8px;">📁 File downloaded automatically</div>
      <div style="margin-bottom: 8px;">✅ alarms.bundle.js was downloaded to your Downloads folder</div>
      <div style="font-size: 12px; opacity: 0.8;">
        • Copy the file from Downloads<br>
        • Replace alarms.bundle.js in your project<br>
        • Alarms are already active in memory 🚀
      </div>
      <button onclick="this.parentElement.remove()" style="
        margin-top: 8px; padding: 4px 8px; border: 1px solid #bee5eb; 
        background: white; border-radius: 4px; cursor: pointer; font-size: 12px;
  ">OK</button>
    `;
  } else {
    notification.style.background = '#fff3cd';
    notification.style.border = '1px solid #ffeaa7';
    notification.style.color = '#856404';
    notification.innerHTML = `
      <div style="font-weight: bold; margin-bottom: 8px;">💾 Saved Alarms (Manual Update)</div>
      <div style="margin-bottom: 8px;">Alarms are active, but you need to:</div>
      <div style="font-size: 12px; opacity: 0.8;">
        • Use "Generate Bundle" to download the file<br>
        • Replace alarms.bundle.js manually<br>
        • Or run python save_bundle.py
      </div>
      <button onclick="this.parentElement.remove()" style="
        margin-top: 8px; padding: 4px 8px; border: 1px solid #ffeaa7; 
        background: white; border-radius: 4px; cursor: pointer; font-size: 12px;
      ">OK</button>
    `;
  }
  
  document.body.appendChild(notification);
  
  // Auto-remove after 8 seconds
  setTimeout(() => {
    if (notification.parentElement) {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(() => notification.remove(), 300);
    }
  }, 8000);
}

// Agregar CSS animations
if (!document.getElementById('auto-update-styles')) {
  const styles = document.createElement('style');
  styles.id = 'auto-update-styles';
  styles.textContent = `
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
  `;
  document.head.appendChild(styles);
}

async function updatePhysicalBundleFile() {
  try {
    // Obtener el código generado
    const bundleCode = localStorage.getItem('pv-one-alarms-bundle-code') || window.lastGeneratedAlarmCode;
    
    if (!bundleCode) {
      
      return;
    }

    // Método 1: Intentar usar File System Access API para guardar directamente
    if ('showSaveFilePicker' in window) {
      try {
        // Obtener referencia al archivo alarms.bundle.js
        let fileHandle = localStorage.getItem('pv-one-bundle-file-handle');
        
        if (!fileHandle) {
          // Primera vez - pedir al usuario que seleccione el archivo alarms.bundle.js
          const options = {
            suggestedName: 'alarms.bundle.js',
            types: [{
              description: 'JavaScript files',
              accept: { 'text/javascript': ['.js'] }
            }]
          };
          
          fileHandle = await window.showSaveFilePicker(options);
          // Guardar referencia para uso futuro (no funciona entre sesiones, pero útil durante la sesión)
        }
        
        // Escribir el archivo
        const writable = await fileHandle.createWritable();
        await writable.write(bundleCode);
        await writable.close();
        
        
        return true;
        
      } catch (err) {
        if (err.name === 'AbortError') {
          
          return false;
        }
        
      }
    }

    // Método 2: Intentar guardar usando fetch POST (para servidor Python local)
    try {
      const response = await fetch('/update-bundle', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          filename: 'alarms.bundle.js',
          content: bundleCode
        })
      });
      
      if (response.ok) {
        
        return true;
      }
    } catch (err) {
      
    }
    
    // Método 3: Instrucciones para el usuario
    
    
    
    
    
    // Mostrar notificación al usuario
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed; top: 20px; right: 20px; z-index: 10000;
      background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px;
      padding: 16px; max-width: 400px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, sans-serif; font-size: 14px;
    `;
    notification.innerHTML = `
      <div style="font-weight: bold; margin-bottom: 8px;">💾 Alarm Rules Updated!</div>
      <div style="margin-bottom: 8px;">Your alarm rules are active in memory, but to persist them:</div>
      <div style="font-size: 12px; color: #666;">
        • Check Downloads folder for updated alarms.bundle.js<br>
        • Replace the file in your project folder<br>
        • Or use "Generate Bundle" button for manual save
      </div>
      <button onclick="this.parentElement.remove()" style="
        margin-top: 8px; padding: 4px 8px; border: 1px solid #ddd; 
        background: white; border-radius: 4px; cursor: pointer; font-size: 12px;
      ">OK</button>
    `;
    document.body.appendChild(notification);
    
    // Auto-remove notification after 10 seconds
    setTimeout(() => {
      if (notification.parentElement) {
        notification.remove();
      }
    }, 10000);
    
  } catch (error) {
    console.error('❌ Error updating physical bundle file:', error);
  }
}

// Template definitions
const alarmTemplates = {
  hypoperfusion: {
    name: "Hypoperfusion Warning",
    tag: "hypoperfusion",
    severity: "warning",
    category: "metabolic",
  expression: "Lactate >= 2"
  },
  "severe-shock": {
    name: "Severe Cardiogenic Shock",
    tag: "severe_shock",
    severity: "critical", 
    category: "perfusion",
  expression: "CI < 2.2 && Lactate >= 5"
  },
  "rv-failure": {
    name: "RV Failure (Right Ventricular Failure)",
    tag: "RV_failure",
    severity: "critical",
    category: "congestion", 
    expression: "RAP >= 12 && PAPI < 1.85"
  },
  congestion: {
    name: "BiV Congestion (Biventricular Congestion)",
    tag: "BiV_congestion",
    severity: "warning",
    category: "congestion",
    expression: "RAP >= 12 && PCWP >= 18"
  },
  "impella-wean": {
    name: "Impella Wean Ready",
    tag: "impella_wean_ready",
    severity: "wean_ok",
    category: "weaning",
  expression: "Impella && Impella_flow_Lmin <= 1.0 && CountTrue([CI >= 2.0, svo2 >= 55, Lactate <= 2.5, pH >= 7.30]) >= 3 && MAP >= 65"
  },
  "metabolic-crisis": {
    name: "Metabolic Crisis",
    tag: "metabolic_crisis", 
    severity: "critical",
    category: "metabolic",
  expression: "pH <= 7.20 || Lactate >= 10"
  }
};

function initAlarmsBuilder() {
  // Add condition button
  byId('btnAddCondition')?.addEventListener('click', addCondition);
  
  // Advanced expression toggle
  byId('btnAddAdvanced')?.addEventListener('click', toggleAdvancedExpression);
  
  // Add alarm rule button
  byId('btnAddAlarm')?.addEventListener('click', addAlarmRule);
  
  // Validation button
  byId('btnValidateExpression')?.addEventListener('click', validateExpression);
  
  // Clear all button
  byId('btnClearAllAlarms')?.addEventListener('click', clearAllAlarms);
  
  // Generate bundle button
  byId('btnGenerateAlarms')?.addEventListener('click', generateAlarmsBundle);

  // Apply to disk (single-click write like Variable Builder)
  byId('btnApplyToDisk')?.addEventListener('click', applyAlarmsBundleToDisk);
  
  // Setup direct update button (ensure user gesture is preserved)
  byId('btnSetupDirectUpdate')?.addEventListener('click', async (e) => {
    
    
    // Prevent any default behavior
    e.preventDefault();
    e.stopPropagation();
    
    // Call setup function immediately in the same call stack
    await setupDirectFileAccess(e);
  });

  // Auto Writes toggle: load saved preference and wire handler
  try {
    const autoBtn = byId('btnToggleAutoWrites');
    const saved = localStorage.getItem('pv-one-auto-writes');
    if (saved === 'true') {
      window.allowAutoPhysicalWrites = true;
    } else {
      window.allowAutoPhysicalWrites = false;
    }
    if (autoBtn) {
      autoBtn.textContent = window.allowAutoPhysicalWrites ? '✅ Auto Writes: On' : '⚠️ Auto Writes: Off';
      autoBtn.addEventListener('click', ()=>{
        window.allowAutoPhysicalWrites = !window.allowAutoPhysicalWrites;
        localStorage.setItem('pv-one-auto-writes', window.allowAutoPhysicalWrites ? 'true' : 'false');
        autoBtn.textContent = window.allowAutoPhysicalWrites ? '✅ Auto Writes: On' : '⚠️ Auto Writes: Off';
        
      });
    }
  } catch(e){ console.warn('Auto writes toggle initialization failed', e); }
  
  // Multiple alarms buttons
  byId('btnShowMultipleAlarms')?.addEventListener('click', showMultipleAlarmsEditor);
  byId('btnHideMultipleAlarms')?.addEventListener('click', hideMultipleAlarmsEditor);
  byId('btnProcessMultipleAlarms')?.addEventListener('click', processMultipleAlarms);
  byId('btnValidateMultiple')?.addEventListener('click', validateMultipleAlarms);
  
  // Variable Builder button
  byId('btnAddVariable')?.addEventListener('click', addCustomVariable);
  
  // Setup Direct Update for Variables button
  byId('btnSetupVariablesDirect')?.addEventListener('click', async (e) => {
    
    e.preventDefault();
    e.stopPropagation();
    await setupVariablesDirectFileAccess(e);
  });
  
  // Multiple Variables event listeners (prevent duplicates)
  const btnShow = byId('btnShowMultipleVariables');
  const btnValidate = byId('btnValidateMultipleVariables');
  const btnProcess = byId('btnProcessMultipleVariables');
  const btnHide = byId('btnHideMultipleVariables');
  
  if (btnShow && !btnShow.dataset.listenerAdded) {
    btnShow.addEventListener('click', showMultipleVariablesEditor);
    btnShow.dataset.listenerAdded = 'true';
  }
  if (btnValidate && !btnValidate.dataset.listenerAdded) {
    btnValidate.addEventListener('click', validateMultipleVariables);
    btnValidate.dataset.listenerAdded = 'true';
  }
  if (btnProcess && !btnProcess.dataset.listenerAdded) {
    btnProcess.addEventListener('click', processMultipleVariables);
    btnProcess.dataset.listenerAdded = 'true';
  }
  if (btnHide && !btnHide.dataset.listenerAdded) {
    btnHide.addEventListener('click', hideMultipleVariablesEditor);
    btnHide.dataset.listenerAdded = 'true';
  }
  
  // Variables reference functionality
  initVariablesReference();
  
  // Initialize Variable Builder with delay to ensure variablesbuild.js is loaded
  setTimeout(() => {
    loadVariablesFromStorage();
    // Re-initialize custom variables from file after DOM is ready
    if (typeof window.CUSTOM_VARIABLES !== 'undefined') {
      initCustomVariables();
    }
  }, 100);
  
  // Reload bundle button (if present)
  const reloadBtn = byId('btnReloadBundle'); if (reloadBtn) reloadBtn.addEventListener('click', reloadAlarmsBundle);
  
  // Import/Export buttons (if present)
  const importBtn = byId('btnImportAlarms'); if (importBtn) importBtn.addEventListener('click', importAlarms);
  const exportBtn = byId('btnExportAlarms'); if (exportBtn) exportBtn.addEventListener('click', exportAlarms);
  
  // Template cards
  document.querySelectorAll('.template-card').forEach(card => {
    card.addEventListener('click', () => {
      const templateId = card.dataset.template;
      if (alarmTemplates[templateId]) {
        loadTemplate(alarmTemplates[templateId]);
      }
    });
  });
  
  // Auto-update preview when typing
  const inputs = ['alarmName', 'alarmTag', 'alarmSeverity', 'alarmCategory', 'advancedExpression'];
  inputs.forEach(id => {
    const el = byId(id);
    if (el) {
      el.addEventListener('input', updateExpressionPreview);
      el.addEventListener('change', updateExpressionPreview);
    }
  });
  
  // Add bidirectional sync for expression preview
  const expressionPreview = byId('expressionPreview');
  if (expressionPreview) {
    expressionPreview.addEventListener('input', function() {
      if (!isUpdatingPreview) {
        // When user edits directly, switch to advanced mode automatically
        const advancedContainer = byId('advancedExpressionContainer');
        const advancedInput = byId('advancedExpression');
        if (advancedContainer && advancedInput) {
          advancedContainer.style.display = 'block';
          byId('btnAddAdvanced').textContent = '📝 Simple Builder';
          advancedInput.value = this.value;
        }
      }
    });
  }
  
  // Listen for changes in condition builder
  document.addEventListener('change', (e) => {
    if (e.target.matches('.condition-variable, .condition-operator, .condition-value, .condition-logic')) {
      updateExpressionPreview();
    }
  });
  
  // Don't load alarms immediately - wait for bundle to load first
  
  
  // 💾 Cargar variables guardadas automáticamente (Firefox fix)
  if (loadVariablesFromStorage()) {
    renderCustomVariablesList();
    // Si hay variables guardadas, activarlas automáticamente
    if (customVariables.length > 0) {
      
      autoUpdateVariablesBundle().then(() => {
        
      }).catch(err => {
        console.error('❌ Error activating saved custom variables:', err);
      });
    }
  }
  
  // 🔥 Force reload bundle BEFORE loading alarms
  setTimeout(() => {
    
    
    // Force reload the alarms bundle file first
    const script = document.createElement('script');
    script.src = 'alarms.bundle.js?t=' + Date.now(); // Add timestamp to avoid cache
    script.onload = () => {
      
      
      
      // Initialize custom alarms from bundle first, then load from storage
      setTimeout(() => {
        // Initialize alarms from the bundle file
        if (typeof window.ALARM_RULES !== 'undefined') {
          initCustomAlarms();
        }
        
        if (loadAlarmsFromStorage()) {
          renderAlarmRulesList();
        }
        
        // Force render alarms reference
        if (typeof renderAlarmsReference === 'function') {
          renderAlarmsReference();
        }
      }, 300);
    };
    document.head.appendChild(script);
    
    // Update variable components
    if (typeof updateCustomVariablesInPanels === 'function') {
      updateCustomVariablesInPanels();
    }
    if (typeof updateCustomVariablesInDropdowns === 'function') {
      updateCustomVariablesInDropdowns();
    }
    
  }, 1000);
  
  updateExpressionPreview();
}

// Direct file system access (bypass CORS completely)
let alarmsBundleFileHandle = null;
let variablesBundleFileHandle = null;

async function updatePhysicalFileDirectly(filename, content) {
  try {
    // Check if browser supports File System Access API
    if (!window.showOpenFilePicker || !window.showSaveFilePicker) {
      
      return false;
    }

    // If we don't have a handle yet, get one
    if (!alarmsBundleFileHandle) {
      try {
        // Try to pick the specific alarms.bundle.js file
        [alarmsBundleFileHandle] = await window.showOpenFilePicker({
          types: [{
            description: 'JavaScript files',
            accept: {
              'text/javascript': ['.js']
            }
          }],
          startIn: 'desktop'
        });
        
        // Verify it's the right file
        const file = await alarmsBundleFileHandle.getFile();
        if (!file.name.includes('alarms.bundle')) {
          
          alarmsBundleFileHandle = null;
          return false;
        }
        
        
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Error selecting file:', err);
        }
        return false;
      }
    }

    // Check if we have write permission
    const permission = await alarmsBundleFileHandle.queryPermission({ mode: 'readwrite' });
    if (permission !== 'granted') {
      const requestResult = await alarmsBundleFileHandle.requestPermission({ mode: 'readwrite' });
      if (requestResult !== 'granted') {
        
        alarmsBundleFileHandle = null;
        return false;
      }
    }

    // Write the new content
    const writable = await alarmsBundleFileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    
    return true;

  } catch (error) {
    console.error('❌ Error updating physical file:', error);
    // Reset handle on error
    alarmsBundleFileHandle = null;
    return false;
  }
}

// Setup direct file access to bypass CORS
async function setupDirectFileAccess(event) {
  // Ensure this is called from a user gesture
  if (event) {
    event.preventDefault();
    event.stopPropagation();
  }
  
  try {
    // Check if browser supports File System Access API
    if (!window.showOpenFilePicker || !window.showSaveFilePicker) {
      alert('❌ Your browser doesn\'t support direct file access.\n\nPlease use Chrome, Edge, or another Chromium-based browser for this feature.\n\nAlternatively, use the "Generate Bundle" button to download files manually.');
      return;
    }

    // Show instructions dialog with immediate action
    const proceed = confirm(`🔧 Setup Direct File Update\n\nThis will select your alarms.bundle.js file to enable automatic updates without CORS restrictions.\n\nPath: C:\\Users\\jorge\\Desktop\\PV-one V1.3.1.1\\alarms.bundle.js\n\nClick OK to open file picker now!`);
    
    if (!proceed) {
      
      return;
    }

    // Immediately try to get file handle while user gesture is active
    try {
      
      
      // Add small delay to ensure confirm dialog is closed
      await new Promise(resolve => setTimeout(resolve, 100));
      
      const [fileHandle] = await window.showOpenFilePicker({
        types: [{
          description: 'JavaScript Bundle Files',
          accept: {
            'text/javascript': ['.js']
          }
        }],
        startIn: 'desktop',
        multiple: false,
        excludeAcceptAllOption: false
      });

      // Verify it's the right file
      const file = await fileHandle.getFile();
      if (!file.name.includes('alarms.bundle')) {
        alert(`❌ Wrong file selected!\n\nYou selected: ${file.name}\nPlease select: alarms.bundle.js`);
        return;
      }

      // Request write permission
      const permission = await fileHandle.queryPermission({ mode: 'readwrite' });
      let hasPermission = permission === 'granted';
      
      if (!hasPermission) {
        const requestResult = await fileHandle.requestPermission({ mode: 'readwrite' });
        hasPermission = requestResult === 'granted';
      }

      if (!hasPermission) {
        alert('❌ Write permission denied!\n\nDirect file updates require write permission. You can still use the "Generate Bundle" button to download files manually.');
        return;
      }

      // Store the handle globally
      alarmsBundleFileHandle = fileHandle;

      // Update button appearance to show success
      const btn = byId('btnSetupDirectUpdate');
      if (btn) {
        btn.style.background = '#28a745';
        btn.style.color = 'white';
        btn.innerHTML = '✅ Direct Update Ready';
        btn.title = `Direct update setup complete for: ${file.name}`;
      }

      alert(`✅ Direct File Access Setup Complete!\n\nFile: ${file.name}\nPath: ${file.webkitRelativePath || 'Selected file'}\n\nFrom now on, all alarm changes will automatically update your physical file without downloads!`);

      // Verify we can read the selected file (do NOT write during setup to avoid file-watch reloads)
      
      try {
        const fileContent = await file.text();
        
        
      } catch (readErr) {
        console.warn('⚠️ Could not read selected file during setup (read-only test failed):', readErr);
        // Do not abort setup; we still keep the handle for future writes if permissions allow
      }

    } catch (err) {
      if (err.name === 'AbortError') {
        
        alert('Setup cancelled. You can try again or use the "Generate Bundle" button for manual downloads.');
      } else if (err.name === 'SecurityError') {
        console.error('🔒 Security error:', err);
        alert('❌ Security Error: File System Access API requires a secure context.\n\nTry:\n1. Using HTTPS or localhost\n2. Using Chrome/Edge browser\n3. Using "Generate Bundle" for manual downloads');
      } else if (err.message.includes('user gesture') || err.message.includes('showOpenFilePicker')) {
        console.error('👆 User gesture or API error:', err);
        alert('❌ File System Access API Error\n\nThis might be due to:\n• Browser security restrictions\n• Popup blockers\n• Unsupported browser version\n\nTry:\n1. Using Chrome/Edge (latest version)\n2. Disabling popup blockers\n3. Using "Generate Bundle" for manual downloads');
        
        // Try alternative method
        tryAlternativeFileMethod();
      } else {
        console.error('❌ Setup error:', err);
        alert(`❌ Setup Failed: ${err.message}\n\nError type: ${err.name}\n\nYou can still use the "Generate Bundle" button to download files manually.`);
      }
    }

  } catch (error) {
    console.error('❌ Setup error:', error);
    alert(`❌ Setup Error: ${error.message}\n\nPlease try again or use the "Generate Bundle" button for manual downloads.`);
  }
}

// Generate alarm bundle content (helper function for direct file updates)
function generateAlarmsBundleContent(alarmRules) {
  if (!alarmRules || alarmRules.length === 0) {
    return `/***********************
 * CUSTOM ALARM RULES GENERATED BY ALARMS BUILDER
 * Generated on: ${new Date().toLocaleString()}
 * Total rules: 0
 ***********************/

// No custom alarm rules defined
window.ALARM_RULES = [];

`;
  }

  // Support two input shapes:
  // 1) grouped form: [ { subtitle: '...', items: [ {expr,...}, ... ] }, ... ]
  // 2) flat list form: [ { expression/expr, severity/color, category, ... }, ... ]
  const groupsOut = [];

  if (alarmRules.length && alarmRules[0] && Array.isArray(alarmRules[0].items)) {
    // Input already grouped - preserve subtitles and items (filter empty placeholders)
    alarmRules.forEach(g => {
      const items = (g.items || []).map(it => ({
        expr: it.expression || it.expr || '',
        color: it.severity || it.color || '',
        tag: it.tag || '',
        label: it.name || it.label || '',
        id: it.id || it.tag || '',
        clinical: it.clinical || '',
        suggest: it.suggest || ''
      })).filter(it => it.expr || it.label || it.id);
      if (items.length) groupsOut.push({ subtitle: g.subtitle || 'Custom Rules', items });
    });
  } else {
    // Flat list - group by category
    const groupedRules = {};
    alarmRules.forEach(rule => {
      const key = (rule.category || 'Custom Rules').toString();
      if (!groupedRules[key]) groupedRules[key] = [];
      const obj = {
        expr: rule.expression || rule.expr || '',
        color: rule.severity || rule.color || '',
        tag: rule.tag || '',
        label: rule.name || rule.label || '',
        id: rule.id || rule.tag || '',
        clinical: rule.clinical || '',
        suggest: rule.suggest || ''
      };
      if (!obj.expr && !obj.label && !obj.id) return; // skip empty placeholders
      groupedRules[key].push(obj);
    });
    Object.keys(groupedRules).forEach(k => { if (groupedRules[k].length) groupsOut.push({ subtitle: k, items: groupedRules[k] }); });
  }

  // Compute total rules and header
  const totalRules = groupsOut.reduce((s, g) => s + (g.items ? g.items.length : 0), 0);
  let jsCode = `/***********************\n * CUSTOM ALARM RULES GENERATED BY ALARMS BUILDER\n * Generated on: ${new Date().toLocaleString()}\n * Total rules: ${totalRules}\n ***********************/\n\nwindow.ALARM_RULES = [`;

  function literalFor(r){
    const esc = (v, def='') => (v===undefined || v===null ? def : String(v).replace(/"/g, '\\"'));
    const expr = esc(r.expr, '');
    const color = esc(r.color, '');
    const tag = esc(r.tag, '');
    const label = esc(r.label, '');
    const id = esc(r.id, '');
    const clinical = esc(r.clinical, 'Custom alarm rule');
    const suggest = esc(r.suggest, 'Monitor patient status');
    return `    { expr: "${expr}", color: "${color}", tag: "${tag}", label: "${label}", id: "${id}", clinical: "${clinical}", suggest: "${suggest}" }`;
  }

  // Append groups preserving subtitles
  groupsOut.forEach(g => {
    const title = (g.subtitle || 'Custom Rules').toString();
    jsCode += `\n  { subtitle: "${title}", items: [\n`;
    jsCode += (g.items || []).map(literalFor).join(',\n');
    jsCode += `\n  ]},\n`;
  });

  jsCode += `\n];\n\n`;

  // Initialization block (preserve previous behavior)
  jsCode += `// Initialize alarm evaluators when rules are loaded\ntry {\n  if (typeof initAlarmEvaluators === 'function') {\n    initAlarmEvaluators();\n  }\n  if (typeof renderAlarmsReference === 'function') {\n    renderAlarmsReference();\n  }\n  if (typeof generateAll === 'function') {\n    generateAll();\n  }\n} catch(e) {\n  console.error('Error initializing custom alarm rules:', e);\n}`;

  return jsCode;
}

// Alternative method for browsers that block File System Access API
function tryAlternativeFileMethod() {
  const proceed = confirm('🔄 Alternative Setup Method\n\nThe direct file access method failed. Would you like to try an alternative approach?\n\nThis will:\n1. Create a hidden file input\n2. Let you select your alarms.bundle.js file\n3. Enable read access (write still requires manual download)\n\nProceed?');
  
  if (!proceed) return;
  
  // Create hidden file input
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.js';
  input.style.display = 'none';
  
  input.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file && file.name.includes('alarms.bundle')) {
      alert(`✅ File Selected: ${file.name}\n\nNote: Due to browser security, automatic file updates are not possible with this method. You'll need to use "Generate Bundle" to download updated files.`);
      
      // Update button to show alternative mode
      const btn = byId('btnSetupDirectUpdate');
      if (btn) {
        btn.style.background = '#ffc107';
        btn.style.color = '#212529';
        btn.innerHTML = '⚠️ Manual Mode';
        btn.title = 'Alternative mode active - use Generate Bundle for updates';
      }
    } else {
      alert('❌ Please select the alarms.bundle.js file');
    }
    
    // Remove the input
    document.body.removeChild(input);
  });
  
  document.body.appendChild(input);
  input.click();
}

// ============== VARIABLES DIRECT FILE UPDATE FUNCTIONS ==============

// Setup direct file access for Variables to bypass CORS
async function setupVariablesDirectFileAccess(event) {
  if (event) {
    event.preventDefault();
    event.stopPropagation();
  }
  
  try {
    // Check if browser supports File System Access API
    if (!window.showOpenFilePicker || !window.showSaveFilePicker) {
      alert('❌ Your browser doesn\'t support direct file access.\n\nPlease use Chrome, Edge, or another Chromium-based browser for this feature.\n\nAlternatively, use manual file downloads.');
      return;
    }

    // Show instructions dialog with immediate action
    const proceed = confirm(`🔧 Setup Variables Direct File Update\n\nThis will select your lib/variablesbuild.js file to enable automatic updates without CORS restrictions.\n\nPath: C:\\Users\\jorge\\Desktop\\PV-one V1.3.1.1\\lib\\variablesbuild.js\n\nClick OK to open file picker now!`);
    
    if (!proceed) {
      
      return;
    }

    // Immediately try to get file handle while user gesture is active
    try {
      
      
      await new Promise(resolve => setTimeout(resolve, 100));
      
      const [fileHandle] = await window.showOpenFilePicker({
        types: [{
          description: 'JavaScript Files',
          accept: {
            'text/javascript': ['.js']
          }
        }],
        startIn: 'desktop',
        multiple: false,
        excludeAcceptAllOption: false
      });

      // Verify it's the right file
      const file = await fileHandle.getFile();
      if (!file.name.includes('variablesbuild')) {
        alert(`❌ Wrong file selected!\n\nYou selected: ${file.name}\nPlease select: variablesbuild.js`);
        return;
      }

      // Request write permission
      const permission = await fileHandle.queryPermission({ mode: 'readwrite' });
      let hasPermission = permission === 'granted';
      
      if (!hasPermission) {
        const requestResult = await fileHandle.requestPermission({ mode: 'readwrite' });
        hasPermission = requestResult === 'granted';
      }

      if (!hasPermission) {
        alert('❌ Write permission denied!\n\nDirect file updates require write permission for variables.');
        return;
      }

      // Store the handle globally
      variablesBundleFileHandle = fileHandle;

      // Update button appearance to show success
      const btn = byId('btnSetupVariablesDirect');
      if (btn) {
        btn.style.background = '#28a745';
        btn.style.color = 'white';
        btn.innerHTML = '✅ Variables Direct Update Ready';
        btn.title = `Variables direct update setup complete for: ${file.name}`;
      }

      alert(`✅ Variables Direct File Access Setup Complete!\n\nFile: ${file.name}\nPath: ${file.webkitRelativePath || 'Selected file'}\n\nFrom now on, all variable changes will automatically update your physical file without downloads!`);

      // Test the connection with current variables
      
      const currentVariables = Object.keys(window.CUSTOM_VARIABLES || {}).map(name => ({
        name,
        expression: window.CUSTOM_VARIABLES[name].expression,
        description: window.CUSTOM_VARIABLES[name].description || ''
      }));
      
      const testContent = generateVariablesBundleContent(currentVariables);
      const success = await updateVariablesPhysicalFile('lib/variablesbuild.js', testContent);
      
      if (success) {
        
      } else {
        console.warn('⚠️ Variables direct file access test failed, but setup is complete.');
      }

    } catch (err) {
      if (err.name === 'AbortError') {
        
        alert('Variables setup cancelled. You can try again later.');
      } else if (err.name === 'SecurityError') {
        console.error('🔒 Variables security error:', err);
        alert('❌ Security Error: File System Access API requires a secure context for variables.\n\nTry using Chrome/Edge browser.');
      } else if (err.message.includes('user gesture') || err.message.includes('showOpenFilePicker')) {
        console.error('👆 Variables user gesture or API error:', err);
        alert('❌ Variables File System Access API Error\n\nTry using Chrome/Edge (latest version) and disable popup blockers.');
      } else {
        console.error('❌ Variables setup error:', err);
        alert(`❌ Variables Setup Failed: ${err.message}\n\nError type: ${err.name}`);
      }
    }

  } catch (error) {
    console.error('❌ Variables setup error:', error);
    alert(`❌ Variables Setup Error: ${error.message}\n\nPlease try again later.`);
  }
}

// Update variables physical file directly
async function updateVariablesPhysicalFile(filename, content) {
  try {
    if (!variablesBundleFileHandle) {
      
      return false;
    }

    // Check if we have write permission
    const permission = await variablesBundleFileHandle.queryPermission({ mode: 'readwrite' });
    if (permission !== 'granted') {
      const requestResult = await variablesBundleFileHandle.requestPermission({ mode: 'readwrite' });
      if (requestResult !== 'granted') {
        
        variablesBundleFileHandle = null;
        return false;
      }
    }

    // Write the new content
    const writable = await variablesBundleFileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    
    return true;

  } catch (error) {
    console.error('❌ Error updating variables physical file:', error);
    variablesBundleFileHandle = null;
    return false;
  }
}

// Generate variables bundle content
function generateVariablesBundleContent(variables) {
  if (!variables || variables.length === 0) {
    return `/***********************
 * CUSTOM VARIABLES GENERATED BY VARIABLE BUILDER
 * Generated on: ${new Date().toLocaleString()}
 * Total variables: 0
 ***********************/

// No custom variables defined
window.CUSTOM_VARIABLES = {};

`;
  }

  let jsCode = `/***********************
 * CUSTOM VARIABLES GENERATED BY VARIABLE BUILDER
 * Generated on: ${new Date().toLocaleString()}
 * Total variables: ${variables.length}
 ***********************/

window.CUSTOM_VARIABLES = {`;

  variables.forEach((variable, index) => {
    const comma = index < variables.length - 1 ? ',' : '';
    jsCode += `
  "${variable.name}": {
    expression: "${variable.expression.replace(/"/g, '\\"')}",
    description: "${(variable.description || '').replace(/"/g, '\\"')}"
  }${comma}`;
  });

  jsCode += `
};
`;

  return jsCode;
}

function addCondition() {
  conditionCounter++;
  const container = byId('conditionsContainer');
  if (!container) return;
  
  const conditionRow = document.createElement('div');
  conditionRow.className = 'condition-row';
  conditionRow.dataset.condition = conditionCounter;
  
  conditionRow.innerHTML = `
    <div class="row" style="align-items:center;margin-bottom:8px">
      <select class="condition-variable" style="width:120px">
        <option value="">Select Variable</option>
        <option value="HR">HR</option>
        <option value="SBP">SBP</option>
        <option value="DBP">DBP</option>
        <option value="MAP">MAP</option>
        <option value="ESP">ESP</option>
        <option value="sPAP">sPAP</option>
        <option value="dPAP">dPAP</option>
        <option value="PCWP">PCWP</option>
        <option value="RAP">RAP</option>
        <option value="CO">CO</option>
        <option value="CI">CI</option>
        <option value="SVI">SVI</option>
        <option value="LVEF">LVEF</option>
        <option value="EDV">EDV</option>
        <option value="ESV">ESV</option>
        <option value="Ea">Ea</option>
        <option value="Ees">Ees</option>
        <option value="VAC">VAC</option>
        <option value="CPO">CPO</option>
        <option value="CPI">CPI</option>
        <option value="SVR">SVR</option>
        <option value="PVR_WU">PVR (WU)</option>
        <option value="PAPI">PAPI</option>
  <option value="Lactate">Lactate</option>
        <option value="Lactate">Lactate</option>
        <option value="pH">pH</option>
        <option value="ALT">ALT</option>
        <option value="SvO2">SvO2</option>
        <option value="svo2">SvO2</option>
        <option value="creatinine">Creatinine</option>
        <option value="LVIS">LVIS</option>
        <option value="Stage">SCAI Stage</option>
        <option value="IABP">IABP</option>
        <option value="Impella">Impella</option>
        <option value="ECMO">ECMO</option>
        <option value="VAD">VAD</option>
        <option value="On_IABP">On IABP</option>
        <option value="On_Impella">On Impella</option>
        <option value="On_ECMO">On ECMO</option>
        <option value="Impella_flow_Lmin">Impella Flow</option>
        <option value="Dobut">Dobutamine</option>
        <option value="Dopa">Dopamine</option>
        <option value="Norepi">Norepinephrine</option>
        <option value="Milrinone">Milrinone</option>
        <option value="Epi">Epinephrine</option>
        <option value="Vasopressin">Vasopressin</option>
        <option value="Levosimendan">Levosimendan</option>
      </select>
      
      <select class="condition-operator" style="width:80px;margin-left:8px">
        <option value="">Op</option>
        <option value=">">></option>
        <option value=">=">≥</option>
        <option value="<"><</option>
        <option value="<=">≤</option>
        <option value="==">=</option>
        <option value="!=">≠</option>
      </select>
      
      <input type="text" class="condition-value" placeholder="Value" style="width:100px;margin-left:8px">
      
      <select class="condition-logic" style="width:60px;margin-left:8px">
        <option value="">End</option>
        <option value="&&">AND</option>
        <option value="||">OR</option>
      </select>
      
      <button class="btn" onclick="removeCondition(this)" style="margin-left:8px">🗑️</button>
    </div>
  `;
  
  container.appendChild(conditionRow);
  
  // Update the newly added dropdown with custom variables
  updateCustomVariablesInDropdowns();
  
  updateExpressionPreview();
}

function removeCondition(button) {
  const conditionRow = button.closest('.condition-row');
  if (conditionRow) {
    conditionRow.remove();
    updateExpressionPreview();
  }
}

function toggleAdvancedExpression() {
  const container = byId('advancedExpressionContainer');
  if (!container) return;
  
  const isVisible = container.style.display !== 'none';
  container.style.display = isVisible ? 'none' : 'block';
  byId('btnAddAdvanced').textContent = isVisible ? '⚙️ Advanced Expression' : '📝 Simple Builder';
  
  updateExpressionPreview();
}

// Variable to prevent infinite loops during sync
let isUpdatingPreview = false;

function updateExpressionPreview() {
  if (isUpdatingPreview) return; // Prevent infinite loops
  
  const preview = byId('expressionPreview');
  if (!preview) return;
  
  const advancedContainer = byId('advancedExpressionContainer');
  const isAdvancedMode = advancedContainer && advancedContainer.style.display !== 'none';
  
  isUpdatingPreview = true;
  
  if (isAdvancedMode) {
    // Use advanced expression
    const advancedExpr = byId('advancedExpression')?.value || '';
    preview.value = advancedExpr || '(empty expression)';
  } else {
    // Build expression from conditions
    const conditions = Array.from(document.querySelectorAll('.condition-row'));
    const parts = [];
    
    conditions.forEach((row, index) => {
      const variable = row.querySelector('.condition-variable')?.value;
      const operator = row.querySelector('.condition-operator')?.value;
      const value = row.querySelector('.condition-value')?.value;
      const logic = row.querySelector('.condition-logic')?.value;
      
      if (variable && operator && value) {
        let condition = `${variable} ${operator} ${value}`;
        
        // Handle special cases
        if (operator === '==' && value.includes("'")) {
          condition = `${variable} ${operator} ${value}`;
        } else if (operator === '==' && isNaN(parseFloat(value))) {
          condition = `${variable} ${operator} '${value}'`;
        }
        
        parts.push(condition);
        
        if (logic && index < conditions.length - 1) {
          parts.push(logic === '&&' ? ' AND ' : ' OR ');
        }
      }
    });
    
    preview.value = parts.join('') || '(no conditions defined)';
  }
  
  isUpdatingPreview = false;
}

function validateExpression() {
  const result = byId('validationResult');
  if (!result) return;
  
  try {
    const expression = getExpressionText();
    if (!expression || expression.trim() === '' || expression === '(empty expression)' || expression === '(no conditions defined)') {
      result.innerHTML = '<span class="validation-error">⚠️ Empty expression</span>';
      return;
    }
    
    // Basic syntax validation
    if (expression.includes('undefined') || expression.includes('null')) {
      result.innerHTML = '<span class="validation-error">⚠️ Invalid values detected</span>';
      return;
    }
    
    // Try to compile (basic test)
    if (typeof compileAlarmExpr === 'function') {
      const compiled = compileAlarmExpr(expression);
      if (compiled && typeof compiled === 'function') {
        result.innerHTML = '<span class="validation-success">✅ Expression is valid</span>';
      } else {
        result.innerHTML = '<span class="validation-error">❌ Failed to compile expression</span>';
      }
    } else {
      result.innerHTML = '<span class="validation-success">✅ Syntax appears valid</span>';
    }
  } catch (error) {
    result.innerHTML = `<span class="validation-error">❌ Error: ${error.message}</span>`;
  }
}

function getExpressionText() {
  const advancedContainer = byId('advancedExpressionContainer');
  const isAdvancedMode = advancedContainer && advancedContainer.style.display !== 'none';
  
  if (isAdvancedMode) {
    return byId('advancedExpression')?.value || '';
  } else {
    return byId('expressionPreview')?.value || '';
  }
}

async function addAlarmRule() {
  const name = byId('alarmName')?.value?.trim();
  const tag = byId('alarmTag')?.value?.trim();  
  const severity = byId('alarmSeverity')?.value;
  const category = byId('alarmCategory')?.value;
  const expression = getExpressionText();
  const clinical = byId('clinicalWording')?.value?.trim();
  const suggest = byId('suggestedActions')?.value?.trim();
  
  if (!name) {
    alert('Please enter a rule name');
    return;
  }
  
  if (!expression || expression === '(no conditions defined)' || expression === '(empty expression)') {
    alert('Please define an expression or conditions');
    return;
  }
  
  // Check if we're in edit mode (support numeric ids and string/tag ids)
  const addButton = byId('btnAddAlarm');
  const editingMarker = addButton?.dataset?.editingId;
  if (editingMarker) {
    // Normalize editing identifier
    const editingId = (typeof editingMarker === 'string' && editingMarker.match(/^\d+$/)) ? Number(editingMarker) : editingMarker;

    // Find rule either by numeric id, by string id, or by tag
    const rule = customAlarmRules.find(r => r.id === editingId || String(r.id) === String(editingId) || r.tag === editingId || String(r.tag) === String(editingId));
    if (rule) {
      rule.name = name;
      rule.tag = tag || name.toLowerCase().replace(/\s+/g, '_');
      rule.severity = severity;
      rule.category = category;
      rule.expression = expression;
      rule.clinical = clinical || undefined;
      rule.suggest = suggest || undefined;
      // keep original created timestamp
    }

    // Persist changes and refresh UI
    saveAlarmsToStorage();
    renderAlarmRulesList();
    clearForm();

    // Clear edit state and restore add button UI
    if (addButton) {
      delete addButton.dataset.editingId;
      addButton.textContent = '➕ Add Alarm Rule';
      addButton.style.background = '';
    }

    // Show success and auto-update
    const vrEl = byId('validationResult');
    if (vrEl) vrEl.innerHTML = '<span class="validation-success">✅ Alarm rule updated! Updating bundle automatically...</span>';
    await autoUpdateBundle();
    if (vrEl) vrEl.innerHTML = '<span class="validation-success">✅ Alarm rule updated and activated! Auto-updating file... ✅</span>';
    setTimeout(() => { if (vrEl) vrEl.innerHTML = ''; }, 6000);

    return;
  }

  // Create new rule (not editing)
  const rule = {
    id: Date.now(), 
    name: name,
    tag: tag || name.toLowerCase().replace(/\s+/g, '_'),
    severity: severity,
    category: category,
    expression: expression,
    clinical: clinical || undefined,
    suggest: suggest || undefined,
    created: new Date().toLocaleString()
  };

  customAlarmRules.push(rule);
  saveAlarmsToStorage(); // 💾 Guardar automáticamente
  renderAlarmRulesList();
  clearForm();

  // Show success message
  byId('validationResult').innerHTML = '<span class="validation-success">✅ Alarm rule added! Updating bundle automatically...</span>';

  // Automatically generate and update the bundle
  await autoUpdateBundle();

  // Update success message
  byId('validationResult').innerHTML = '<span class="validation-success">✅ Alarm rule added and activated! Auto-updating file... ✅</span>';
  setTimeout(() => {
    byId('validationResult').innerHTML = '';
  }, 6000);
}

function clearForm() {
  byId('alarmName').value = '';
  byId('alarmTag').value = '';
  byId('alarmSeverity').value = 'warning';
  byId('alarmCategory').value = 'congestion';
  byId('advancedExpression').value = '';
  byId('clinicalWording').value = '';
  byId('suggestedActions').value = '';
  
  // Clear conditions
  const container = byId('conditionsContainer');
  if (container) {
    container.innerHTML = `
      <div class="condition-row" data-condition="0">
        <div class="row" style="align-items:center;margin-bottom:8px">
          <select class="condition-variable" style="width:120px">
            <option value="">Select Variable</option>
            <option value="HR">HR</option>
            <option value="SBP">SBP</option>
            <option value="DBP">DBP</option>
            <option value="MAP">MAP</option>
            <option value="ESP">ESP</option>
            <option value="sPAP">sPAP</option>
            <option value="dPAP">dPAP</option>
            <option value="PCWP">PCWP</option>
            <option value="RAP">RAP</option>
            <option value="CO">CO</option>
            <option value="CI">CI</option>
            <option value="SVI">SVI</option>
            <option value="LVEF">LVEF</option>
            <option value="EDV">EDV</option>
            <option value="ESV">ESV</option>
            <option value="Ea">Ea</option>
            <option value="Ees">Ees</option>
            <option value="VAC">VAC</option>
            <option value="CPO">CPO</option>
            <option value="CPI">CPI</option>
            <option value="SVR">SVR</option>
            <option value="PVR_WU">PVR (WU)</option>
            <option value="PAPI">PAPI</option>
            <option value="Lactate">Lactate</option>
            <option value="Lactate">Lactate</option>
            <option value="pH">pH</option>
            <option value="ALT">ALT</option>
            <option value="SvO2">SvO2</option>
            <option value="svo2">SvO2</option>
            <option value="creatinine">Creatinine</option>
            <option value="LVIS">LVIS</option>
            <option value="Stage">SCAI Stage</option>
            <option value="IABP">IABP</option>
            <option value="Impella">Impella</option>
            <option value="ECMO">ECMO</option>
            <option value="VAD">VAD</option>
            <option value="On_IABP">On IABP</option>
            <option value="On_Impella">On Impella</option>
            <option value="On_ECMO">On ECMO</option>
            <option value="Impella_flow_Lmin">Impella Flow</option>
            <option value="Dobut">Dobutamine</option>
            <option value="Dopa">Dopamine</option>
            <option value="Norepi">Norepinephrine</option>
            <option value="Milrinone">Milrinone</option>
            <option value="Epi">Epinephrine</option>
            <option value="Vasopressin">Vasopressin</option>
            <option value="Levosimendan">Levosimendan</option>
          </select>
          
          <select class="condition-operator" style="width:80px;margin-left:8px">
            <option value="">Op</option>
            <option value=">">></option>
            <option value=">=">≥</option>
            <option value="<"><</option>
            <option value="<=">≤</option>
            <option value="==">=</option>
            <option value="!=">≠</option>
          </select>
          
          <input type="text" class="condition-value" placeholder="Value" style="width:100px;margin-left:8px">
          
          <select class="condition-logic" style="width:60px;margin-left:8px">
            <option value="">End</option>
            <option value="&&">AND</option>
            <option value="||">OR</option>
          </select>
          
          <button class="btn" onclick="removeCondition(this)" style="margin-left:8px">🗑️</button>
        </div>
      </div>
    `;
  }
  
  // Hide advanced expression
  const advancedContainer = byId('advancedExpressionContainer');
  if (advancedContainer) {
    advancedContainer.style.display = 'none';
    byId('btnAddAdvanced').textContent = '⚙️ Advanced Expression';
  }
  
  updateExpressionPreview();

  // Reset add button editing state if present
  const addButton = byId('btnAddAlarm');
  if (addButton) {
    if (addButton.dataset && addButton.dataset.editingId) {
      delete addButton.dataset.editingId;
    }
    addButton.textContent = '➕ Add Alarm Rule';
  }
}

function renderAlarmRulesList() {
  const container = byId('currentAlarmsContainer');
  if (!container) return;
  
  if (customAlarmRules.length === 0) {
    container.innerHTML = '<div class="small" style="color:#666;font-style:italic">No custom alarm rules created yet.</div>';
    return;
  }
  
  // Mostrar contador de alarmas guardadas
  const savedCount = `<div style="margin-bottom:10px;padding:8px;background:#e8f5e8;border-radius:4px;font-size:12px;color:#155724">
    💾 <strong id="currentAlarmsResultCount">${customAlarmRules.length}</strong> alarm rules permanently saved
  </div>`;

  // Quick search box for current alarm rules
  const searchBoxHtml = `
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <input id="currentAlarmsSearch" placeholder="Quick search rules (name, tag, category, expression)..." style="flex:1;padding:8px;border:1px solid #dfe8ff;border-radius:6px" />
      <button class="btn" id="currentAlarmsClear">Clear</button>
    </div>`;
  
  const html = customAlarmRules.map(rule => {
    const severityIcon = {
      'warning': '⚠️',
      'critical': '🔴', 
      'improving': '🟢',
      'wean_ok': '🔵'
    }[rule.severity] || '⚪';
    
    return `
      <div class="alarm-rule-item severity-${rule.severity}">
        <div class="alarm-rule-content">
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
            <span style="font-size:16px">${severityIcon}</span>
            <strong>${escapeHtml(rule.name)}</strong>
            <span class="pill">${rule.category}</span>
            <span class="pill">${rule.tag}</span>
            <small style="color:#28a745;font-size:11px">💾 saved</small>
          </div>
          ${rule.clinical ? `<div class="small" style="color:#0066cc;margin-bottom:4px;font-style:italic">${escapeHtml(rule.clinical)}</div>` : ''}
          <div class="small" style="font-family:monospace;color:#666;margin-bottom:4px">${escapeHtml(rule.expression)}</div>
          ${rule.suggest ? `<div class="small" style="color:#16a34a;margin-bottom:4px">🎯 ${escapeHtml(rule.suggest)}</div>` : ''}
          <div class="small" style="color:#888">Created: ${rule.created}</div>
        </div>
          <div class="alarm-rule-actions">
          <button class="btn" onclick="editAlarmRule('${rule.id}')" title="Edit rule">✏️</button>
          <button class="btn" onclick="deleteAlarmRule('${rule.id}')" title="Delete rule">🗑️</button>
        </div>
      </div>
    `;
  }).join('');
  
  // Render search box + saved count + rules
  container.innerHTML = searchBoxHtml + savedCount + html;

  // Attach quick-search behavior (debounced) to filter the visible alarm-rule-item elements
  try{
    const input = byId('currentAlarmsSearch'); const clearBtn = byId('currentAlarmsClear');
    const resultCountEl = byId('currentAlarmsResultCount');
    if(input){
      let to = null;
      const doFilter = ()=>{
        const q = (input.value||'').toString().trim().toLowerCase();
        const items = Array.from(container.querySelectorAll('.alarm-rule-item'));
        if(!q){ items.forEach(it=> it.style.display=''); if(resultCountEl) resultCountEl.textContent = items.length; return; }
        let visible = 0;
        items.forEach(it=>{
          const txt = (it.textContent||'').toLowerCase();
          const show = txt.indexOf(q) !== -1;
          it.style.display = show ? '' : 'none';
          if(show) visible++;
        });
        if(resultCountEl) resultCountEl.textContent = visible;
      };
      input.addEventListener('input', ()=>{ if(to) clearTimeout(to); to = setTimeout(doFilter, 180); });
      clearBtn?.addEventListener('click', ()=>{ if(input){ input.value=''; input.dispatchEvent(new Event('input')); } });
      // initialize count
      if(resultCountEl) resultCountEl.textContent = Array.from(container.querySelectorAll('.alarm-rule-item')).length;
    }
  }catch(e){ console.warn('Failed to attach current alarms search', e); }
}

function editAlarmRule(id) {
  // Normalize id types (allow string ids from onclick)
  const normId = (typeof id === 'string' && id.match(/^\d+$/)) ? Number(id) : id;
  const rule = customAlarmRules.find(r => r.id === normId || String(r.id) === String(id));
  if (!rule) return;
  
  byId('alarmName').value = rule.name;
  byId('alarmTag').value = rule.tag;
  byId('alarmSeverity').value = rule.severity;
  byId('alarmCategory').value = rule.category;
  byId('clinicalWording').value = rule.clinical || '';
  byId('suggestedActions').value = rule.suggest || '';
  
  // Use advanced expression mode for editing
  const advancedContainer = byId('advancedExpressionContainer');
  if (advancedContainer) {
    advancedContainer.style.display = 'block';
    byId('btnAddAdvanced').textContent = '📝 Simple Builder';
  }
  
  byId('advancedExpression').value = rule.expression;
  updateExpressionPreview();
  
  // Enter edit mode: mark the Add button with the editing id instead of deleting
  const addBtn = byId('btnAddAlarm');
  if (addBtn) {
    addBtn.dataset.editingId = id;
    addBtn.textContent = '💾 Save Changes';
    // give visual hint
    const vr = byId('validationResult');
    if (vr) vr.innerHTML = '<span style="color:#0b5ed7">✏️ Editing rule - save to apply changes</span>';
  }

  // Scroll to form
  document.querySelector('#sec-alarms-builder .card').scrollIntoView({ behavior: 'smooth' });
}

async function deleteAlarmRule(id, confirm = true) {
  if (confirm && !window.confirm('Delete this alarm rule?')) return;
  const normId = (typeof id === 'string' && id.match(/^\d+$/)) ? Number(id) : id;
  customAlarmRules = customAlarmRules.filter(r => !(r.id === normId || String(r.id) === String(id)));
  saveAlarmsToStorage(); // 💾 Guardar automáticamente
  renderAlarmRulesList();
  
  // Auto-update bundle after deletion
  await autoUpdateBundle();
}

async function clearAllAlarms() {
  if (!confirm('Delete all custom alarm rules?')) return;
  
  customAlarmRules = [];
  clearAlarmsFromStorage(); // 💾 Limpiar localStorage también
  renderAlarmRulesList();
  
  // Clear the bundle and reset to empty state  
  window.ALARM_RULES = [];
  window.ALARM_RULES_EXTRA = [];
  
  const emptyCode = `// Custom alarm rules generated by Alarms Builder
// This file will be populated when you create rules using the Alarms Builder interface
// Currently empty - create rules in the Alarms Builder tab to populate this file
`;
  
  // Try to save empty bundle
  saveToServerFile('alarms.bundle.js', emptyCode);
  
  // Refresh components
  if (typeof renderAlarmsReference === 'function') {
    renderAlarmsReference();
  }
  if (typeof generateAll === 'function') {
    generateAll();
  }
}

function loadTemplate(template) {
  byId('alarmName').value = template.name;
  byId('alarmTag').value = template.tag;
  byId('alarmSeverity').value = template.severity;
  byId('alarmCategory').value = template.category;
  
  // Use advanced expression mode for templates
  const advancedContainer = byId('advancedExpressionContainer');
  if (advancedContainer) {
    advancedContainer.style.display = 'block';
    byId('btnAddAdvanced').textContent = '📝 Simple Builder';
  }
  
  byId('advancedExpression').value = template.expression;
  updateExpressionPreview();
  
  // Scroll to form
  document.querySelector('#sec-alarms-builder .card').scrollIntoView({ behavior: 'smooth' });
}

async function generateAlarmsBundle() {
  if (customAlarmRules.length === 0) {
    alert('No custom alarm rules to generate. Please create some rules first.');
    return;
  }
  
  try {
    // Group rules by category
    const groupedRules = {};
    customAlarmRules.forEach(rule => {
      const key = rule.category || 'other';
      if (!groupedRules[key]) {
        groupedRules[key] = [];
      }
      
      groupedRules[key].push({
        expr: rule.expression,
        color: rule.severity,
        tag: rule.tag,
        label: rule.name,
        id: rule.tag,
        clinical: rule.clinical,
        suggest: rule.suggest
      });
    });
    
    // Generate JavaScript code
    let jsCode = `/***********************
 * CUSTOM ALARM RULES GENERATED BY ALARMS BUILDER
 * Generated on: ${new Date().toLocaleString()}
 * Total rules: ${customAlarmRules.length}
 ***********************/

// Color legend:
// - warning    = 🟨 alerta / riesgo intermedio
// - critical   = 🔴 alarma mayor / falla inminente  
// - improving  = 🟩 mejoría clínica/metabólica
// - wean_ok    = 🔵 criterios cumplidos para destete

window.ALARM_RULES = [
`;
    
    Object.entries(groupedRules).forEach(([category, rules]) => {
      const categoryTitle = {
        'congestion': 'Custom Congestion Rules',
        'metabolic': 'Custom Metabolic Rules', 
        'perfusion': 'Custom Perfusion Rules',
        'trends': 'Custom Trend Rules',
        'mcs': 'Custom MCS Rules',
        'weaning': 'Custom Weaning Rules',
        'other': 'Custom Other Rules'
      }[category] || 'Custom Rules';
      
      jsCode += `
  // ${categoryTitle}
  { subtitle: "${categoryTitle}", items: [
`;
      
      rules.forEach((rule, index) => {
        let ruleCode = `    { expr: "${rule.expr.replace(/"/g, '\\"')}", color: "${rule.color}", tag: "${rule.tag}", label: "${rule.label}", id: "${rule.id}"`;
        if (rule.clinical) {
          ruleCode += `, clinical: "${rule.clinical.replace(/"/g, '\\"')}"`;
        }
        if (rule.suggest) {
          ruleCode += `, suggest: "${rule.suggest.replace(/"/g, '\\"')}"`;
        }
        ruleCode += ' }';
        jsCode += ruleCode;
        if (index < rules.length - 1) jsCode += ',';
        jsCode += '\n';
      });
      
      jsCode += '  ]},';
    });
    
    jsCode += `
];

// Initialize alarm evaluators when rules are loaded
try {
  if (typeof initAlarmEvaluators === 'function') {
    initAlarmEvaluators();
  }
  if (typeof renderAlarmsReference === 'function') {
    renderAlarmsReference();
  }
  if (typeof generateAll === 'function') {
    generateAll();
  }
} catch(e) {
  console.error('Error initializing custom alarm rules:', e);
}
`;
    
    // Always download when user explicitly requests it
  // Keep last generated code available for "Apply to disk" action
  window.lastGeneratedAlarmsCode = jsCode;
  downloadTextFile('alarms.bundle.js', jsCode);
    
    // Update the global alarm rules immediately regardless of save method
    try {
      // Clear existing rules first
      window.ALARM_RULES = [];
      window.ALARM_RULES_EXTRA = [];
      
      // Execute the generated code to load new rules
      eval(jsCode);
      
      alert(`Generated alarms.bundle.js with ${customAlarmRules.length} custom rules! File has been downloaded and rules are active in the dashboard.`);
      
      // Force refresh of all components that use alarm rules
      if (typeof initAlarmEvaluators === 'function') {
        initAlarmEvaluators();
      }
      if (typeof renderAlarmsReference === 'function') {
        renderAlarmsReference();
      }
      if (typeof generateAll === 'function') {
        generateAll();
      }
      
      
    } catch (error) {
      console.error('Error applying generated rules:', error);
      alert('Bundle generated but there was an error applying the rules. Check the console for details.');
    }
    
  } catch (error) {
    console.error('Error generating alarms bundle:', error);
    alert('Error generating bundle: ' + error.message);
  }
}

// Apply the last generated alarms bundle to disk using File System Access API
async function applyAlarmsBundleToDisk() {
  try {
    const code = window.lastGeneratedAlarmsCode;
    if (!code) {
      alert('No generated bundle available. Click "Generate Bundle" first.');
      return;
    }

    // Prefer direct update if a handle is already stored
    if (typeof updatePhysicalFileDirectly === 'function') {
      const success = await updatePhysicalFileDirectly('alarms.bundle.js', code);
      if (success) {
        alert('✅ alarms.bundle.js written to disk successfully');
        return;
      }
    }

    // If direct write failed, offer the setup flow
    const setup = confirm('Automatic write not available. Would you like to setup Direct Update now? (recommended)');
    if (setup) {
      await setupDirectFileAccess();
      // try again after setup
      if (typeof updatePhysicalFileDirectly === 'function') {
        const retry = await updatePhysicalFileDirectly('alarms.bundle.js', code);
        if (retry) { alert('✅ alarms.bundle.js written to disk successfully'); return; }
      }
    }

    // Fallback: download the file
    downloadTextFile('alarms.bundle.js', code);
    alert('Downloaded alarms.bundle.js to your Downloads folder (fallback).');
  } catch (err) {
    console.error('Error applying bundle to disk:', err);
    alert('Error writing file: ' + (err && err.message ? err.message : String(err)));
  }
}

// ============== VARIABLE BUILDER FUNCTIONS ==============
let customVariables = [];

async function addCustomVariable() {
  const name = byId('variableName')?.value?.trim();
  const expression = byId('variableExpression')?.value?.trim();
  const description = byId('variableDescription')?.value?.trim();
  const result = byId('variableValidationResult');
  const addButton = byId('btnAddVariable');
  
  // Check if we're in edit mode
  const isEditing = addButton?.dataset?.editingId;
  const editingId = isEditing ? parseInt(addButton.dataset.editingId) : null;
  
  if (!name) {
    result.innerHTML = '<span style="color:#dc2626">❌ Please enter a variable name</span>';
    return;
  }
  
  if (!expression) {
    result.innerHTML = '<span style="color:#dc2626">❌ Please enter an expression</span>';
    return;
  }
  
  // Check if variable name already exists (but allow same name when editing same variable)
  const existingVariable = customVariables.find(v => v.name === name);
  if (existingVariable && (!isEditing || existingVariable.id !== editingId)) {
    result.innerHTML = '<span style="color:#dc2626">❌ Variable name already exists</span>';
    return;
  }
  
  // Validate variable name (alphanumeric + underscore, no spaces)
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {
    result.innerHTML = '<span style="color:#dc2626">❌ Variable name must start with letter/underscore and contain only letters, numbers, underscores</span>';
    return;
  }
  
  if (isEditing) {
    // Update existing variable
    const variable = customVariables.find(v => v.id === editingId);
    if (variable) {
      variable.name = name;
      variable.expression = expression;
      variable.description = description || undefined;
      // Keep original creation date, but add update info
      variable.updated = new Date().toLocaleString();
    }
    
    // Reset button to add mode
    addButton.textContent = '➕ Add Variable';
    addButton.style.background = '';
    delete addButton.dataset.editingId;
    
    result.innerHTML = `<span style="color:#16a34a">✅ Variable "${name}" updated! Updating bundle automatically...</span>`;
  } else {
    // Create new variable
    const variable = {
      id: Date.now(),
      name: name,
      expression: expression,
      description: description || undefined,
      created: new Date().toLocaleString()
    };
    
    customVariables.push(variable);
    result.innerHTML = `<span style="color:#16a34a">✅ Variable "${name}" added! Updating bundle automatically...</span>`;
  }
  
  // Clear form
  byId('variableName').value = '';
  byId('variableExpression').value = '';
  byId('variableDescription').value = '';
  
  // Set flag to prevent file conflicts
  variableUpdateInProgress = true;
  
  // Save and update (like alarms system)
  saveVariablesToStorage();
  renderCustomVariablesList();
  updateVariableDescriptionsTable(); // Update the descriptions table
  
  // Automatically generate and update the bundle (like alarms system)
  await autoUpdateVariablesBundle();
  
  // Clear flag after a delay
  setTimeout(() => {
    variableUpdateInProgress = false;
  }, 2000);
  
  // Update success message based on mode
  const action = isEditing ? 'updated' : 'added';
  result.innerHTML = `<span style="color:#16a34a">✅ Variable "${name}" ${action} and activated! Auto-updating file... 🔄</span>`;
  
  // Force a small delay to prevent conflicts with file reloading
  setTimeout(() => {
    result.innerHTML = '';
  }, 6000);
}

function renderCustomVariablesList() {
  const container = byId('customVariablesList');
  if (!container) return;
  
  if (customVariables.length === 0) {
    container.innerHTML = '<div class="small" style="color:#6b7280;font-style:italic">No custom variables created yet</div>';
    return;
  }
  
  let html = '<div style="display:grid;gap:8px">';
  
  customVariables.forEach(variable => {
    html += `
      <div class="variable-rule-card" style="background:#f8fafc;border:1px solid #e2e8f0;border-radius:8px;padding:10px">
        <div style="display:flex;justify-content:space-between;align-items:flex-start">
          <div style="flex:1">
            <div style="font-weight:500;color:#1e40af;cursor:pointer;margin-bottom:4px" onclick="copyToClipboard('${variable.name}')" title="Click to copy variable name">
              ${variable.name}
            </div>
            <div class="mono" style="font-size:13px;color:#374151;margin-bottom:4px">
              ${variable.expression}
            </div>
            ${variable.description ? `<div style="font-size:12px;color:#6b7280">${variable.description}</div>` : ''}
            <div style="font-size:11px;color:#9ca3af;margin-top:4px">Created: ${variable.created}</div>
          </div>
          <div style="display:flex;gap:4px">
            <button onclick="editCustomVariable(${variable.id})" class="btn" style="background:#1f6fff;color:white;padding:4px 8px;font-size:12px" title="Edit variable">✏️</button>
            <button onclick="deleteCustomVariable(${variable.id})" class="btn" style="background:#dc2626;color:white;padding:4px 8px;font-size:12px" title="Delete variable">🗑️</button>
          </div>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  container.innerHTML = html;
  
  // Also update the variables panel and dropdown
  updateCustomVariablesInPanels();
  // Deduplicate custom variables visually (ensure canonical-only display)
  try{ dedupeCustomVariables(); }catch(e){ console.debug('dedupeCustomVariables failed after renderCustomVariablesList', e); }
}

// Update custom variables in the variables panel and dropdown
function updateCustomVariablesInPanels() {
  // Update the variables panel
  const customPanel = byId('customVariablesPanel');
  const customCategory = byId('customVariablesCategory');
  
  if (customPanel && customCategory) {
    if (customVariables.length === 0) {
      // Hide the category if no custom variables
      customCategory.style.display = 'none';
    } else {
      // Show the category and populate variables
      customCategory.style.display = 'block';
      
      let panelHtml = '';
      customVariables.forEach(variable => {
        panelHtml += `<span class="variable-item" data-var="${variable.name}" style="background:#e0e7ff;border-color:#a5b4fc;color:#3730a3" title="${variable.description || variable.expression}">${variable.name}</span>`;
      });
      customPanel.innerHTML = panelHtml;
    }
  }
  
  // Update all dropdown selects for condition variables
  updateCustomVariablesInDropdowns();
  // Also ensure visual deduplication for newly updated panels
  try{ dedupeCustomVariables(); }catch(e){ console.debug('dedupeCustomVariables failed after updateCustomVariablesInPanels', e); }
}

// Add custom variables to all condition variable dropdowns
function updateCustomVariablesInDropdowns() {
  const dropdowns = document.querySelectorAll('.condition-variable');
  
  dropdowns.forEach(dropdown => {
    // Remove existing custom variables (those after the standard ones)
    const options = Array.from(dropdown.options);
    const lastStandardIndex = options.findIndex(opt => opt.value === 'Levosimendan');
    
    if (lastStandardIndex !== -1) {
      // Remove all options after the last standard variable
      for (let i = dropdown.options.length - 1; i > lastStandardIndex; i--) {
        dropdown.remove(i);
      }
    }
    
    // Add custom variables
    if (customVariables.length > 0) {
      // Add separator
      const separator = document.createElement('option');
      separator.disabled = true;
      separator.text = '--- Custom Variables ---';
      dropdown.add(separator);
      
      // Add each custom variable
      customVariables.forEach(variable => {
        const option = document.createElement('option');
        option.value = variable.name;
        option.text = `${variable.name} (custom)`;
        option.title = variable.description || variable.expression;
        dropdown.add(option);
      });
    }
  });
}

function editCustomVariable(id) {
  const variable = customVariables.find(v => v.id === id);
  if (!variable) {
    alert('Variable not found!');
    return;
  }
  
  // Fill the form with existing values
  const nameInput = byId('variableName');
  const expressionInput = byId('variableExpression');
  const descriptionInput = byId('variableDescription');
  
  if (nameInput) nameInput.value = variable.name;
  if (expressionInput) expressionInput.value = variable.expression;
  if (descriptionInput) descriptionInput.value = variable.description || '';
  
  // Change button text to indicate edit mode
  const addButton = byId('btnAddVariable');
  if (addButton) {
    addButton.textContent = '💾 Update Variable';
    addButton.style.background = '#f59e0b';
    
    // Store the ID we're editing
    addButton.dataset.editingId = id;
  }
  
  // Scroll to form
  nameInput?.scrollIntoView({ behavior: 'smooth' });
}

function deleteCustomVariable(id) {
  if (confirm('Are you sure you want to delete this variable?')) {
    customVariables = customVariables.filter(v => v.id !== id);
    saveVariablesToStorage();
    renderCustomVariablesList();
    generateVariablesBundle();
  }
}

function saveVariablesToStorage() {
  try {
    localStorage.setItem('customVariables', JSON.stringify(customVariables));
  } catch (error) {
    console.error('Error saving variables to localStorage:', error);
  }
}

// Update the Variable Descriptions table with custom variables
function updateVariableDescriptionsTable() {
  // Variable Descriptions section removed — keep a no-op stub to avoid
  // runtime errors from callers elsewhere in the app.
  return;
}

// Initialize custom variables from variablesbuild.js file
function initCustomVariables() {
  try {
    // Skip initialization if an update is in progress to avoid conflicts
    if (variableUpdateInProgress) {
      return;
    }
    
    if (typeof window.CUSTOM_VARIABLES !== 'undefined' && Array.isArray(window.CUSTOM_VARIABLES)) {
      
      // Convert the format from variablesbuild.js to internal format
      const externalVariables = window.CUSTOM_VARIABLES.map((variable, index) => ({
        id: Date.now() + index, // Generate unique ID
        name: variable.name,
        expression: variable.expression,
        description: variable.description || '',
        created: new Date().toLocaleString()
      }));
      
      // Merge with existing localStorage variables (avoid duplicates)
      const existingVariables = customVariables || [];
      const mergedVariables = [...existingVariables];
      
      externalVariables.forEach(extVar => {
        // Check if this variable already exists (by name)
        const existingIndex = mergedVariables.findIndex(existing => existing.name === extVar.name);
        if (existingIndex === -1) {
          // Add new variable
          mergedVariables.push(extVar);
        } else {
          // Keep existing variable from localStorage (it's more up-to-date)
          // Only update if the existing variable doesn't have recent changes
          const existing = mergedVariables[existingIndex];
          if (!existing.updated && !existing.created) {
            // Only update if it's from an old version without timestamps
            mergedVariables[existingIndex] = { ...existing, ...extVar };
          } else {
            
          }
        }
      });
      
      // Update global variables and refresh UI
      customVariables = mergedVariables;
      saveVariablesToStorage();
      renderCustomVariablesList();
      updateVariableDescriptionsTable();
  try{ dedupeCustomVariables(); }catch(e){ console.debug('dedupeCustomVariables failed after initCustomVariables', e); }
      
      
    } else {
      
    }
  } catch (error) {
    console.error('❌ Error initializing custom variables from file:', error);
  }
}

function loadVariablesFromStorage() {
  try {
    const stored = localStorage.getItem('customVariables');
    if (stored) {
      customVariables = JSON.parse(stored);
      renderCustomVariablesList();
    }
  } catch (error) {
    console.error('Error loading variables from localStorage:', error);
    customVariables = [];
  }
}

// Auto-update variables bundle (like alarms system)
async function autoUpdateVariablesBundle() {
  if (customVariables.length === 0) {
    return;
  }
  
  try {
    // Generate JavaScript code (exactly like alarms system)
    let jsCode = `/***********************
 * CUSTOM VARIABLES GENERATED BY VARIABLE BUILDER
 * Generated on: ${new Date().toLocaleString()}
 * Total variables: ${customVariables.length}
 ***********************/

// Custom variables for use in alarm expressions and calculations
window.CUSTOM_VARIABLES = [
`;
    
    customVariables.forEach((variable, index) => {
      jsCode += `  { name: "${variable.name}", expression: "${variable.expression.replace(/"/g, '\\"')}"`;
      if (variable.description) {
        jsCode += `, description: "${variable.description.replace(/"/g, '\\"')}"`;
      }
      jsCode += ' }';
      if (index < customVariables.length - 1) {
        jsCode += ',';
      }
      jsCode += '\n';
    });
    
    jsCode += `];

// Initialize custom variables when loaded
try {
  if (typeof initCustomVariables === 'function') {
    initCustomVariables();
  }
} catch(e) {
  console.error('Error loading custom variables:', e);
}`;
    
    // Update the global custom variables immediately (like alarms system)
    try {
      // Execute the generated code to load new variables
      eval(jsCode);
      
      
      
      // Store the generated code for manual export if needed
      window.lastGeneratedVariableCode = jsCode;
      
      // Save to localStorage for persistence (like alarms system)
      try {
  localStorage.setItem('pv-one-variables-bundle-code', jsCode);
      } catch (error) {
        console.error('Error saving variables bundle code to localStorage:', error);
      }
      
      // 🔥 AUTO-UPDATE PHYSICAL FILE AUTOMATICALLY using Direct File Access
      try {
        // Try Direct File Update first (like alarms system)
        const directUpdateSuccess = await updateVariablesPhysicalFile('lib/variablesbuild.js', jsCode);
        if (!directUpdateSuccess) {
          // Fallback to fetch API if Direct Update is not available
          const response = await fetch('/update-bundle', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filename: 'lib/variablesbuild.js', content: jsCode })
          });
          if (response.ok) {
            const result = await response.json();
          }
        }
      } catch (err) {
        // Auto-update not available; rely on localStorage
      }
      
    } catch (error) {
      console.error('Error auto-updating custom variables:', error);
    }
    
  } catch (error) {
    console.error('Error in autoUpdateVariablesBundle:', error);
  }
}

// Legacy function for manual generation
async function generateVariablesBundle() {
  // Just call the auto-update function
  await autoUpdateVariablesBundle();
  
  // Show success message
  const result = byId('variableValidationResult');
  if (result) {
    result.innerHTML = `<span style="color:#16a34a">✅ Generated and activated ${customVariables.length} variables! Auto-updating file... 🔄</span>`;
    setTimeout(() => result.innerHTML = '', 3000);
  }
}

// ============== MULTIPLE VARIABLES FUNCTIONS ==============
let multipleVariablesEditorVisible = false;
let variableUpdateInProgress = false; // Flag to prevent file reload conflicts

function showMultipleVariablesEditor() {
  try {
    
    
    const card = byId('multipleVariablesCard');
    const btn = byId('btnShowMultipleVariables');
    
    if (!card) {
      console.error('❌ multipleVariablesCard not found');
      return;
    }
    if (!btn) {
      console.error('❌ btnShowMultipleVariables not found');
      return;
    }
    
    if (multipleVariablesEditorVisible) {
      // Hide editor
      card.style.display = 'none';
      btn.textContent = '📝 Multiple Variables';
      multipleVariablesEditorVisible = false;
    } else {
      // Show editor
      card.style.display = 'block';
      btn.textContent = '📝 Hide Multiple Variables';
      multipleVariablesEditorVisible = true;
      
      // Scroll to view with error handling
      try {
        card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      } catch (scrollError) {
        console.warn('⚠️ ScrollIntoView error (non-critical):', scrollError);
      }
    }
    
    
  } catch (error) {
    console.error('❌ Error in showMultipleVariablesEditor:', error);
  }
}

function hideMultipleVariablesEditor() {
  const card = byId('multipleVariablesCard');
  const btn = byId('btnShowMultipleVariables');
  if (card && btn) {
    card.style.display = 'none';
    btn.textContent = '📝 Multiple Variables';
    multipleVariablesEditorVisible = false;
  }
}

function validateMultipleVariables() {
  try {
    
    
    const editor = byId('multipleVariablesEditor');
    const result = byId('multipleVariablesValidationResult');
    
    if (!editor) {
      console.error('❌ multipleVariablesEditor not found');
      return;
    }
    if (!result) {
      console.error('❌ multipleVariablesValidationResult not found');
      return;
    }
    
    const text = editor.value.trim();
    if (!text) {
      result.innerHTML = '<span style="color:#f59e0b">⚠️ Add content to editor</span>';
      return;
    }
    
    const variables = parseMultipleVariables(text);
  result.innerHTML = `<span style="color:#16a34a">✅ Valid format! Found ${variables.length} variables</span>`;
    
  } catch (error) {
    console.error('❌ Validation error:', error);
    const result = byId('multipleVariablesValidationResult');
    if (result) {
      result.innerHTML = `<span style="color:#dc2626">❌ Error: ${error.message}</span>`;
    }
  }
}

function parseMultipleVariables(text) {
  const variables = [];
  
  try {
    // Try JSON format
    const jsonData = JSON.parse(text);
    if (Array.isArray(jsonData)) {
      return jsonData.map((item, index) => {
        if (!item.name || !item.expression) {
          throw new Error(`Variable ${index + 1}: requires 'name' and 'expression'`);
        }
        
        // Validate variable name (alphanumeric + underscore, no spaces)
        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(item.name)) {
          throw new Error(`Variable ${index + 1}: name '${item.name}' must start with letter/underscore and contain only letters, numbers, underscores`);
        }
        
        // Check if variable name already exists
        if (customVariables.find(v => v.name === item.name)) {
          throw new Error(`Variable ${index + 1}: name '${item.name}' already exists`);
        }
        
        return {
          name: item.name,
          expression: item.expression,
          description: item.description || undefined
        };
      });
    }
  } catch (e) {
    throw new Error('Invalid JSON format or validation error: ' + e.message);
  }
  
  throw new Error('Content must be a JSON array of variables');
}

async function processMultipleVariables() {
  const editor = byId('multipleVariablesEditor');
  const result = byId('multipleVariablesValidationResult');
  if (!editor || !result) return;
  
  try {
    const text = editor.value.trim();
    if (!text) {
      result.innerHTML = '<span style="color:#f59e0b">⚠️ Add content to editor</span>';
      return;
    }
    
    const variables = parseMultipleVariables(text);
    let addedCount = 0;
    
    for (const variable of variables) {
      const newVar = {
        id: Date.now() + addedCount,
        name: variable.name,
        expression: variable.expression,
        description: variable.description,
        created: new Date().toLocaleString()
      };
      
      customVariables.push(newVar);
      addedCount++;
    }
    
    // Save and update (like alarms system)
    saveVariablesToStorage();
    renderCustomVariablesList();
    
    // Auto-update bundle like alarms system
    await autoUpdateVariablesBundle();
    
    result.innerHTML = `<span style="color:#16a34a">✅ ${addedCount} variables added successfully!</span>`;
    
    // Clear editor
    editor.value = '';
    
    // Hide editor after success
    setTimeout(() => {
      hideMultipleVariablesEditor();
    }, 2000);
    
  } catch (error) {
    result.innerHTML = `<span style="color:#dc2626">❌ Error: ${error.message}</span>`;
  }
}

// Variables are auto-updated like alarms - no manual configuration needed

function exportAlarms() {
  if (customAlarmRules.length === 0) {
    alert('No alarm rules to export.');
    return;
  }
  
  const exportData = {
    version: '1.0',
    exported: new Date().toISOString(),
    totalRules: customAlarmRules.length,
    rules: customAlarmRules
  };
  
  const json = JSON.stringify(exportData, null, 2);
  downloadTextFile('alarm-rules-config.json', json);
}

function importAlarms() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        
        if (!data.rules || !Array.isArray(data.rules)) {
          throw new Error('Invalid file format - missing rules array');
        }
        
        const importCount = data.rules.length;
        if (confirm(`Import ${importCount} alarm rules? This will add to your existing rules.`)) {
          // Add imported rules with new IDs to avoid conflicts
          data.rules.forEach(rule => {
            rule.id = Date.now() + Math.random();
            rule.created = rule.created || new Date().toLocaleString();
          });
          
          customAlarmRules.push(...data.rules);
          saveAlarmsToStorage(); // 💾 Guardar automáticamente
          renderAlarmRulesList();
          alert(`Successfully imported ${importCount} alarm rules and saved permanently! 💾`);
        }
      } catch (error) {
        alert('Error importing file: ' + error.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

// Function to try saving directly to server file (silent operation)
async function saveToServerFile(filename, content) {
  try {
    // Method 1: Try using a simple HTTP PUT request to save the file
    try {
      const response = await fetch(`/${filename}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'text/javascript',
        },
        body: content
      });
      
      if (response.ok) {
        return true;
      }
    } catch (err) {
    }
    
    // For local development, we'll just keep the rules in memory
    // The rules are already active via eval() in autoUpdateBundle()
    return false;
    
  } catch (error) {
    console.error('Error saving file:', error);
    return false;
  }
}

// Variables use the same server update system as alarms

function downloadTextFile(filename, content) {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', initAlarmsBuilder);

// Helper function to read device inputs from DOM (for alarm evaluation context)
function readDeviceInputsFromDOM(act) {
  if (!act) return null;
  
  try {
    // Get active timepoint index
    let activeIndex = '0';
    const activeRadio = document.querySelector('input[name="activeTP"]:checked');
    if (activeRadio) {
      activeIndex = activeRadio.id.split('_').pop();
    }
    
    const result = {
      svo2: null,
      lactate: null,
      pH: null,
      map: null,
      impFlowRaw: null,
      devs: {}
    };
    
    // Read SvO2
    const svo2Input = document.getElementById(`t_svo2_${activeIndex}`);
    if (svo2Input && svo2Input.value !== '') {
      const val = parseFloat(svo2Input.value);
      if (!isNaN(val)) result.svo2 = val;
    }
    
    // Read Lactate  
    const lactInput = document.getElementById(`t_lac_${activeIndex}`);
    if (lactInput && lactInput.value !== '') {
      const val = parseFloat(lactInput.value);
      if (!isNaN(val)) result.lactate = val;
    }
    
    // Read pH
    const phInput = document.getElementById(`t_ph_${activeIndex}`);
    if (phInput && phInput.value !== '') {
      const val = parseFloat(phInput.value);
      if (!isNaN(val)) result.pH = val;
    }
    
    // Calculate MAP from SBP/DBP if available
    const sbpInput = document.getElementById(`t_sbp_${activeIndex}`);
    const dbpInput = document.getElementById(`t_dbp_${activeIndex}`);
    if (sbpInput && dbpInput && sbpInput.value && dbpInput.value) {
      const sbp = parseFloat(sbpInput.value);
      const dbp = parseFloat(dbpInput.value);
      if (!isNaN(sbp) && !isNaN(dbp)) {
        result.map = dbp + (sbp - dbp) / 3;
      }
    }
    
    // Read Impella flow
    const impFlowInput = document.getElementById(`t_impella_flow_${activeIndex}`);
    if (impFlowInput) {
      result.impFlowRaw = impFlowInput.value;
    }
    
    // Read device states
    const devices = ['IABP', 'Impella', 'ECMO', 'VAD'];
    devices.forEach(dev => {
      const devInput = document.getElementById(`t_dev_${dev}_${activeIndex}`);
      if (devInput) {
        result.devs[dev] = devInput.checked;
      }
    });
    
    return result;
  } catch (e) {
    console.warn('Error reading device inputs from DOM:', e);
    return null;
  }
}

// Function to automatically update the bundle without user interaction
async function autoUpdateBundle() {
  if (customAlarmRules.length === 0) {
    return;
  }
  
  try {
    // Group rules by category
    const groupedRules = {};
    customAlarmRules.forEach(rule => {
      const key = rule.category || 'other';
      if (!groupedRules[key]) {
        groupedRules[key] = [];
      }
      
      groupedRules[key].push({
        expr: rule.expression,
        color: rule.severity,
        tag: rule.tag,
        label: rule.name,
        id: rule.tag,
        clinical: rule.clinical,
        suggest: rule.suggest
      });
    });
    
    // Generate JavaScript code
    let jsCode = `/***********************
 * CUSTOM ALARM RULES GENERATED BY ALARMS BUILDER
 * Generated on: ${new Date().toLocaleString()}
 * Total rules: ${customAlarmRules.length}
 ***********************/

// Color legend:
// - warning    = 🟨 alerta / riesgo intermedio
// - critical   = 🔴 alarma mayor / falla inminente  
// - improving  = 🟩 mejoría clínica/metabólica
// - wean_ok    = 🔵 criterios cumplidos para destete

window.ALARM_RULES = [
`;
    
    Object.entries(groupedRules).forEach(([category, rules]) => {
      const categoryTitle = {
        'congestion': 'Custom Congestion Rules',
        'metabolic': 'Custom Metabolic Rules', 
        'perfusion': 'Custom Perfusion Rules',
        'trends': 'Custom Trend Rules',
        'mcs': 'Custom MCS Rules',
        'weaning': 'Custom Weaning Rules',
        'other': 'Custom Other Rules'
      }[category] || 'Custom Rules';
      
      jsCode += `
  // ${categoryTitle}
  { subtitle: "${categoryTitle}", items: [
`;
      
      rules.forEach((rule, index) => {
        let ruleCode = `    { expr: "${rule.expr.replace(/"/g, '\\"')}", color: "${rule.color}", tag: "${rule.tag}", label: "${rule.label}", id: "${rule.id}"`;
        if (rule.clinical) {
          ruleCode += `, clinical: "${rule.clinical.replace(/"/g, '\\"')}"`;
        }
        if (rule.suggest) {
          ruleCode += `, suggest: "${rule.suggest.replace(/"/g, '\\"')}"`;
        }
        ruleCode += ' }';
        jsCode += ruleCode;
        if (index < rules.length - 1) jsCode += ',';
        jsCode += '\n';
      });
      
      jsCode += '  ]},';
    });
    
    jsCode += `
];

// Initialize alarm evaluators when rules are loaded
try {
  if (typeof initAlarmEvaluators === 'function') {
    initAlarmEvaluators();
  }
  if (typeof renderAlarmsReference === 'function') {
    renderAlarmsReference();
  }
  if (typeof generateAll === 'function') {
    generateAll();
  }
} catch(e) {
  console.error('Error initializing custom alarm rules:', e);
}
`;
    
    // Update the global alarm rules immediately
    try {
      // Clear existing rules first
      window.ALARM_RULES = [];
      window.ALARM_RULES_EXTRA = [];
      
      // Execute the generated code to load new rules
      eval(jsCode);
      
      // Force refresh of all components that use alarm rules
      if (typeof initAlarmEvaluators === 'function') {
        initAlarmEvaluators();
      }
      if (typeof renderAlarmsReference === 'function') {
        renderAlarmsReference();
      }
      if (typeof generateAll === 'function') {
        generateAll();
      }
      
      
      
      // Store the generated code for manual export if needed
      window.lastGeneratedAlarmCode = jsCode;
      
      // Guardar el código generado en localStorage para exportación
      try {
  localStorage.setItem('pv-one-alarms-bundle-code', jsCode);
      } catch (error) {
        console.error('Error saving bundle code to localStorage:', error);
      }
      
      // 🔥 UPDATE PHYSICAL FILE DIRECTLY (bypass CORS)
      try {
        // If running on a local dev server (e.g., Live Server at localhost:5500), avoid automatic physical writes
        // because they typically trigger a file-watch reload of the page. In that environment prefer download fallback.
        const host = (location && location.hostname) ? location.hostname : '';
        const isLocalDev = host === '127.0.0.1' || host === 'localhost' || (location && location.port === '5500');
  // Prefer download fallback when running on local dev servers OR when auto physical writes are not allowed
  const preferDownload = !!window.forceBundleDownload || isLocalDev || (window.allowAutoPhysicalWrites !== true);

        if (preferDownload) {
          try { localStorage.setItem('pv-one-alarms-bundle-code', jsCode); } catch(e){}
          downloadTextFile('alarms.bundle.js', jsCode);
          showAutoUpdateNotification('download');
        } else {
          const updated = await updatePhysicalFileDirectly('alarms.bundle.js', jsCode);
          if (updated) {
            showAutoUpdateNotification('success');
          } else {
            // Fallback to download
            downloadTextFile('alarms.bundle.js', jsCode);
            showAutoUpdateNotification('download');
          }
        }
      } catch (err) {
        downloadTextFile('alarms.bundle.js', jsCode);
        showAutoUpdateNotification('download');
      }
      
    } catch (error) {
      console.error('Error auto-updating alarm rules:', error);
    }
    
  } catch (error) {
    console.error('Error in auto bundle update:', error);
  }
}

// Function to reload the alarms bundle dynamically
function reloadAlarmsBundle() {
  // Remove existing script if present
  const existingScript = document.querySelector('script[src*="alarms.bundle.js"]');
  if (existingScript) {
    existingScript.remove();
  }
  
  // Create new script element with cache-busting parameter
  const script = document.createElement('script');
  script.src = `alarms.bundle.js?t=${Date.now()}`;
  script.onload = () => {
    // Re-initialize alarm system
    if (typeof initAlarmEvaluators === 'function') {
      initAlarmEvaluators();
    }
    if (typeof renderAlarmsReference === 'function') {
      renderAlarmsReference();
    }
    if (typeof generateAll === 'function') {
      generateAll();
    }
  };
  script.onerror = () => {
    console.warn('Failed to reload alarms bundle');
  };
  
  document.head.appendChild(script);
}

// Variables Reference Functions
function initVariablesReference() {
  // Initialize custom variables from variablesbuild.js file first
  if (typeof window.CUSTOM_VARIABLES !== 'undefined') {
    initCustomVariables();
  }
  
  // Load variables from storage and update descriptions table
  loadVariablesFromStorage();
  updateVariableDescriptionsTable();
  
  // Variable search functionality
  const searchInput = byId('variableSearch');
  if (searchInput) {
    searchInput.addEventListener('input', function() {
      const query = this.value.toLowerCase();
      filterVariables(query);
    });
  }
  
  // Variable click functionality
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('variable-item')) {
      const variable = e.target.dataset.var || e.target.textContent;
      copyVariableToClipboard(variable, e.target);
      insertVariableIntoExpression(variable);
    }
  });
}

function filterVariables(query) {
  const categories = document.querySelectorAll('.variable-category');
  
  categories.forEach(category => {
    const items = category.querySelectorAll('.variable-item');
    let hasVisibleItems = false;
    
    items.forEach(item => {
      const variableName = (item.dataset.var || item.textContent).toLowerCase();
      const matches = variableName.includes(query);
      
      item.style.display = matches ? 'inline-block' : 'none';
      if (matches) hasVisibleItems = true;
    });
    
    // Hide category if no items match
    category.classList.toggle('hidden', !hasVisibleItems && query !== '');
  });
}

async function copyVariableToClipboard(variable, element) {
  try {
    await navigator.clipboard.writeText(variable);
    
    // Visual feedback
    element.classList.add('copied');
    const originalText = element.textContent;
    element.textContent = '✅ Copiado!';
    
    setTimeout(() => {
      element.classList.remove('copied');
      element.textContent = originalText;
    }, 1000);
    
  } catch (err) {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = variable;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    
    element.classList.add('copied');
    setTimeout(() => element.classList.remove('copied'), 1000);
  }
}

// Simple copy to clipboard function for Variable Builder
async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    // Show toast or alert briefly
    const result = byId('variableValidationResult');
    if (result) {
      result.innerHTML = `<span style="color:#16a34a">✅ "${text}" copied to clipboard!</span>`;
      setTimeout(() => result.innerHTML = '', 2000);
    }
  } catch (err) {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
  }
}

function insertVariableIntoExpression(variable) {
  // Try to insert into the current expression preview
  const expressionPreview = byId('expressionPreview');
  const advancedExpression = byId('advancedExpression');
  
  // Determine which field is active
  const advancedContainer = byId('advancedExpressionContainer');
  const isAdvancedMode = advancedContainer && advancedContainer.style.display !== 'none';
  
  const targetField = isAdvancedMode ? advancedExpression : expressionPreview;
  
  if (targetField) {
    const currentValue = targetField.value || '';
    const cursorPosition = targetField.selectionStart || currentValue.length;
    
    // Insert variable at cursor position or append
    let newValue;
    if (currentValue === '(no conditions defined)' || currentValue === '(empty expression)') {
      newValue = variable;
    } else {
      const before = currentValue.substring(0, cursorPosition);
      const after = currentValue.substring(cursorPosition);
      
      // Add spaces if needed
      const needSpaceBefore = before && !before.endsWith(' ') && !before.endsWith('(');
      const needSpaceAfter = after && !after.startsWith(' ') && !after.startsWith(')');
      
      newValue = before + 
                 (needSpaceBefore ? ' ' : '') + 
                 variable + 
                 (needSpaceAfter ? ' ' : '') + 
                 after;
    }
    
    targetField.value = newValue;
    
    // Update cursor position
    const newCursorPos = cursorPosition + variable.length + 
                         (currentValue && !currentValue.endsWith(' ') ? 1 : 0);
    targetField.setSelectionRange(newCursorPos, newCursorPos);
    
    // Trigger validation if it's the advanced field
    if (isAdvancedMode) {
      updateExpressionPreview();
    }
    
    // Focus the field
    targetField.focus();
  }
}

// Functions for Multiple Alarms Editor
function showMultipleAlarmsEditor() {
  const card = byId('multipleAlarmsCard');
  if (card) {
    card.style.display = 'block';
    card.scrollIntoView({ behavior: 'smooth' });
  }
}

function hideMultipleAlarmsEditor() {
  const card = byId('multipleAlarmsCard');
  if (card) card.style.display = 'none';
}

function validateMultipleAlarms() {
  const editor = byId('multipleAlarmsEditor');
  const result = byId('multipleValidationResult');
  if (!editor || !result) return;
  
  const text = editor.value.trim();
  if (!text) {
    result.innerHTML = '<span style="color:#f59e0b">⚠️ Editor vacío</span>';
    return;
  }
  
  try {
    const parsed = parseMultipleAlarms(text);
    result.innerHTML = `<span style="color:#16a34a">✅ Formato válido - ${parsed.length} alarmas detectadas</span>`;
  } catch (error) {
    result.innerHTML = `<span style="color:#dc2626">❌ Error: ${error.message}</span>`;
  }
}

function parseMultipleAlarms(text) {
  const alarms = [];
  
  try {
    // Try JSON format first
    const jsonData = JSON.parse(text);
    if (Array.isArray(jsonData)) {
      return jsonData.map((item, index) => {
        if (!item.name || !item.expression) {
          throw new Error(`Alarma ${index + 1}: requiere 'name' y 'expression'`);
        }
        return {
          name: item.name,
          severity: item.severity || 'warning',
          category: item.category || 'other',
          expression: item.expression,
          tag: item.tag || item.name.toLowerCase().replace(/\s+/g, '_'),
          clinical: item.clinical,
          suggest: item.suggest
        };
      });
    }
  } catch (e) {
    // If not JSON, try line-by-line format
  }
  
  // Line format: Name | severity | category | expression | clinical | suggest
  const lines = text.split('\n').filter(line => line.trim());
  
  lines.forEach((line, index) => {
    const parts = line.split('|').map(p => p.trim());
    if (parts.length >= 4) {
      alarms.push({
        name: parts[0],
        severity: parts[1] || 'warning',
        category: parts[2] || 'other',
        expression: parts[3],
        tag: parts[0].toLowerCase().replace(/\s+/g, '_'),
        clinical: parts[4] && parts[4] !== '' ? parts[4] : undefined,
        suggest: parts[5] && parts[5] !== '' ? parts[5] : undefined
      });
    } else if (parts.length > 1) {
      throw new Error(`Línea ${index + 1}: formato incorrecto. Use: Name | severity | category | expression | clinical | suggest`);
    }
  });
  
  if (alarms.length === 0) {
    throw new Error('No se encontraron alarmas válidas');
  }
  
  return alarms;
}

async function processMultipleAlarms() {
  const editor = byId('multipleAlarmsEditor');
  const result = byId('multipleValidationResult');
  if (!editor || !result) return;
  
  try {
    const text = editor.value.trim();
    if (!text) {
      result.innerHTML = '<span style="color:#f59e0b">⚠️ Agregue contenido al editor</span>';
      return;
    }
    
    const alarms = parseMultipleAlarms(text);
    let addedCount = 0;
    
    for (const alarm of alarms) {
      const rule = {
        id: Date.now() + addedCount,
        name: alarm.name,
        tag: alarm.tag,
        severity: alarm.severity,
        category: alarm.category,
        expression: alarm.expression,
        clinical: alarm.clinical,
        suggest: alarm.suggest,
        created: new Date().toLocaleString()
      };
      
      customAlarmRules.push(rule);
      addedCount++;
    }
    
    // Save and update
    saveAlarmsToStorage();
    renderAlarmRulesList();
    await autoUpdateBundle();
    
    result.innerHTML = `<span style="color:#16a34a">✅ ${addedCount} alarmas agregadas exitosamente!</span>`;
    
    // Clear editor
    editor.value = '';
    
    // Hide editor after success
    setTimeout(() => {
      hideMultipleAlarmsEditor();
    }, 2000);
    
  } catch (error) {
    result.innerHTML = `<span style="color:#dc2626">❌ Error: ${error.message}</span>`;
  }
}

// Modal functions
function showExplainModal(ruleSource, expression) {
  const modal = byId('explainModal');
  const title = byId('explainModalTitle');
  const content = byId('explainModalContent');
  const technical = byId('explainTechnicalDetails');
  
  if (!modal || !title || !content || !technical) return;
  
  // Determine what to show for clinical explanation
  let clinicalText = '';
  if (ruleSource && ruleSource.clinical) {
    clinicalText = ruleSource.clinical;
  } else if (ruleSource && ruleSource.label) {
    clinicalText = ruleSource.label;
  } else if (expression) {
    clinicalText = formatExpr(expression);
  } else {
    clinicalText = 'No clinical description available.';
  }
  
  title.textContent = 'Clinical Explanation';
  content.innerHTML = `<div style="line-height: 1.5; font-size: 14px;">${escapeHtml(clinicalText)}</div>`;
  technical.textContent = expression || 'No expression available';
  
  modal.style.display = 'block';
}

function showSuggestModal(ruleSource) {
  const modal = byId('suggestModal');
  const title = byId('suggestModalTitle');
  const content = byId('suggestModalContent');
  
  if (!modal || !title || !content || !ruleSource || !ruleSource.suggest) return;
  
  title.textContent = 'Suggested Actions';
  content.innerHTML = `<div style="line-height: 1.5; font-size: 14px;">${escapeHtml(ruleSource.suggest)}</div>`;
  
  modal.style.display = 'block';
}

function closeModal(modalId) {
  const modal = byId(modalId);
  if (modal) modal.style.display = 'none';
}

// Close modal when clicking outside
window.onclick = function(event) {
  const explainModal = byId('explainModal');
  const suggestModal = byId('suggestModal');
  if (event.target === explainModal) {
    explainModal.style.display = 'none';
  }
  if (event.target === suggestModal) {
    suggestModal.style.display = 'none';
  }
}

// Make functions global for onclick handlers
window.removeCondition = removeCondition;
window.editAlarmRule = editAlarmRule;
window.deleteAlarmRule = deleteAlarmRule;
window.readDeviceInputsFromDOM = readDeviceInputsFromDOM;
window.reloadAlarmsBundle = reloadAlarmsBundle;
window.autoUpdateBundle = autoUpdateBundle;
window.showExplainModal = showExplainModal;
window.showSuggestModal = showSuggestModal;
window.closeModal = closeModal;

</script>

<!-- Clinic Panel rendering script -->
<script>
  // Helper: get active timepoint object from collectAll() or DOM radios
  function getActiveTP(){
    try{
      if(typeof collectAll === 'function'){
        const all = collectAll();
        const active = all.find(r=>r.active) || all[0] || null;
        return active;
      }
    }catch(e){ console.warn('collectAll failed', e); }
    // DOM fallback
    try{
      const rd = document.querySelector('[id^="t_active_"]:checked');
      if(rd){ const idx = rd.id.replace('t_active_',''); return window._lastSeries && window._lastSeries[idx] ? window._lastSeries[idx] : { hours: parseFloat((document.getElementById(`t_hours_${idx}`)||{value:0}).value) }; }
    }catch(e){}
    return null;
  }

  // Clinic canonical variables to display in legend/trends
  const CLINIC_CANONICAL_VARS = [
    "HR","SBP","DBP","MAP","RAP","PCWP","sPAP","dPAP","mPAP","CO",
    "CI","SV","SVI","SVR","SVRI","PVR_WU","PVRI_WU","PAPI","pH","Lactate",
    "Creat","ALT","SvO2","ESP","EDV","ESV","EF","Ees","Ea","VAC",
    "SW","PE","PVA","Eff","CPO","CPI","CPOa","CPIa","OPP","CPP",
    "LVSWi","RVSWi","SCAI","devicesOn","drugsOn","inotropesOn","pressorsOn",
    "Impella","Impella_flow_Lmin","Impella_level"
  ];

  function renderClinicCanonicalLegend(tp){
    try{
      if(!tp) return '';
      const rows = CLINIC_CANONICAL_VARS.map(k=>{
        let v = tp[k];
        if(typeof v === 'number'){
          // choose precision: integers for large values, 2 decimals otherwise
          v = Math.abs(v) >= 100 ? Math.round(v) : (Number.isFinite(v) ? v.toFixed(2) : v);
        } else if(v === undefined || v === null){ v = '—'; }
        return `<div class="legendItem"><div style="width:10px;height:10px;margin-right:8px;display:inline-block"></div><div style="display:inline-block">${k}: <b>${escapeHtml(String(v))}</b></div></div>`;
      }).join('');
      return `<div class="clinicCanonicalLegend">${rows}</div>`;
    }catch(e){ return ''; }
  }

  function setActiveByHours(hours){
    try{
      if(typeof collectAll === 'function'){
        const all = collectAll();
        // if 'last', pick last active/last
        if(hours==='last'){ const lastIndex = all.length-1; if(lastIndex>=0){ setActiveIndex(lastIndex); return true; } }
        // find nearest by hours
        const target = parseFloat(hours);
        if(!Number.isFinite(target)) return false;
        let best = 0; let bestDiff = Infinity;
        all.forEach((tp,i)=>{ const h = parseFloat(tp.hours||tp.time||0); const d = Math.abs(h - target); if(d < bestDiff){ bestDiff = d; best = i; } });
        setActiveIndex(best);
        return true;
      }
    }catch(e){ console.warn('setActiveByHours failed', e); }
    return false;
  }

  function setActiveIndex(idx){
    try{
      // prefer DOM radios if present
      try{ // visually ensure only one radio looks checked
        document.querySelectorAll('input[name="activeTP"]').forEach(r=>{ try{ r.checked = false; }catch(e){} });
      }catch(e){}
      const rd = document.getElementById(`t_active_${idx}`);
      if(rd){ rd.checked = true; }
      // Also update underlying timepoint objects and re-generate
      const all = (typeof collectAll === 'function') ? collectAll() : null;
      if(Array.isArray(all)){
        all.forEach((a,i)=>{ a.active = (i===idx); });
      }
      // Keep clinic-local state in sync when global synchronization is enabled.
      // Without this, the clinic panel may prefer a previously-set clinic-local
      // active index (window._clinicState.active) and therefore display a
      // different active TP than the dashboard even when global sync is expected.
      try{
        window._clinicState = window._clinicState || {};
        if(window.GLOBAL_SYNC_TIMEPOINTS !== false){
          window._clinicState.active = idx;
          // ensure shown array exists and marks this TP visible
          if(!Array.isArray(window._clinicState.shown)){
            window._clinicState.shown = (Array.isArray(all) ? all.map(()=>true) : []);
          }
          if(window._clinicState.shown.length <= idx){
            for(let i = window._clinicState.shown.length; i <= idx; i++) window._clinicState.shown[i] = true;
          }
          window._clinicState.shown[idx] = true;
        }
      }catch(e){}
      if(typeof generateAll === 'function') generateAll();
      // slight delay, then render panel
      setTimeout(()=>{ try{ renderClinicPanel(); }catch(e){} }, 120);
    }catch(e){ console.warn('setActiveIndex', e); }
  }
  // Clinic-specific active helpers (clinic-local selection independent of dashboard)
  // Clinic active index setter. By default this will SYNC globally so selecting a
  // TP in Clinic will make it the global active TP across the app. To disable
  // global synchronization set `window.GLOBAL_SYNC_TIMEPOINTS = false`.
  window.setClinicActiveIndex = function(idx){
    try{
      window._clinicState = window._clinicState || {};
      // Mark the requested index as the clinic-local active index
      window._clinicState.active = idx;
      // Ensure the clinic-local 'shown' array marks this TP as visible so clinic tools render correctly
      try{ if(!Array.isArray(window._clinicState.shown)) window._clinicState.shown = (typeof collectAll === 'function' ? collectAll().map(()=>true) : []); if(window._clinicState.shown.length <= idx) { for(let i=window._clinicState.shown.length;i<=idx;i++) window._clinicState.shown[i] = true; } window._clinicState.shown[idx] = true; }catch(e){}

      // If global sync is enabled (default), prefer the shared setter which will
      // update dashboard radios, call generateAll(), and re-render panels.
      if(window.GLOBAL_SYNC_TIMEPOINTS !== false && typeof setActiveIndex === 'function'){
        try{ setActiveIndex(idx); }catch(e){}
        // also ensure the dashboard "on" checkbox is checked so the TP becomes visible
        try{ const onChk = byId(`t_on_${idx}`); if(onChk && !onChk.checked){ onChk.checked = true; try{ onChk.dispatchEvent(new Event('change')); }catch(e){} } }catch(e){}
        // create/update clinic menu after global change
        try{ createClinicTimesMenu(); }catch(e){}
      } else {
        // Local-only behavior: re-render clinic panel and keep dashboard untouched
        try{ renderClinicPanel(); }catch(e){}
        try{ createClinicTimesMenu(); }catch(e){}
      }
    }catch(e){ console.warn('setClinicActiveIndex', e); }
  };
  window.setClinicActiveByHours = function(hours){ try{ const all = (typeof collectAll==='function')? collectAll():[]; if(hours==='last'){ const last = all.length-1; if(last>=0) { window.setClinicActiveIndex(last); return true; } } const target = parseFloat(hours); if(!Number.isFinite(target)) return false; let best=0; let bestDiff=Infinity; all.forEach((tp,i)=>{ const h = parseFloat(tp.hours||tp.time||0); const d = Math.abs(h - target); if(d < bestDiff){ bestDiff = d; best = i; } }); window.setClinicActiveIndex(best); return true; }catch(e){ console.warn('setClinicActiveByHours', e); return false; } };

  // Clinic Alarm Badges renderer — aggregates alarms per group into a single circular badge with a conic-gradient ring
  window.renderClinicAlarmBadges = function(activeAlarms){
    try{
      const wrap = document.getElementById('clinicAlarmBadges'); if(!wrap) return;
      if(!Array.isArray(activeAlarms) || activeAlarms.length===0){ wrap.innerHTML=''; return; }
      // Aggregate by group -> severity counts
      const COLORS = { critical:'#dc2626', warning:'#f59e0b', improving:'#16a34a', wean_ok:'#1f6fff' };
      const groups = {};
      activeAlarms.forEach(a=>{
        const g = (a.group||'other').toString().toLowerCase();
        const sev = (a.color||'').toString().toLowerCase();
        groups[g] = groups[g] || { total:0, counts:{critical:0,warning:0,improving:0,wean_ok:0} };
        groups[g].total += 1;
        if(groups[g].counts[sev] !== undefined) groups[g].counts[sev] += 1; else groups[g].counts.warning += 1; // unknown -> warning
      });
      // Helper to build conic-gradient string from severity counts
      function gradientFor(cnt){
        const total = Math.max(1, cnt.total);
        const parts = [];
        const order = ['wean_ok','improving','warning','critical']; // clockwise order
        order.forEach(key=>{
          const pct = ( (cnt.counts[key]||0) / total ) * 100;
          if(pct>0) parts.push({ color: COLORS[key], pct });
        });
        let acc = 0; const segs = [];
        parts.forEach(p=>{ const next = acc + p.pct; segs.push(`${p.color} ${acc}% ${next}%`); acc = next; });
        if(acc < 100) segs.push(`#e6eefb ${acc}% 100%`); // remainder muted
        return `conic-gradient(${segs.join(',')})`;
      }
      // Show aggregates for main groups
      const wanted = ['congestion','perfusion','metabolic','trends','mcs','weaning','other'];
      const items = wanted.filter(k=> groups[k] && groups[k].total>0).map(k=>({ key:k, agg: groups[k] }));
      
      // Add individual device badges (these come with isDevice flag)
      const deviceBadges = activeAlarms.filter(a => a.isDevice === true);
      
      if(items.length===0 && deviceBadges.length===0){ wrap.innerHTML=''; return; }
      const ICONS = {
        congestion: 'Badges/Congestion.ico',
        perfusion: 'Badges/Perfusion_Power .ico',
        metabolic: 'Badges/Metabolic_Labs.ico',
        trends: 'Badges/trends.ico',
        mcs: 'Badges/MCS-specific.ico',
        weaning: 'Badges/Weaning candidates.ico', 
        other: 'Badges/Other_Escalation.ico'
      };
      const LABELS = { congestion:'Congestion', perfusion:'Perfusion / Power', metabolic:'Metabolic / Labs', trends:'Trends', mcs:'MCS', weaning:'Weaning', other:'Other' };
      
      // Render alarm aggregate badges
      const html = items.map(it=>{
        const g = it.key; const cnt = it.agg; const total = cnt.total;
        const ring = gradientFor(cnt);
        const label = LABELS[g] || (g.charAt(0).toUpperCase()+g.slice(1));
        const title = `${label} — ${total} alarm` + (total>1?'s':'');
        const icon = ICONS[g] || ICONS.other;
        const legend = `🔴${cnt.counts.critical||0} ⚠️${cnt.counts.warning||0} 🟢${cnt.counts.improving||0} 🔵${cnt.counts.wean_ok||0}`;
        return `
          <div class="agg-badge" title="${escapeHtml(title+' · '+legend)}" style="display:flex;flex-direction:column;align-items:center;gap:8px;min-width:96px">
            <div style="position:relative;width:80px;height:80px;border-radius:50%;background:${ring};display:flex;align-items:center;justify-content:center;box-shadow:inset 0 0 0 3px rgba(27,43,73,0.06)">
              <img src="${icon}" alt="${escapeHtml(g)}" style="width:90%;height:90%;object-fit:contain" onerror="this.onerror=null; this.src='Badges/Other_Escalation.ico';"/>
            </div>
            <div style="font-size:13px;font-weight:600;color:#234">${escapeHtml(label)}</div>
          </div>`;
      }).join('');
      
      // Render device badges (solid clinical blue ring for active device)
      const deviceHtml = deviceBadges.map(d => {
        const label = d.label || '';
        const icon = d.icon || 'Badges/MCS-specific.ico';
        const blueRing = 'conic-gradient(rgba(95, 143, 253, 0.5) 0% 100%)'; // light blue 50% transparent
        return `  
          <div class="agg-badge device-badge" title="${escapeHtml(label + ' — Active')}" style="display:flex;flex-direction:column;align-items:center;gap:8px;min-width:96px">
            <div style="position:relative;width:80px;height:80px;border-radius:50%;background:${blueRing};display:flex;align-items:center;justify-content:center;box-shadow:inset 0 0 0 3px rgba(27,43,73,0.06)">
              <img src="${icon}" alt="${escapeHtml(label)}" style="width:90%;height:90%;object-fit:contain" onerror="this.onerror=null; this.src='Badges/MCS-specific.ico';"/>
            </div>
            <div style="font-size:13px;font-weight:600;color:#234">${escapeHtml(label)}</div>
          </div>`;
      }).join('');
      
      wrap.innerHTML = html + deviceHtml;
    }catch(e){ /* ignore */ }
  }

  // Render Clinic Panel independently (uses clinic-local shown/active state)
  function renderClinicPanel(){
    const all = (typeof collectAll === 'function') ? collectAll() : [];
  // Default: all timepoints should be shown (active) unless the user explicitly changes them.
  // If an existing _clinicState is present but has a different length (old patient), replace shown with all-true.
  const defaultShown = all.map(()=> true);
  const existingShown = (window._clinicState && Array.isArray(window._clinicState.shown)) ? window._clinicState.shown : null;
  const shown = (existingShown && existingShown.length === all.length) ? existingShown.map(v=> typeof v === 'boolean' ? v : true) : defaultShown;
  window._clinicState = window._clinicState || {};
  window._clinicState.shown = shown;
  window._clinicState.active = (window._clinicState.active !== undefined) ? window._clinicState.active : (all.findIndex(r=>r.active&&r.on)>=0? all.findIndex(r=>r.active&&r.on): (all.findIndex(r=>r.on)>=0? all.findIndex(r=>r.on):0));
    // basic patient metadata
    byId('clinicPatientName') && (byId('clinicPatientName').textContent = byId('patientName')?.value || '—');
    byId('clinicPatientAge') && (byId('clinicPatientAge').textContent = byId('ptAge')?.value || '—');
    byId('clinicPatientSex') && (byId('clinicPatientSex').textContent = byId('ptSex')?.value || '—');
    if(byId('clinicPatientCS')){
      try{
        const csChecked = document.querySelector('#csTypeGroup input:checked');
        let csText = 'General';
        if(csChecked){
          const v = (csChecked.value||'').toString().toLowerCase();
          if(v === 'ami') csText = 'AMI-CS';
          else if(v === 'hf') csText = 'HF-CS';
          else csText = csChecked.nextElementSibling?.textContent?.trim() || 'General';
        }
        byId('clinicPatientCS').textContent = csText;
      }catch(e){ byId('clinicPatientCS').textContent = 'General'; }
    }
    byId('clinicPatientHeight') && (byId('clinicPatientHeight').textContent = byId('ptH')?.value || '—');
    byId('clinicPatientWeight') && (byId('clinicPatientWeight').textContent = byId('ptW')?.value || '—');
    byId('clinicPatientBMI') && (byId('clinicPatientBMI').textContent = byId('chipBMI')?.textContent?.replace('BMI','').trim() || '—');
    byId('clinicPatientBSA') && (byId('clinicPatientBSA').textContent = byId('chipBSA')?.textContent?.replace('BSA','').trim() || '—');

  // Build clinic-local copy
  const clinicAll = all.map((r,i)=> Object.assign({}, r, { on: !!(window._clinicState.shown && window._clinicState.shown[i]), active: (i === (window._clinicState.active||0)) }));
  // determine clinic-local active timepoint (used for annotations, gauges, alarms)
  const activeClinic = clinicAll.find(r=>r.active && r.on) || clinicAll.find(r=>r.on) || clinicAll[0] || null;
  // safe resize helper: only call Plotly resize when element is displayed; retry a few times
  const scheduleSafeResize = function(el, attempts=6, interval=220){ try{ let tries=0; const tick = function(){ try{ if(!el) return; const rect = el.getBoundingClientRect(); if(rect.width>1 && rect.height>1){ try{ window.Plotly && window.Plotly.Plots && typeof window.Plotly.Plots.resize === 'function' && window.Plotly.Plots.resize(el); }catch(e){} return; } if(tries < attempts){ tries++; setTimeout(tick, interval); } }catch(e){} }; tick(); }catch(e){} };
  // Observe Clinic grid size changes to trigger Plotly resize precisely on reflow
  function ensureClinicResizeObserver(){
    try{
      if(window._clinicROAttached) return;
      if(typeof ResizeObserver === 'undefined') return;
      const grid = document.querySelector('.clinic-grid');
      if(!grid) return;
      const ro = new ResizeObserver(()=>{
        try{ const plotEl = document.querySelector('#clinicPVPlot'); if(plotEl) safePlotlyResize(plotEl); }catch(e){}
      });
      ro.observe(grid);
      // also observe PV wrapper for internal height changes
      const pvWrap = document.getElementById('clinicPVLoops'); if(pvWrap) ro.observe(pvWrap);
      window._clinicROAttached = true;
    }catch(e){}
  }

    const pvDiv = byId('clinicPVLoops');
    if(pvDiv){
      // keep clinicGroupedVars inside the PV wrapper so it isn't destroyed by innerHTML resets
  pvDiv.innerHTML = '<div id="clinicPVPlot"></div><div id="pvLegendClinic" style="margin-top:8px"></div><div id="clinicSupportTimeline" style="margin-top:8px"></div><div id="clinicGroupedVars" style="margin-top:12px"></div>';
      const plotEl = pvDiv.querySelector('#clinicPVPlot');
      const legendEl = pvDiv.querySelector('#pvLegendClinic');
      try{
        if(window.renderers && typeof window.renderers.createPVSpec === 'function'){
          const spec = window.renderers.createPVSpec(clinicAll, { clinicMode: true });
          const doPlot = ()=>{ try{ window.Plotly.newPlot(plotEl, spec.data, spec.layout, spec.config); try{ scheduleSafeResize(plotEl); }catch(e){}; if(legendEl){ const tpForLegend = activeClinic || clinicAll.find(r=>r.active && r.on) || clinicAll[0];
                  // Diagnostic: show color swatches for loop traces so it's easy to tell if per-timepoint coloring is active
                  try{
                    const swatches = (spec.data || []).filter(t=> t && t.line && t.line.color).map((t,i)=> `<span title="${escapeHtml(String(t.name||i))}" style="display:inline-block;width:18px;height:12px;background:${t.line.color};margin-right:6px;border:1px solid #cbd5e1"></span>`).join('');
                    const colorRow = swatches ? `<div style="margin-top:8px">Colors: ${swatches}</div>` : '';
                    legendEl.innerHTML = renderClinicCanonicalLegend(tpForLegend) + (spec.legendHtml || '') + colorRow;
                  }catch(e){ legendEl.innerHTML = renderClinicCanonicalLegend(tpForLegend) + (spec.legendHtml || ''); }
                } try{ renderClinicSupportTimeline(clinicAll, activeClinic); }catch(e){} }catch(e){ console.warn('clinic Plotly newPlot failed', e); } };
          if(typeof window.Plotly === 'undefined' && typeof window.loadPlotly === 'function'){
            window.loadPlotly().then(()=>{ doPlot(); }).catch(e=>{ console.warn('loadPlotly failed for clinic', e); });
                    } else { doPlot(); try{ setTimeout(()=>{ safePlotlyResize(plotEl); }, 160); }catch(e){} }
        } else {
          // Inline fallback similar to dashboard but independent
          // Build traces with clinic-mode per-timepoint colors (hsl hues) so all PV elements share the same color
          const traces = [];
          const vis = clinicAll.filter(r=>r.on);
          const Nvis = vis.length;
          function timeHue(i){ return 200 - ( (i / Math.max(1, Nvis-1)) * 180 ); }
          vis.forEach((r, idx)=>{
            const h = timeHue(idx);
            const defaultCol = (typeof hslColor === 'function') ? hslColor(idx) : `hsl(${Math.round(h)},70%,45%)`;
            const timeColor = (r && r.color) ? r.color : defaultCol;
            const fillColor = (r && r.color) ? (function(col){ try{ if(col.startsWith('hsl')) return col.replace('hsl','hsla').replace(')',',0.15)'); if(col.startsWith('#')){ const c = col.replace('#',''); const bigint = parseInt(c.length===3? c.split('').map(ch=>ch+ch).join('') : c,16); const rch = (bigint>>16)&255; const gch = (bigint>>8)&255; const bch = bigint&255; return `rgba(${rch},${gch},${bch},0.15)`; } return col; }catch(e){ return defaultCol; } })(r.color) : (function(col){ try{ if(col.startsWith('hsl')) return col.replace('hsl','hsla').replace(')',',0.15)'); if(col.startsWith('#')){ const cc = col.replace('#',''); const bigint = parseInt(cc.length===3? cc.split('').map(ch=>ch+ch).join('') : cc,16); const rch = (bigint>>16)&255; const gch = (bigint>>8)&255; const bch = bigint&255; return `rgba(${rch},${gch},${bch},0.15)`; } return col; }catch(e){ return defaultCol; } })(defaultCol);
            try{ if(!r._pvColor) r._pvColor = timeColor; if(!r._pvFillColor) r._pvFillColor = fillColor; }catch(e){}
            traces.push({ x:r.V_loop, y:r.P_loop, mode:'lines', name:`${r.time}`, line:{color:r._pvColor,width:r.active?4:3}, showlegend:false });
            if(r.active){
              traces.push({x:r.V, y:r.P_EDPVR, mode:'lines', name:`EDPVR ${r.time}`, line:{color:r._pvColor, dash:'dot', width:2}, showlegend:false});
              traces.push({x:r.V_espvr, y:r.P_espvr, mode:'lines', name:`Ees (ESPVR) ${r.time}`, line:{color:r._pvColor, dash:'dash', width:2}, showlegend:false});
              traces.push({x:r.V_ea, y:r.P_ea, mode:'lines', name:`Ea ${r.time}`, line:{color:r._pvColor, dash:'dot', width:2}, showlegend:false});
              traces.push({x:r.V_loop.concat([r.V_loop[0]]), y:r.P_loop.concat([0]), fill:'toself', mode:'lines', line:{color:r._pvColor,width:0}, fillcolor:r._pvFillColor, name:`SW area ${r.time}`, showlegend:false, hoverinfo:'skip', opacity:1});
            }
          });
          const active = clinicAll.find(r=>r.active && r.on) || clinicAll.find(r=>r.on) || clinicAll[0];
          // Clinic view intentionally hides PV helper annotations (V₀ and VAC)
          const ann = [];
    const layout = { paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)', xaxis:{title:'Volume (mL)',color:'#0b1b33', gridcolor:'#e7eefc'}, yaxis:{title:'Pressure (mmHg)',color:'#0b1b33', gridcolor:'#e7eefc', range:[0,150]}, showlegend:false, annotations:ann, margin:{t:30}, font:{ family:'Inter, Arial, sans-serif', size:14, color:'#0b1b33' } };
          const config = {displaylogo:false,responsive:true,modeBarButtonsToRemove:['lasso2d','select2d']};
          const doInlinePlot = ()=>{
            try{ window.Plotly.newPlot(plotEl, traces, layout, config); scheduleSafeResize(plotEl); if(legendEl){ const tpForLegend = active || clinicAll.find(r=>r.active && r.on) || clinicAll[0]; legendEl.innerHTML = renderClinicCanonicalLegend(tpForLegend); } try{ renderClinicSupportTimeline(clinicAll, activeClinic); }catch(e){} }catch(e){ console.warn('clinic inline plotly failed', e); }
          };
          if(typeof window.Plotly === 'undefined' && typeof window.loadPlotly === 'function'){ window.loadPlotly().then(()=>{ doInlinePlot(); }).catch(()=>{}); } else { doInlinePlot(); }
        }
      }catch(e){ console.warn('clinic PV render failed', e); }
  try{ setTimeout(()=>{ safePlotlyResize(plotEl); }, 260); }catch(e){}
    }

    // Smart alarms: render using the shared renderAlarms function so clinic matches dashboard
    try{
      // Use clinicAll (which represents clinic-local shown/active flags) as the series input
      renderAlarms(clinicAll, 'clinicSmartAlarms');
        // BADGES: aggregate all active alarms by group for the active TP
        if (typeof renderClinicAlarmBadges === 'function') {
          // Prefer the flat list produced by renderAlarms (keeps logic in one place)
          const flat = (window._LAST_ACTIVE_ALARMS && window._LAST_ACTIVE_ALARMS['clinicSmartAlarms']) || [];
          const actives = Array.isArray(flat) ? flat : [];
          
          // Also add badges for active MCS devices (independent of alarms)
          const activeTP = activeClinic || clinicAll.find(r=>r.active && r.on) || clinicAll[0];
          if(activeTP && activeTP.devs){
            const deviceBadges = [];
            const DEVICE_ICONS = {
              IABP: 'Badges/IABP.ico',
              Impella: 'Badges/Impella.ico',
              ECMO: 'Badges/ECMO.ico',
              VAD: 'Badges/VAD.ico'
            };
            const devices = ['IABP', 'Impella', 'ECMO', 'VAD'];
            devices.forEach(dev => {
              if(activeTP.devs[dev]){
                deviceBadges.push({
                  group: 'device',
                  color: 'improving', // green for active device
                  label: dev,
                  tag: dev.toLowerCase(),
                  isDevice: true,
                  icon: DEVICE_ICONS[dev]
                });
              }
            });
            // Merge device badges with alarm badges
            const combined = [...actives, ...deviceBadges];
            renderClinicAlarmBadges(combined);
          } else {
            renderClinicAlarmBadges(actives);
          }
        }
    }catch(e){ console.warn('clinic renderAlarms failed', e); }

  // Sync clinic status pill with clinic-local series
    const clinicPill = byId('clinicStatusPill');
    try{
      if(clinicPill){ const st = statusFromSeries(clinicAll); clinicPill.className = `status ${st==='improve'?'improve':(st==='worse'?'worse':'stable')}`; clinicPill.textContent = st==='improve'?'↑ Improving':(st==='worse'?'↓ Worsening':'● Stable'); }
    }catch(e){ console.warn('clinic status update failed', e); }

    // update quick buttons to reflect visible timepoints
    try{ createClinicQuickButtons(); }catch(e){}

  // Prognosis / outcome probabilities: populate the new clinic panel (if renderer available)
  try{ if(window.renderers && typeof window.renderers.renderClinicPrognosis === 'function'){ window.renderers.renderClinicPrognosis(clinicAll); } }catch(e){ console.warn('renderClinicPrognosis failed', e); }
  // Render compact RAP vs PCWP mini-plot (if available) into clinic-specific containers
  try{ if(window.renderers && typeof window.renderers.renderHemo === 'function'){ window.renderers.renderHemo(clinicAll, { element: 'plotHemoClinic', legendElement: 'hemoLegendClinic', small: true }); } }catch(e){ console.warn('renderHemo (clinic mini) failed', e); }
  // Aggressive relayout+resize attempts to ensure the clinic hemo plot is visible on
  // devices where the container was initially hidden or resized (iPad portrait, etc.).
  try{
    if(window.Plotly && typeof window.Plotly.relayout === 'function'){
      const tryRelayout = function(){
        try{
          const el = byId('plotHemoClinic'); if(!el) return false;
          // perform a no-op relayout (triggers internal reflow) then resize
          try{ window.Plotly.relayout(el, {}); }catch(e){}
          try{ if(window.Plotly.Plots && typeof window.Plotly.Plots.resize === 'function') window.Plotly.Plots.resize(el); else if(typeof window.Plotly.resize === 'function') window.Plotly.resize(el); }catch(e){}
          return true;
        }catch(e){ return false; }
      };
      // Retry at increasing delays (short, medium, longer)
      [150, 450, 900].forEach(function(delay){ setTimeout(tryRelayout, delay); });
    }
  }catch(e){ /* ignore resize failures */ }

    // Gauges: render small Plotly indicator gauges for visual parity with dashboard
    const gaugeDiv = byId('clinicGaugeContainer');
    if(gaugeDiv){
      const tp = activeClinic || getActiveTP();
      if(!tp){ gaugeDiv.innerHTML = '<div class="small">No gauge data</div>'; }
      else {
        const gauges = [
          {id:'CI', val:tp.CI, min:0, max:5, title:'CI (L/min/m²)'},
          {id:'SVI', val:tp.SVI, min:0, max:120, title:'SVI (mL/m²)'},
          {id:'CPO', val:tp.CPO, min:0, max:10, title:'CPO (W)'},
          {id:'SVR', val:tp.SVR, min:0, max:3000, title:'SVR'},
          {id:'PVR', val:tp.PVR_WU, min:0, max:10, title:'PVR (WU)'},
          {id:'VAC', val:tp.VAC, min:0, max:3, title:'VAC'}
        ];
        gaugeDiv.innerHTML = '<div class="gaugeGrid">' + gauges.map(g=>`<div><div id="clinic_gauge_${g.id}" class="gauge-plot" style="width:100%;height:220px"></div><div class="gauge-label">${g.title}</div></div>`).join('') + '</div>';

        const draw = function(){
          try{
            if(!window.Plotly || typeof window.Plotly.newPlot !== 'function') return;
            gauges.forEach(g=>{
              try{
                const el = byId('clinic_gauge_'+g.id); if(!el) return;
                const value = Number.isFinite(g.val)? g.val : 0;
                const spec = [{ type: 'indicator', mode: 'gauge+number', value: value, title: { text: g.id, font: { size: 12 } }, gauge: { axis: { range: [g.min, g.max] }, bar: { color: '#1f6fff' }, steps: [ { range: [g.min, (g.max-g.min)*0.6 + g.min], color: '#eaf4ff' } ] } }];
                Plotly.newPlot(el, spec, { margin:{t:10,b:10,l:10,r:10}, paper_bgcolor:'transparent', plot_bgcolor:'transparent' }, {displaylogo:false,responsive:true});
              }catch(e){ console.warn('clinic gauge draw failed', e); }
            });
          }catch(e){ console.warn('draw clinic gauges failed', e); }
        };

        if(window.Plotly && typeof window.Plotly.newPlot === 'function') draw();
        else if(typeof window.loadPlotly === 'function') window.loadPlotly().then(draw).catch(()=>{ /* ignore */ });
      }
    }

  const trendsDiv = byId('clinicTrends');
  if(trendsDiv){
    try{
      const tp = activeClinic || getActiveTP();
      if(!tp){ trendsDiv.innerHTML = '<div class="small">No trend data</div>'; }
      else {
        // Build a readable grid that shows ONLY percent-change for each canonical var.
        // Values are presumed shown elsewhere in the card; here we keep a compact grid of % deltas.
        const fmtPct = (p)=>{ if(!Number.isFinite(p)) return ''; const s = Math.abs(p).toFixed(1) + '%'; return (p>=0? '↑'+s : '↓'+s); };

        // helpers to compute percent-change from signals or previous TP (generic)
        const computePctFromSignals = (name) => {
          try{
            const arr = (window.signals && window.signals[name]) ? window.signals[name] : null;
            if(!Array.isArray(arr) || arr.length < 2) return null;
            const last = Number(arr[arr.length-1].v ?? arr[arr.length-1]);
            const prev = Number(arr[arr.length-2].v ?? arr[arr.length-2]);
            if(!Number.isFinite(last) || !Number.isFinite(prev)) return null;
            return ((last - prev) / Math.max(prev, 1e-9)) * 100;
          }catch(e){ return null; }
        };
        const computePctFromPrevTP = (key)=>{
          try{
            if(typeof collectAll !== 'function') return null;
            const all = collectAll(); if(!Array.isArray(all) || all.length < 2) return null;
            const idx = all.findIndex(x=> x === tp || (x.time !== undefined && tp.time !== undefined && String(x.time) === String(tp.time)) );
            if(idx === 0) return null; // baseline/first TP: do not compute trends
            const prevIdx = (idx>0) ? idx-1 : null; if(prevIdx===null) return null;
            const last = Number(all[idx][key]); const prev = Number(all[prevIdx][key]);
            if(!Number.isFinite(last) || !Number.isFinite(prev)) return null;
            return ((last - prev) / Math.max(prev, 1e-9)) * 100;
          }catch(e){ return null; }
        };

        // detect baseline (first TP) and if so, do not show any trends
        let isBaseline = false;
        try{ if(typeof collectAll === 'function'){ const all = collectAll(); const idx = Array.isArray(all)? all.findIndex(x=> x===tp || (x.time!==undefined && tp.time!==undefined && String(x.time)===String(tp.time))) : -1; if(idx === 0) isBaseline = true; } }catch(e){}
        if(isBaseline){ trendsDiv.innerHTML = '<div class="small">No trends for baseline</div>'; }
        else {
          const EXCLUDE_TRENDS = new Set(['devicesOn','drugsOn','inotropesOn','pressorsOn','Impella','Impella_flow_Lmin','deviceson','drugson','inotropeson','presserson','impella','impella_flow_lmin']);
          const items = [];
          (Array.isArray(CLINIC_CANONICAL_VARS) ? CLINIC_CANONICAL_VARS : []).forEach(k=>{
            try{
              // skip variables the user requested to hide from trends
              if(EXCLUDE_TRENDS.has(k) || EXCLUDE_TRENDS.has(k.toLowerCase())) return;
              // compute pct change: prefer explicit, else signals, else prev TP
              let pct = null;
              const pctField = (tp[`${k}_pct_change`] !== undefined) ? tp[`${k}_pct_change`] : (tp[`${k.toLowerCase()}_pct_change`] !== undefined ? tp[`${k.toLowerCase()}_pct_change`] : undefined);
              if(Number.isFinite(pctField)) pct = pctField;
              if(pct === null) pct = computePctFromSignals(k) ?? computePctFromSignals(k.toLowerCase());
              if(pct === null) pct = computePctFromPrevTP(k) ?? computePctFromPrevTP(k.toLowerCase());
              if(Number.isFinite(pct)){
                const label = escapeHtml(String(k));
                const pctTxt = escapeHtml(fmtPct(pct));
                items.push(`<div style="min-width:120px;padding:6px 8px;border-radius:6px;background:rgba(31,111,255,0.06);color:#1f6fff;font-size:12px">${label}: <strong style=\"margin-left:6px\">${pctTxt}</strong></div>`);
              }
            }catch(e){ /* ignore per-var */ }
          });

          if(!items.length){ trendsDiv.innerHTML = '<div class="small">No trend data</div>'; }
          else {
            trendsDiv.innerHTML = `<div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">${items.join('')}</div>`;
          }
        }
      }
    }catch(e){ try{ console.warn('clinic trends update failed', e); }catch(_){} }
  }
    // Render grouped variables under PV loops
    try{ renderClinicGroupedVars(clinicAll, activeClinic); }catch(e){ console.warn('renderClinicGroupedVars call failed', e); }
    // Ensure Plotly resizes after render so the plot appears correctly when the panel is revealed
    try{
  const scheduleClinicResize = function(){ try{ const plotEl = pvDiv && pvDiv.querySelector('#clinicPVPlot'); if(plotEl) scheduleSafeResize(plotEl); ensureClinicResizeObserver(); }catch(e){} };
      scheduleClinicResize();
    }catch(e){ /* ignore */ }

    // Clinical summary removed per user request
  }

  // Build the quick buttons area from the dashboard timepoints (only show those with on=true)
  function createClinicQuickButtons(){
    const wrap = byId('clinicQuickButtons'); if(!wrap) return;
    try{
      const all = (typeof collectAll === 'function') ? collectAll() : [];
      // Clear existing
      wrap.innerHTML = '';
      // If no user-visible timepoints, show default baseline buttons (last fallback)
  // Show every timepoint as a quick button (do not hide buttons for timepoints that are off)
  const visible = all.map((t,i)=> ({...t, i}));
      if(visible.length === 0){
        // show a minimal default set
        const defaults = [{label:'Basal', val:0},{label:'6h', val:6},{label:'12h', val:12},{label:'24h', val:24},{label:'Last', val:'last'}];
        defaults.forEach(d=>{
          const b = document.createElement('button'); b.className='btn'; b.textContent = d.label; b.dataset.ct = d.val; b.addEventListener('click', ()=>{ if(d.val==='last') setClinicActiveByHours('last'); else setClinicActiveByHours(parseFloat(d.val)); });
          wrap.appendChild(b);
        });
        return;
      }
      // Create one button per visible timepoint, using label or time/hours when available
      visible.forEach(t=>{
        const b = document.createElement('button'); b.className='btn';
        const label = (t.label && String(t.label).trim()) ? t.label : (t.time!==undefined? String(t.time) : (t.hours!==undefined? String(t.hours) : `TP ${t.i}`));
        b.textContent = label;
        // Tooltip: include time and a representative metric (CI) when available
        try{ const timeStr = (t.time!==undefined? t.time : (t.hours!==undefined? t.hours : '—')); const ciStr = (t.CI || t.CI===0) ? (`CI: ${Number.isFinite(t.CI)? t.CI.toFixed(2): t.CI}`) : ''; b.title = (t.label? t.label + ' — ':'') + `time: ${timeStr}` + (ciStr? (' · ' + ciStr) : ''); }catch(e){}
        b.addEventListener('click', ()=>{ window.setClinicActiveIndex(t.i); try{ createClinicQuickButtons(); }catch(e){} });
        // highlight active button based on clinic-local active index
        try{ const activeIdx = window._clinicState && Number.isFinite(window._clinicState.active) ? window._clinicState.active : null; if(activeIdx === t.i) b.classList.add('primary'); }
        catch(e){}
        wrap.appendChild(b);
      });
      // Append a 'Last' button for convenience
  const lastB = document.createElement('button'); lastB.className='btn'; lastB.textContent='Last'; lastB.addEventListener('click', ()=>{ setClinicActiveByHours('last'); }); wrap.appendChild(lastB);
    }catch(e){ console.warn('createClinicQuickButtons failed', e); }
  }

  function escapeHtml(s){ if(!s) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Render a compact per-timepoint support timeline (devices and key drugs)
  function renderClinicSupportTimeline(clinicAll, activeClinic){
    try{
      const wrap = byId('clinicSupportTimeline'); if(!wrap) return;
      const all = Array.isArray(clinicAll) ? clinicAll : (typeof collectAll === 'function' ? collectAll() : []);
      const vis = all.filter(r=> r && r.on);
      const active = activeClinic || vis.find(r=>r.active) || vis[0] || null;
      if(!vis.length){ wrap.innerHTML = '<div class="small">No support data</div>'; return; }

      // If SCAI stage data is present, render a compact SCAI walker at the
      // top of the clinic support timeline so it matches the dashboard style.
      try{
        const hasScai = Array.isArray(all) && all.some(r=> r && (r.SCAI !== undefined && r.SCAI !== null));
        let walkerHtml = '';
        if(hasScai){
          const stageColors = { 'A':'#10b981', 'B':'#1f6fff', 'C':'#f59e0b', 'D':'#ef4444', 'E':'#6b7280' };
          const points = all.map((r,i)=>({ stage: (r && r.SCAI) ? r.SCAI : 'C', time: (r && (r.time!==undefined? r.time : r.hours!==undefined? r.hours : i)), origIdx: i, visible: !!(r && r.on), color: stageColors[(r && r.SCAI) ? r.SCAI : 'C'] }));
          walkerHtml += '<div class="clinic-scai-walker" style="padding:6px 0;margin-bottom:8px">';
          walkerHtml += '<div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">';
          points.forEach((p,pi)=>{
            const badgeOpacity = p.visible === false ? 0.5 : 1.0;
            walkerHtml += `
              <div class="scai-walker-badge" data-orig-idx="${p.origIdx}" style="display:flex;flex-direction:column;align-items:center;gap:6px;opacity:${badgeOpacity};cursor:pointer">
                <div class="scai-circle" style="position:relative;width:52px;height:52px;border-radius:50%;background:${p.color};display:flex;align-items:center;justify-content:center;box-shadow:0 3px 8px ${p.color}40;color:#fff;font-family:Inter, Arial, sans-serif;font-size:20px;font-weight:500">
                  <span class="scai-letter">${p.stage}</span>
                </div>
                <div class="stage-time" style="font-size:12px;font-weight:600;color:var(--muted)">${p.time}h</div>
              </div>
            `;
            if(pi < points.length - 1){
              walkerHtml += `
                <div style="display:flex;align-items:center;margin:0 -2px">
                  <svg width="20" height="14" viewBox="0 0 28 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 9 L22 9 M16 3 L22 9 L16 15" stroke="#cbd5e1" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </div>
              `;
            }
          });
          walkerHtml += '</div></div>';
        }
        // Build support cards (existing implementation will render below)
        const cardsHtml = vis.map(tp=>{
          const isActive = active && (tp===active || (String(tp.time)===String(active.time)));
          const title = (tp.label && String(tp.label).trim()) ? tp.label : (tp.time!==undefined? String(tp.time) : (tp.hours!==undefined? String(tp.hours)+'h' : 'TP'));
          return `<div class="support-tp${isActive?' active':''}"><div class="support-t"><strong>${escapeHtml(title)}</strong></div><div class="support-pills">${pillsForTP(tp)}</div></div>`;
        }).join('');

        wrap.innerHTML = (walkerHtml || '') + `<div class="clinic-support-timeline">${cardsHtml}</div>`;

        // Inject blink CSS for clinic walker once
        if(typeof document !== 'undefined' && !document.getElementById('scai-walker-clinic-style')){
          const ss = document.createElement('style'); ss.id = 'scai-walker-clinic-style'; ss.textContent = `
            .clinic-scai-walker .scai-circle.scai-blink{ animation: scaiPulse 1.4s infinite; box-shadow: 0 6px 18px rgba(0,0,0,0.12), 0 0 0 6px rgba(255,255,255,0.06); }
            @keyframes scaiPulse{ 0%{ transform:scale(1); } 50%{ transform:scale(1.06); } 100%{ transform:scale(1); } }
          `; document.head.appendChild(ss);
        }

        // Attach click handlers to clinic walker badges and start blink on active
        try{
          const badges = wrap.querySelectorAll('.clinic-scai-walker .scai-walker-badge');
          // Determine clinic-local active index
          const clinicActiveIdx = (window._clinicState && Number.isFinite(window._clinicState.active)) ? window._clinicState.active : (active ? all.findIndex((r,i)=> r===active || String(r.time)===String(active.time)) : -1);
          badges.forEach(b=>{
            try{
              const oi = b.getAttribute('data-orig-idx'); const origIdx = oi ? Number(oi) : -1;
              b.style.cursor = 'pointer';
              b.addEventListener('click', ()=>{ try{ window.setClinicActiveIndex(origIdx); createClinicQuickButtons(); }catch(e){} });
              // Blink only the active badge
              const circle = b.querySelector('.scai-circle');
              if(circle){
                if(Number.isFinite(clinicActiveIdx) && clinicActiveIdx === origIdx){ circle.classList.add('scai-blink'); }
                else { circle.classList.remove('scai-blink'); }
              }
            }catch(e){}
          });
        }catch(e){}
      }catch(e){ /* non-fatal: fall back to existing cards rendering */ }

      const get = (tp, key)=>{ if(!tp) return undefined; if(key in tp) return tp[key]; const low = key.toLowerCase(); if(low in tp) return tp[low]; const up = key.toUpperCase(); if(up in tp) return tp[up]; return undefined; };
      const num = (v)=>{ const n = Number(v); return Number.isFinite(n) ? n : null; };
      const truthy = (v)=>{ if(v===true) return true; if(typeof v==='number') return v!==0; if(typeof v==='string') return !/^\s*(0|false|no|off|n\/a|na)?\s*$/i.test(v); return !!v; };
      const DRUG_ABBR = { Norepinephrine:'NE', Epinephrine:'Epi', Dobutamine:'DOB', Dopamine:'DOP', Milrinone:'MIL', Vasopressin:'Vaso', Levosimendan:'LEVO' };

      const pillsForTP = (tp)=>{
        const pills = [];
        // Devices first
        const impFlow = num(get(tp, 'Impella_flow_Lmin'));
        const impOn = truthy(get(tp,'Impella')) || (impFlow!=null && impFlow>0);
        if(impOn){ pills.push(`<span class="support-pill mcs" title="Impella flow">Imp ${impFlow!=null? impFlow.toFixed(1)+' L/min':''}</span>`); }
        const ecmoFlow = num(get(tp, 'ECMO_flow_Lmin'));
        const ecmoOn = truthy(get(tp,'ECMO')) || (ecmoFlow!=null && ecmoFlow>0);
        if(ecmoOn){ pills.push(`<span class="support-pill mcs" title="ECMO flow">ECMO ${ecmoFlow!=null? ecmoFlow.toFixed(1)+' L/min':''}</span>`); }
        const iabpOn = truthy(get(tp,'IABP'));
        const iabpRatio = num(get(tp,'IABP_ratio'));
        if(iabpOn){ pills.push(`<span class="support-pill mcs" title="IABP">IABP${iabpRatio!=null? ' '+iabpRatio.toFixed(2):''}</span>`); }

        // Drugs: collect doses > 0
        const drugs = [];
        try{ Object.keys(DOSE_KEYS||{}).forEach(k=>{ const v = num(get(tp,k)); if(v!=null && v>0){ drugs.push({k, v}); } }); }catch(e){}
        // Sort by descending dose and show up to 3; if more, show +n
        drugs.sort((a,b)=> (b.v - a.v));
        const shown = drugs.slice(0,3);
        shown.forEach(d=>{ const abbr = DRUG_ABBR[d.k] || d.k; pills.push(`<span class="support-pill drug" title="${d.k}">${abbr} ${d.v.toFixed(2)}</span>`); });
        const extra = drugs.length - shown.length; if(extra>0){ pills.push(`<span class="support-pill more" title="more drugs">+${extra}</span>`); }
        return pills.join(' ');
      };

      const cards = vis.map(tp=>{
        const isActive = active && (tp===active || (String(tp.time)===String(active.time)));
        const title = (tp.label && String(tp.label).trim()) ? tp.label : (tp.time!==undefined? String(tp.time) : (tp.hours!==undefined? String(tp.hours)+'h' : 'TP'));
        return `<div class="support-tp${isActive?' active':''}"><div class="support-t"><strong>${escapeHtml(title)}</strong></div><div class="support-pills">${pillsForTP(tp)}</div></div>`;
      }).join('');

      wrap.innerHTML = `<div class="clinic-support-timeline">${cards}</div>`;
    }catch(e){ try{ console.warn('renderClinicSupportTimeline failed', e); }catch(_){} }
  }

  // Render grouped hemodynamic variables as horizontal strips for Clinic panel
  function renderClinicGroupedVars(clinicAll, activeClinic){
    try{
      const wrap = byId('clinicGroupedVars'); if(!wrap) return;
  const all = Array.isArray(clinicAll) ? clinicAll : (typeof collectAll === 'function' ? collectAll() : []);
  const active = activeClinic || all.find(r=>r.active && r.on) || all.find(r=>r.on) || all[0] || null;

      // Hide the legacy canonical legend (vertical key:value dump) to avoid duplicate output
      try{ const legacy = byId('pvLegendClinic'); if(legacy){ legacy.style.display = 'none'; legacy.innerHTML = '';
          // Prevent future updates (Plotly or other async code) from re-inserting content
          try{
            if(!legacy.__clinic_legend_observer){
              const obs = new MutationObserver(()=>{ try{ legacy.style.display='none'; legacy.innerHTML=''; }catch(e){} });
              obs.observe(legacy, { childList:true, subtree:true, characterData:true });
              legacy.__clinic_legend_observer = obs;
            }
          }catch(e){}
        } }catch(e){}

      // User-provided grouping (verbatim mapping)
      const GROUPS = {
        "Identification_Support": ["SCAI","devicesOn","drugsOn"],
        "Vitals_Arterial": ["HR","SBP","DBP","MAP"],
        "Perfusion": ["CO","CI","SV","SVI","Lactate","OPP","CPP"],
        "Filling Pressures": ["RAP","PCWP"],
        "RV_Function": ["sPAP","dPAP","mPAP","PAPI","RVSWi"],
        "Vascular_Resistance": ["SVR","SVRI","PVR_WU","PVRI_WU"],
        "LV_Function_Work": ["CPO","CPI","CPOa","CPIa","LVSWi"],
        "PV_Mechanics_VA_Coupling": ["ESP", "Ees","Ea","VAC","EDV","ESV","EF"],
        "EDPVR": ["V0_EDPVR","alpha","beta"],
        "Energetics_Power": ["SW","PE","PVA","Eff"],
        "Biochem_Organs": ["Creatinine","ALT", "pH","svO2"]
      };

      // decimals per variable (heuristic)
      const DECIMALS = { HR:0, SBP:0, DBP:0, MAP:0, ESP:0, CO:2, CI:2, SV:0, SVI:0, Lactate:2, pH:2, SvO2:0, OPP:0, CPP:0, RAP:0, PCWP:0, sPAP:0, dPAP:0, mPAP:0, SVR:0, SVRI:0, PVR_WU:2, PVRI_WU:2, EDV:0, ESV:0, EF:1, LVSWi:1, SW:0, Ees:2, Ea:2, VAC:2, PE:2, PVA:2, Eff:1, CPO:2, CPI:2, CPOa:2, CPIa:2, PAPI:1, RVSWi:1, Creat:2, ALT:0,
        // EDPVR
        V0_EDPVR:0, alpha:2, beta:2, P_EDPVR_at_EDV:2 };

      // Units mapping for clinical variables (displayed after value)
      const UNITS = {
        HR: 'bpm', SBP: 'mmHg', DBP: 'mmHg', MAP: 'mmHg', ESP: 'mmHg', RAP: 'mmHg', PCWP: 'mmHg', sPAP: 'mmHg', dPAP: 'mmHg', mPAP: 'mmHg',
        CO: 'L/min', CI: 'L/min/m²', SV: 'mL', SVI: 'mL/m²', SVR: 'dyn·s·cm⁻⁵', SVRI: 'dyn·s·cm⁻⁵·m²', PVR_WU: 'WU', PVRI_WU: 'WU·m²',
        PAPI: '', pH: '', Lactate: 'mmol/L', SvO2: '%', Creat: 'mg/dL', ALT: 'U/L',
        EDV: 'mL', ESV: 'mL', EF: '%', Ees: 'mmHg/mL', Ea: 'mmHg/mL', VAC: '',
        SW: 'mmHg·mL', PE: 'mmHg·mL', PVA: 'mmHg·mL', Eff: '%', CPO: 'W', CPI: 'W/m²', CPOa: 'W', CPIa: 'W/m²',
        OPP: 'mmHg', CPP: 'mmHg', LVSWi: 'g·m/m²', RVSWi: 'g·m/m²'
        // EDPVR units
        , V0_EDPVR: 'mL'
      };
      // Add unit alias for Creatinine (user-facing group uses 'Creatinine')
      UNITS['Creatinine'] = UNITS['Creat'] || 'mg/dL';

      // Pretty labels for display (replace raw keys)
      const LABELS = {
        V0_EDPVR: 'V₀',
        beta: 'β',
        alpha: 'α',
        P_EDPVR_at_EDV: 'P@EDV',
        SvO2: 'SvO₂',
        svO2: 'SvO₂',
        Creatinine: 'Creatinine',
        // Identification / support pretty names
        SCAI: 'SCAI',
        devicesOn: 'Devices',
        drugsOn: 'Drugs',
        inotropesOn: 'Inotropes',
        pressorsOn: 'Pressors',
        ABP: 'ABP',
        IMPELLA: 'IMPELLA',
        ECMO: 'ECMO',
        VAD: 'VAD'
      };

      // helpers that try fallbacks (canonical / upper / lower) for decimals & units
      const getDecimalFor = function(name){ if(name in DECIMALS) return DECIMALS[name]; try{ if(typeof canonicalOfVar === 'function'){ const c = canonicalOfVar(name); if(c && (c in DECIMALS)) return DECIMALS[c]; } }catch(e){} const up = name.toUpperCase(); if(up in DECIMALS) return DECIMALS[up]; const low = name.toLowerCase(); if(low in DECIMALS) return DECIMALS[low]; return undefined; };
      const getUnitFor = function(name){ if(name in UNITS) return UNITS[name]; try{ if(typeof canonicalOfVar === 'function'){ const c = canonicalOfVar(name); if(c && (c in UNITS)) return UNITS[c]; } }catch(e){} const up = name.toUpperCase(); if(up in UNITS) return UNITS[up]; const low = name.toLowerCase(); if(low in UNITS) return UNITS[low]; return undefined; };

  // robust formatter returning both display text and optional reason for missing/overflow
  const fmtInfo = function(v, d){
        // missing or empty
        if(v===null || v===undefined || v==='') return { text:'—', reason:'missing' };
        // numbers: check finite
        if(typeof v === 'number'){
          if(!Number.isFinite(v)) return { text:'—', reason:'not-finite' };
          if(!Number.isFinite(d)) d = 2;
          if(Math.abs(v) > 1e6) return { text:'—', reason:'overflow' };
          return { text: v.toFixed(d), reason: null };
        }
        // try parseable numeric strings
        const n = Number(v);
        if(!Number.isNaN(n) && Number.isFinite(n)){
          if(!Number.isFinite(d)) d = 2;
          if(Math.abs(n) > 1e6) return { text:'—', reason:'overflow' };
          return { text: n.toFixed(d), reason: null };
        }
        // fallback: plain string
        return { text: String(v), reason: null };
      };

      const tryGet = function(tp, key){
        if(!tp) return undefined;
        if(key in tp) return tp[key];
        try{
          // try canonical mapping and common casing
          if(typeof canonicalOfVar === 'function'){
            const canon = canonicalOfVar(key);
            if(canon && (canon in tp)) return tp[canon];
          }
        }catch(e){}
        const low = key.toLowerCase(); if(low in tp) return tp[low];
        const up = key.toUpperCase(); if(up in tp) return tp[up];
        return undefined;
      };

      const fmt = function(v, d){ if(v===null || v===undefined || v==='') return '—'; if(typeof v === 'number' && Number.isFinite(v)){ if(!Number.isFinite(d)) d = 2; return v.toFixed(d); } return String(v); };

  // Build HTML with inline flex layout to force horizontal 'listones'
  let html = '<div class="variables-grid" style="display:flex;flex-direction:column;gap:12px;">';
  // temporary holder for support summary to insert as its own row after Identification_Support
  let pendingSupportLine = null;
      for(const gKey of Object.keys(GROUPS)){
        const vars = GROUPS[gKey];
        const title = gKey.replace(/_/g,' ');
        // variable-category: left title column (fixed) + right scrollable chip row
        html += `<div class="variable-category" style="display:flex;align-items:center;gap:12px;padding:8px;border-radius:8px;background:rgba(14,165,164,0.03);border:1px solid rgba(14,165,164,0.04);">`;
        html += `<div class="category-title" style="flex:0 0 180px;padding-right:12px;border-right:1px solid rgba(14,165,164,0.06);font-weight:700;color:var(--clinic-accent);">${escapeHtml(title)}</div>`;
  // Render variable list as wrap-capable and limit height to two rows to avoid horizontal sliding
  html += `<div class="variable-list" style="display:flex;gap:8px;align-items:flex-start;flex-wrap:wrap;padding-left:12px;flex:1;max-height:64px;overflow:visible;">`;
        // Render variables as plain inline text (name: value) rather than button-like chips

        // If this is Identification_Support, compute the support summary and save it to render as its own full-width row later
        if(gKey === 'Identification_Support'){
          try{
            const supportsArr = [];
            const impFlow = tryGet(active, 'Impella_flow_Lmin');
            const impOn = tryGet(active, 'Impella') || (Number.isFinite(Number(impFlow)) && Number(impFlow) > 0);
            if(impOn){ supportsArr.push({ name: 'Impella', dose: impFlow, unit: 'L/min' }); }
            const ecmoFlow = tryGet(active, 'ECMO_flow_Lmin');
            const ecmoOn = tryGet(active, 'ECMO') || (Number.isFinite(Number(ecmoFlow)) && Number(ecmoFlow) > 0);
            if(ecmoOn){ supportsArr.push({ name: 'ECMO', dose: ecmoFlow, unit: 'L/min' }); }
            const iabpOn = tryGet(active, 'IABP');
            const iabpRatio = tryGet(active, 'IABP_ratio');
            if(iabpOn){ supportsArr.push({ name: 'IABP', dose: iabpRatio || null, unit: '' }); }
            const vadOn = tryGet(active, 'VAD'); if(vadOn) supportsArr.push({ name: 'VAD', dose: null, unit: '' });

            try{ Object.keys(DOSE_KEYS || {}).forEach(dk=>{ try{ const val = tryGet(active, dk); if(Number.isFinite(Number(val)) && Number(val) > 0){ supportsArr.push({ name: dk, dose: Number(val), unit: (DOSE_KEYS[dk] && DOSE_KEYS[dk].unit) || '' }); } }catch(e){} }); }catch(e){}

            if(supportsArr.length){
              const parts = supportsArr.map(s=>{ const dec = getDecimalFor(s.name) !== undefined ? getDecimalFor(s.name) : 2; const f = (s.dose!==null && s.dose!==undefined) ? fmtInfo(s.dose, dec).text : null; return f ? `${LABELS[s.name] || s.name} ${f}${s.unit? (' ' + s.unit) : ''}` : `${LABELS[s.name] || s.name}`; });
              const supportLine = parts.join(' · ');
              // Save support line to insert after this category so it sits between Identification and the next category
              pendingSupportLine = supportLine;
            }
          }catch(e){ }
        }

        vars.forEach(vname=>{
          // raw value used for presence checks
          const rawVal = tryGet(active, vname);
          // hide-if-empty list for identification/support row
          const HIDE_IF_FALSE = new Set(['inotropesOn','pressorsOn','IABP','IMPELLA','ECMO','VAD']);
          const absentStrings = new Set(['-','—','false','no','n/a','na','']);
          if(HIDE_IF_FALSE.has(vname)){
            // consider falsy or explicit absent markers as absent
            if(rawVal === false || rawVal === null || rawVal === undefined) return;
            // numeric zero (including floats) should be treated as absent
            if(typeof rawVal === 'number' && rawVal === 0) return;
            // numeric strings like '0', '0.0', '0.00' should be treated as absent
            if(typeof rawVal === 'string'){ const trimmed = rawVal.trim(); const num = Number(trimmed); if(trimmed === '' || (!Number.isNaN(num) && Number.isFinite(num) && num === 0)) return; if(absentStrings.has(trimmed.toLowerCase())) return; }
            if(Array.isArray(rawVal) && rawVal.length === 0) return;
          }
          let val = rawVal;
          // friendly rendering for identification/support booleans and flags
          if(vname === 'ABP'){
            // sometimes ABP is boolean-like or numeric
            if(val === true) val = 'Yes';
            else if(val === false) val = 'No';
          }
          if(/On$/.test(vname) || ['devicesOn','drugsOn','inotropesOn','pressorsOn'].includes(vname)){
            if(val === true) val = 'Yes';
            else if(val === false) val = 'No';
            // some of these are numeric flags (0/1 or counts)
            else if(Number.isFinite(Number(val))) val = Number(val);
          }
          // Special-case computed EDPVR pressure at EDV
          if(vname === 'P_EDPVR_at_EDV'){
            // compute from alpha * (exp(beta*(EDV - V0)) - 1)
            try{
              const EDV = tryGet(active, 'EDV');
              const V0 = tryGet(active, 'V0_EDPVR');
              const alpha = tryGet(active, 'alpha');
              const beta = tryGet(active, 'beta');
              if(Number.isFinite(EDV) && Number.isFinite(V0) && Number.isFinite(alpha) && Number.isFinite(beta)){
                const p = alpha * (Math.exp(beta * (EDV - V0)) - 1);
                val = p;
              } else {
                // fallback: try reading an existing scalar P_EDPVR if present
                const pArr = tryGet(active, 'P_EDPVR');
                if(Array.isArray(pArr) && pArr.length>0){
                  // if P_EDPVR aligns with V_loop, try to find last value or value at EDV index is not trivial; show last as fallback
                  val = pArr[pArr.length-1];
                }
              }
            }catch(e){ /* ignore compute errors */ }
          }
          // special formatting: alpha -> scientific 0.00E+00, beta -> 2 decimals
          let dec = getDecimalFor(vname) !== undefined ? getDecimalFor(vname) : 2;
          let res;
          if(vname === 'alpha'){
            // format in scientific notation with 2 decimal mantissa and exponent
            if(typeof val === 'number' && Number.isFinite(val)){
              const sign = val < 0 ? '-' : '';
              const abs = Math.abs(val);
              const exp = abs === 0 ? 0 : Math.floor(Math.log10(abs));
              const mant = abs === 0 ? 0 : abs / Math.pow(10, exp);
              const mantStr = mant.toFixed(2);
              const expStr = (exp >= 0 ? '+' : '') + String(exp).padStart(2,'0');
              res = { text: `${sign}${mantStr}E${expStr}`, reason: null };
            } else {
              res = fmtInfo(val, 2);
            }
          } else if(vname === 'beta'){
            dec = 2;
            res = fmtInfo(val, dec);
          } else {
            res = fmtInfo(val, dec);
          }
          const disp = res.text;
          const reason = res.reason;
          const unit = getUnitFor(vname) || '';
          const dispWithUnit = unit ? (disp + ' ' + unit) : disp;
          const pretty = LABELS[vname] || LABELS[vname.toLowerCase()] || vname;
          const titleAttr = reason ? (` title="${escapeHtml(reason)}"`) : '';
          // render as horizontal chip with name and value as separate spans for styling
          html += `<span class="variable-item"${titleAttr}><span class="variable-name">${escapeHtml(pretty)}:</span> <span class="variable-val">${escapeHtml(dispWithUnit)}</span></span>`;
        });
        html += '</div></div>';
        // If we computed a support summary for Identification_Support, render it as its own full-width row below this category
        try{
          if(pendingSupportLine && gKey === 'Identification_Support'){
            html += `<div class="variable-category" style="display:flex;align-items:center;gap:12px;padding:6px;border-radius:6px;background:rgba(14,165,164,0.02);border:1px solid rgba(14,165,164,0.03);">`;
            html += `<div style="flex:0 0 180px;padding-right:12px;border-right:1px solid rgba(14,165,164,0.04);"></div>`;
            html += `<div style="flex:1;padding-left:12px;font-size:13px;color:#234">Support: <strong>${escapeHtml(pendingSupportLine)}</strong></div>`;
            html += `</div>`;
            pendingSupportLine = null;
          }
        }catch(e){}
      }
      html += '</div>';
      // Replace content forcefully
      wrap.innerHTML = html;
    }catch(e){ console.warn('renderClinicGroupedVars failed', e); }
  }

  function wireClinicControls(){
    // quick time buttons
    // Build dynamic quick buttons from dashboard timepoints
    try{ createClinicQuickButtons(); }catch(e){}

    // update when patient fields change
    ['patientName','ptAge','ptSex','ptH','ptW'].forEach(id=>{ const el = byId(id); if(el){ el.addEventListener('input', renderClinicPanel); el.addEventListener('change', renderClinicPanel); } });
    // CS Type radios: lightweight immediate update (no heavy full regenerate) to avoid perceived lag
    try{
      document.querySelectorAll('input[name="csType"]').forEach(el=>{
        if(!el.dataset.wiredCsType){
          el.addEventListener('change', ()=>{ try{ renderClinicPanel(); }catch(e){} });
          el.dataset.wiredCsType = '1';
        }
      });
    }catch(e){ /* ignore if element missing */ }
    // update when timepoints change
    const tpWrap = byId('tpInputs'); if(tpWrap){ const obs = new MutationObserver(()=>{ renderClinicPanel(); }); obs.observe(tpWrap, { childList:true, subtree:true, attributes:true }); }

    // when clinic tab clicked, render after slight delay to allow layout
    const tabBtn = document.querySelector('header .tabs .tab[data-tab="clinic"]'); if(tabBtn) tabBtn.addEventListener('click', ()=>{ setTimeout(()=>{ try{ renderClinicPanel(); // ensure plotly resize a bit later
  setTimeout(()=>{ try{ const plotEl = document.querySelector('#clinicPVPlot'); safePlotlyResize(plotEl); }catch(e){} }, 300);
    }catch(e){} }, 120); });
    // also resize on window resize to keep layout responsive
  window.addEventListener('resize', ()=>{ try{ const plotEl = document.querySelector('#clinicPVPlot'); safePlotlyResize(plotEl); }catch(e){} });
  // Also resize main PV plot when window resizes (with debounce to avoid excessive calls)
  window.addEventListener('resize', debounce(()=>{ 
    try{ 
      const plotEl = document.querySelector('#plotPV'); 
      // Add small delay to let CSS settle
      setTimeout(()=>safePlotlyResize(plotEl), 50); 
    }catch(e){} 
  }, 150));
    // initial render
    window.addEventListener('load', ()=>{ try{ renderClinicPanel(); }catch(e){} });
  }

  // Clinic PV times menu: alias to new creator
  function refreshClinicPVTimesMenu(){ try{ createClinicTimesMenu(); }catch(e){ console.warn('refreshClinicPVTimesMenu failed', e); } }

  // Build the Clinic-specific times menu from collectAll() (keeps same labels/order as Dashboard)
  function createClinicTimesMenu(){
    const menu = byId('clinicPvTimesMenu'); if(!menu) return;
    try{
      const all = (typeof collectAll === 'function') ? collectAll() : [];
      // ensure clinic state length matches
  // Default: all timepoints should be shown (active) unless the user explicitly changes them.
  // If an existing _clinicState is present but has a different length (old patient), replace shown with all-true.
  const defaultShown = all.map(()=> true);
  const existingShown = (window._clinicState && Array.isArray(window._clinicState.shown)) ? window._clinicState.shown : null;
  const shown = (existingShown && existingShown.length === all.length) ? existingShown.map(v=> typeof v === 'boolean' ? v : true) : defaultShown;
  window._clinicState = window._clinicState || {};
  window._clinicState.shown = shown;
  window._clinicState.active = (window._clinicState.active !== undefined) ? window._clinicState.active : (all.findIndex(r=>r.active&&r.on)>=0? all.findIndex(r=>r.active&&r.on): (all.findIndex(r=>r.on)>=0? all.findIndex(r=>r.on):0));
      // Clear
      menu.innerHTML = '';
      const header = document.createElement('div'); header.style.padding='8px 12px'; header.innerHTML = '<b>Timepoints</b>'; menu.appendChild(header);
      all.forEach((tp,i)=>{
        const row = document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.justifyContent='space-between'; row.style.padding='6px 10px';
        const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
        const chk = document.createElement('input'); chk.type='checkbox'; chk.id = `clinic_t_on_${i}`; chk.checked = !!(window._clinicState.shown && window._clinicState.shown[i]); chk.style.marginRight='8px';
        chk.addEventListener('change', ()=>{ window._clinicState.shown[i] = !!chk.checked; renderClinicPanel(); });
        const lbl = document.createElement('div'); lbl.textContent = (tp && (tp.time!==undefined? tp.time : tp.hours!==undefined? tp.hours : i)) + (tp && tp.label ? (' — ' + tp.label) : ''); lbl.style.minWidth='48px';
        left.appendChild(chk); left.appendChild(lbl);
        const right = document.createElement('div');
        const actBtn = document.createElement('button'); actBtn.className='btn small'; actBtn.textContent = (i===window._clinicState.active)? 'Active' : 'Make active'; actBtn.style.marginLeft='8px';
        actBtn.addEventListener('click', ()=>{ window.setClinicActiveIndex(i); createClinicTimesMenu(); });
        right.appendChild(actBtn);
        row.appendChild(left); row.appendChild(right); menu.appendChild(row);
      });
      const footer = document.createElement('div'); footer.style.padding='8px 12px'; footer.innerHTML = '<button class="btn" id="clinic_first_last">First & Last</button> <button class="btn" id="clinic_active_all">Active all</button> <button class="btn" id="clinic_sync_dash">Sync with Dashboard</button>';
      menu.appendChild(footer);
      byId('clinic_first_last')?.addEventListener('click', ()=>{ if(all.length>0){ window._clinicState.shown = window._clinicState.shown.map((v,idx)=> idx===0 || idx===all.length-1); window._clinicState.active = 0; renderClinicPanel(); createClinicTimesMenu(); } });
      byId('clinic_active_all')?.addEventListener('click', ()=>{ window._clinicState.shown = window._clinicState.shown.map(()=> true); renderClinicPanel(); createClinicTimesMenu(); });
      byId('clinic_sync_dash')?.addEventListener('click', ()=>{ try{ const src = (typeof collectAll === 'function') ? collectAll() : []; window._clinicState.shown = src.map(s=>!!s.on); window._clinicState.active = src.findIndex(r=>r.active&&r.on)>=0? src.findIndex(r=>r.active&&r.on) : (src.findIndex(r=>r.on)>=0? src.findIndex(r=>r.on):0); renderClinicPanel(); createClinicTimesMenu(); }catch(e){ console.warn('clinic sync failed', e); } });
    }catch(e){ console.warn('createClinicTimesMenu failed', e); }
  }

  // clinic quick button toggle
  byId('clinicBtnPVQuick')?.addEventListener('click', (e)=>{
    const menu = byId('clinicPvTimesMenu'); if(!menu) return; const showing = menu.style.display !== 'none';
    if(showing){ menu.style.display='none'; }
    else { try{ createClinicTimesMenu(); }catch(e){} menu.style.display='block'; try{ adjustPopoverPosition(menu); }catch(e){} }
  });

  // Keep clinic menu in sync when timepoints change
  const clinicPvMenuObserver = new MutationObserver(()=>{ const menu = byId('clinicPvTimesMenu'); if(menu && menu.style.display!=='none') createClinicTimesMenu(); });
  const tpWrapClinic = byId('tpInputs'); if(tpWrapClinic) clinicPvMenuObserver.observe(tpWrapClinic, { childList:true, subtree:true, attributes:true });

  // End of clinic wiring
  
  // --- Additional small helpers for view & palette toggles are added below in a separate script block ---

  window.renderClinicPanel = renderClinicPanel; window.wireClinicControls = wireClinicControls; try{ wireClinicControls(); }catch(e){ console.warn(e); }
</script>

<!-- Module loader: incremental migration of inline logic into ES modules (non-destructive) -->
<script type="module">
  // Only try to import if we're running from HTTP server (not file:// protocol)
  if(window.location.protocol === 'http:' || window.location.protocol === 'https:') {
    import('./lib/timepoints.js').then(mod=>{
      if(window.timepoints && window.applyReadOnly === undefined) window.applyReadOnly = window.timepoints.applyReadOnly;
      if(window.timepoints && window.addTP === undefined) window.addTP = window.timepoints.addTP;
    }).catch(err=>{ console.warn('Failed to load timepoints module', err); });
  } else {
  }
</script>

</body>
</html>
